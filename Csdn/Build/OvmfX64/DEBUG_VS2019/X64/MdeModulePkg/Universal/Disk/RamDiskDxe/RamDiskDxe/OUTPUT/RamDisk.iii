#line 1 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\OUTPUT\\.\\RamDisk.i"
#line 1 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\AutoGen.h"
/**
  DO NOT EDIT
  FILE auto-generated
  Module name:
    AutoGen.h
  Abstract:       Auto-generated AutoGen.h for building module or library.
**/








#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\PiDxe.h"
/** @file

  Root include file for Mde Package DXE_CORE, DXE, RUNTIME, SMM, SAL type modules.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"
/** @file
  Defines data types and constants introduced in UEFI.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2011 - 2016, ARM Ltd. All rights reserved.<BR>
Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
Copyright (c) 2022, Loongson Technology Corporation Limited. All rights reserved.<BR>

SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
/** @file
  Root include file for Mde Package Base type modules

  This is the include file for any module of type base. Base modules only use
  types defined via this include file and can be ported easily to any
  environment. There are a set of base libraries in the Mde Package that can
  be used to implement base modules.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




//
// Include processor specific binding
//
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"
/** @file
  Processor or Compiler specific defines and types x64 (Intel 64, AMD64).

  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




///
/// Define the processor type so other code can make processor based choices
///


//
// Make sure we are using the correct packing rules per EFI specification
//

  #pragma pack()
#line 23 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"


























#line 50 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"



//
// Disable warning that make it impossible to compile at /W4
// This only works for Microsoft* tools
//

//
// Disabling bitfield type checking warnings.
//
  #pragma warning ( disable : 4214 )

//
// Disabling the unreferenced formal parameter warnings.
//
  #pragma warning ( disable : 4100 )

//
// Disable slightly different base types warning as CHAR8 * can not be set
// to a constant string.
//
  #pragma warning ( disable : 4057 )

//
// ASSERT(FALSE) or while (TRUE) are legal constructs so suppress this warning
//
  #pragma warning ( disable : 4127 )

//
// This warning is caused by functions defined but not used. For precompiled header only.
//
  #pragma warning ( disable : 4505 )

//
// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
//
  #pragma warning ( disable : 4206 )

  

//
// This warning is for potentially uninitialized local variable, and it may cause false
// positive issues in VS2015 build
//
    #pragma warning ( disable : 4701 )

//
// This warning is for potentially uninitialized local pointer variable, and it may cause
// false positive issues in VS2015 build
//
    #pragma warning ( disable : 4703 )

  #line 104 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"

#line 106 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"


//
// use Microsoft C compiler dependent integer width types
//

///
/// 8-byte unsigned value
///
typedef unsigned __int64 UINT64;
///
/// 8-byte signed value
///
typedef __int64 INT64;
///
/// 4-byte unsigned value
///
typedef unsigned __int32 UINT32;
///
/// 4-byte signed value
///
typedef __int32 INT32;
///
/// 2-byte unsigned value
///
typedef unsigned short UINT16;
///
/// 2-byte Character.  Unless otherwise specified all strings are stored in the
/// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
///
typedef unsigned short CHAR16;
///
/// 2-byte signed value
///
typedef short INT16;
///
/// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
/// values are undefined.
///
typedef unsigned char BOOLEAN;
///
/// 1-byte unsigned value
///
typedef unsigned char UINT8;
///
/// 1-byte Character
///
typedef char CHAR8;
///
/// 1-byte signed value
///
typedef signed char INT8;















































#line 206 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"

///
/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions,
/// 8 bytes on supported 64-bit processor instructions)
///
typedef UINT64 UINTN;
///
/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions,
/// 8 bytes on supported 64-bit processor instructions)
///
typedef INT64 INTN;

//
// Processor specific defines
//

///
/// A value of native width with the highest bit set.
///

///
/// A value of native width with the two highest bits set.
///


///
/// Maximum legal x64 address
///


///
/// Maximum usable address at boot time
///


///
/// Maximum legal x64 INTN and UINTN values.
///



///
/// Minimum legal x64 INTN value.
///


///
/// The stack alignment required for x64
///


///
/// Page allocation granularity for x64
///



//
// Modifier to ensure that all protocol member functions and EFI intrinsics
// use the correct C calling convention. All protocol member functions and
// EFI intrinsics are required to modify their member functions with EFIAPI.
//





///
/// Microsoft* compiler specific method for EFIAPI calling convention.
///

















#line 294 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"







#line 302 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"

/**
  Return the pointer to the first instruction of a function given a function pointer.
  On x64 CPU architectures, these two pointer values are the same,
  so the implementation of this macro is very simple.

  @param  FunctionPointer   A pointer to a function.

  @return The pointer to the first instruction of a function given a function pointer.

**/




#line 318 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"

#line 320 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\X64\\ProcessorBind.h"
#line 22 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"


//
// Disable warning when last field of data structure is a zero sized array.
//
  #pragma warning ( disable : 4200 )
#line 29 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// The Microsoft* C compiler can removed references to unreferenced data items
//  if the /OPT:REF linker option is used. We defined a macro as this is a
//  a non standard extension
//







#line 43 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
///
/// Remove the global variable from the linked image if there are no references
///  to it after all compiler and linker optimizations have been performed.
///
///

#line 50 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with NORETURN to avoid 'noreturn' returns
// warnings.
//

  













#line 71 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

  
///
/// Signal compilers and analyzers that this call is not reachable.  It is
/// up to the compiler to remove any code past that point.
///

  #line 79 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 80 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Signaling compilers and analyzers that a certain function cannot return may
// remove all following code and thus lead to better optimization and less
// false positives.
//

  






#line 95 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
///
/// Signal compilers and analyzers that the function cannot return.
/// It is up to the compiler to remove any code past a call to functions
/// flagged with this attribute.
///

  






#line 109 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 110 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with ANALYZER_NORETURN to avoid 'noreturn'
// returns warnings.
//

  









  
///
/// Signal the analyzer that this call is not reachable.
/// This excludes compilers.
///

  #line 133 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 134 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Static Analyzers may issue errors about potential NULL-dereferences when
// dereferencing a pointer, that has been checked before, outside of a
// NULL-check.  This may lead to false positives, such as when using ASSERT()
// for verification.
//

  









  
///
/// Signal the analyzer that the function cannot return.
/// This excludes compilers.
///

  #line 159 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 160 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

///
/// Tell the code optimizer that the function will return twice.
/// This prevents wrong optimizations which can cause bugs.
///

  





#line 173 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
///
/// Tell the code optimizer that the function will return twice.
/// This prevents wrong optimizations which can cause bugs.
///

  #line 179 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 180 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// For symbol name in assembly code, an extra "_" is sometimes necessary
//

///
/// Private worker functions for ASM_PFX()
///



///
/// The __USER_LABEL_PREFIX__ macro predefined by GNUC represents the prefix
/// on symbols in assembly language.
///










#line 206 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"



///
/// 128 bit buffer containing a unique identifier value.
/// Unless otherwise specified, aligned on a 64 bit boundary.
///
typedef struct {
  UINT32    Data1;
  UINT16    Data2;
  UINT16    Data3;
  UINT8     Data4[8];
} GUID;

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
typedef struct {
  UINT8    Addr[4];
} IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
typedef struct {
  UINT8    Addr[16];
} IPv6_ADDRESS;

//
// 8-bytes unsigned value that represents a physical system address.
//
typedef UINT64 PHYSICAL_ADDRESS;

///
/// LIST_ENTRY structure definition.
///
typedef struct _LIST_ENTRY LIST_ENTRY;

///
/// _LIST_ENTRY structure definition.
///
struct _LIST_ENTRY {
  LIST_ENTRY    *ForwardLink;
  LIST_ENTRY    *BackLink;
};

//
// Modifiers to abstract standard types to aid in debug of problems
//

///
/// Datum is read-only.
///


///
/// Datum is scoped to the current file or function.
///


///
/// Undeclared type.
///


//
// Modifiers for Data Types used to self document code.
// This concept is borrowed for UEFI specification.
//

///
/// Datum is passed to the function.
///


///
/// Datum is returned from the function.
///


///
/// Passing the datum to the function is optional, and a NULL
/// is passed if the value is not supplied.
///


//
//  UEFI specification claims 1 and 0. We are concerned about the
//  compiler portability so we did it this way.
//

///
/// Boolean true value.  UEFI Specification defines this value to be 1,
/// but this form is more portable.
///


///
/// Boolean false value.  UEFI Specification defines this value to be 0,
/// but this form is more portable.
///


///
/// NULL pointer (VOID *)
///






#line 319 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

#line 321 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Null character
//


///
/// Maximum values for common UEFI Data Types
///









///
/// Minimum values for the signed UEFI Data Types
///




















































































































































































//
//  Support for variable argument lists in freestanding edk2 modules.
//
//  For modules that use the ISO C library interfaces for variable
//  argument lists, refer to "StdLib/Include/stdarg.h".
//
//  VA_LIST  - typedef for argument list.
//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
//  VA_END (VA_LIST Marker) - Clear Marker
//  VA_ARG (VA_LIST Marker, var arg type) - Use Marker to get an argument from
//    the ... list. You must know the type and pass it in this macro.  Type
//    must be compatible with the type of the actual next argument (as promoted
//    according to the default argument promotions.)
//  VA_COPY (VA_LIST Dest, VA_LIST Start) - Initialize Dest as a copy of Start.
//
//  Example:
//
//  UINTN
//  EFIAPI
//  ExampleVarArg (
//    IN UINTN  NumberOfArgs,
//    ...
//    )
//  {
//    VA_LIST Marker;
//    UINTN   Index;
//    UINTN   Result;
//
//    //
//    // Initialize the Marker
//    //
//    VA_START (Marker, NumberOfArgs);
//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
//      //
//      // The ... list is a series of UINTN values, so sum them up.
//      //
//      Result += VA_ARG (Marker, UINTN);
//    }
//
//    VA_END (Marker);
//    return Result;
//  }
//
//  Notes:
//  - Functions that call VA_START() / VA_END() must have a variable
//    argument list and must be declared EFIAPI.
//  - Functions that call VA_COPY() / VA_END() must be declared EFIAPI.
//  - Functions that only use VA_LIST and VA_ARG() need not be EFIAPI.
//

/**
  Return the size of argument that has been aligned to sizeof (UINTN).

  @param  n    The parameter size to be aligned.

  @return The aligned size.
**/














#line 594 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"












































#line 639 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
///
/// Variable used to traverse the list of arguments. This type can vary by
/// implementation and could be an array or structure.
///
typedef CHAR8 *VA_LIST;

/**
  Retrieves a pointer to the beginning of a variable argument list, based on
  the name of the parameter that immediately precedes the variable argument list.

  This function initializes Marker to point to the beginning of the variable
  argument list that immediately follows Parameter.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the
  EFIAPI ABI.

  @param   Marker       The VA_LIST used to traverse the list of arguments.
  @param   Parameter    The name of the parameter that immediately precedes
                        the variable argument list.

  @return  A pointer to the beginning of a variable argument list.

**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the EFIAPI ABI.

  @param   Marker   VA_LIST used to traverse the list of arguments.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  Terminates the use of a variable argument list.

  This function initializes Marker so it can no longer be used with VA_ARG().
  After this macro is used, the only way to access the variable argument list is
  by using VA_START() again.

  @param   Marker   VA_LIST used to traverse the list of arguments.

**/


/**
  Initializes a VA_LIST as a copy of an existing VA_LIST.

  This macro initializes Dest as a copy of Start, as if the VA_START macro had been applied to Dest
  followed by the same sequence of uses of the VA_ARG macro as had previously been used to reach
  the present state of Start.

  @param   Dest   VA_LIST used to traverse the list of arguments.
  @param   Start  VA_LIST used to traverse the list of arguments.

**/


#line 707 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

///
/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
///
typedef UINTN *BASE_LIST;

/**
  Returns the size of a data type in sizeof(UINTN) units rounded up to the nearest UINTN boundary.

  @param  TYPE  The date type to determine the size of.

  @return The size of TYPE in sizeof (UINTN) units rounded up to the nearest UINTN boundary.
**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU specific following the EFIAPI ABI.

  @param   Marker   The pointer to the beginning of a variable argument list.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  The macro that returns the byte offset of a field in a data structure.

  This function returns the offset, in bytes, of field specified by Field from the
  beginning of the  data structure specified by TYPE. If TYPE does not contain Field,
  the module will not compile.

  @param   TYPE     The name of the data structure that contains the field specified by Field.
  @param   Field    The name of the field in the data structure.

  @return  Offset, in bytes, of field.

**/


#line 756 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"



#line 760 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

/**
  Returns the alignment requirement of a type.

  @param   TYPE  The name of the type to retrieve the alignment requirement of.

  @return  Alignment requirement, in Bytes, of TYPE.
**/





#line 774 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
//
// All supported versions of GCC and Clang, as well as MSVC 2015 and later,
// support the standard operator _Alignof.
//















#line 794 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

/**
  Portable definition for compile time assertions.
  Equivalent to C11 static_assert macro from assert.h.

  @param  Expression  Boolean expression.
  @param  Message     Raised compiler diagnostic message when expression is false.

**/






#line 810 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

//
// Verify that ProcessorBind.h produced UEFI Data Types that are compliant with
// Section 2.3.1 of the UEFI 2.3 Specification.
//

static_assert (sizeof (BOOLEAN) == 1, "sizeof (BOOLEAN) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT8)    == 1, "sizeof (INT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT8)   == 1, "sizeof (UINT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT16)   == 2, "sizeof (INT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT16)  == 2, "sizeof (UINT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT32)   == 4, "sizeof (INT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT32)  == 4, "sizeof (UINT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT64)   == 8, "sizeof (INT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT64)  == 8, "sizeof (UINT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR8)   == 1, "sizeof (CHAR8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR16)  == 2, "sizeof (CHAR16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L'A')    == 2, "sizeof (L'A') does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L"A")    == 4, "sizeof (L\"A\") does not meet UEFI Specification Data Type requirements");

static_assert (_Alignof (BOOLEAN) == sizeof (BOOLEAN), "Alignment of BOOLEAN does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (INT8)    == sizeof (INT8), "Alignment of INT8 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (UINT8)   == sizeof (UINT8), "Alignment of INT16 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (INT16)   == sizeof (INT16), "Alignment of INT16 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (UINT16)  == sizeof (UINT16), "Alignment of UINT16 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (INT32)   == sizeof (INT32), "Alignment of INT32 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (UINT32)  == sizeof (UINT32), "Alignment of UINT32 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (INT64)   == sizeof (INT64), "Alignment of INT64 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (UINT64)  == sizeof (UINT64), "Alignment of UINT64 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (CHAR8)   == sizeof (CHAR8), "Alignment of CHAR8 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (CHAR16)  == sizeof (CHAR16), "Alignment of CHAR16 does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (INTN)    == sizeof (INTN), "Alignment of INTN does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (UINTN)   == sizeof (UINTN), "Alignment of UINTN does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (void *)  == sizeof (void *), "Alignment of VOID * does not meet UEFI Specification Data Type requirements");

//
// The following three enum types are used to verify that the compiler
// configuration for enum types is compliant with Section 2.3.1 of the
// UEFI 2.3.1 Errata C Specification. These enum types and enum values
// are not intended to be used. A prefix of '__' is used avoid
// conflicts with other types.
//
typedef enum {
  __VerifyUint8EnumValue = 0xff
} __VERIFY_UINT8_ENUM_SIZE;

typedef enum {
  __VerifyUint16EnumValue = 0xffff
} __VERIFY_UINT16_ENUM_SIZE;

typedef enum {
  __VerifyInt32EnumValue = 0x7fffffff
} __VERIFY_INT32_ENUM_SIZE;

static_assert (sizeof (__VERIFY_UINT8_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_UINT16_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_INT32_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");

static_assert (_Alignof (__VERIFY_UINT8_ENUM_SIZE)  == sizeof (__VERIFY_UINT8_ENUM_SIZE), "Alignment of enum does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (__VERIFY_UINT16_ENUM_SIZE) == sizeof (__VERIFY_UINT16_ENUM_SIZE), "Alignment of enum does not meet UEFI Specification Data Type requirements");
static_assert (_Alignof (__VERIFY_INT32_ENUM_SIZE) == sizeof (__VERIFY_INT32_ENUM_SIZE), "Alignment of enum does not meet UEFI Specification Data Type requirements");

/**
  Macro that returns a pointer to the data structure that contains a specified field of
  that data structure.  This is a lightweight method to hide information by placing a
  public data structure inside a larger private data structure and using a pointer to
  the public data structure to retrieve a pointer to the private data structure.

  This function computes the offset, in bytes, of field specified by Field from the beginning
  of the  data structure specified by TYPE.  This offset is subtracted from Record, and is
  used to return a pointer to a data structure of the type specified by TYPE. If the data type
  specified by TYPE does not contain the field specified by Field, then the module will not compile.

  @param   Record   Pointer to the field specified by Field within a data structure of type TYPE.
  @param   TYPE     The name of the data structure type to return.  This data structure must
                    contain the field specified by Field.
  @param   Field    The name of the field in the data structure specified by TYPE to which Record points.

  @return  A pointer to the structure from one of it's elements.

**/


/**
  Checks whether a value is a power of two.

  @param   Value  The value to check.

  @retval TRUE   Value is a power of two.
  @retval FALSE  Value is not a power of two.
**/


/**
  Checks whether a value is aligned by a specified alignment.

  @param   Value      The value to check.
  @param   Alignment  The alignment boundary used to check against.

  @retval TRUE   Value is aligned by Alignment.
  @retval FALSE  Value is not aligned by Alignment.
**/


/**
  Checks whether a pointer or address is aligned by a specified alignment.

  @param   Address    The pointer or address to check.
  @param   Alignment  The alignment boundary used to check against.

  @retval TRUE   Address is aligned by Alignment.
  @retval FALSE  Address is not aligned by Alignment.
**/


/**
  Determines the addend to add to a value to round it up to the next boundary of
  a specified alignment.

  @param   Value      The value to round up.
  @param   Alignment  The alignment boundary used to return the addend.

  @return  Addend to round Value up to alignment boundary Alignment.
**/


/**
  Rounds a value up to the next boundary using a specified alignment.

  This function rounds Value up to the next boundary using the specified Alignment.
  This aligned value is returned.

  @param   Value      The value to round up.
  @param   Alignment  The alignment boundary used to return the aligned value.

  @return  A value up to the next boundary.

**/


/**
  Adjust a pointer by adding the minimum offset required for it to be aligned on
  a specified alignment boundary.

  This function rounds the pointer specified by Pointer to the next alignment boundary
  specified by Alignment. The pointer to the aligned address is returned.

  @param   Pointer    The pointer to round up.
  @param   Alignment  The alignment boundary to use to return an aligned pointer.

  @return  Pointer to the aligned address.

**/


/**
  Rounds a value up to the next natural boundary for the current CPU.
  This is 4-bytes for 32-bit CPUs and 8-bytes for 64-bit CPUs.

  This function rounds the value specified by Value up to the next natural boundary for the
  current CPU. This rounded value is returned.

  @param   Value      The value to round up.

  @return  Rounded value specified by Value.

**/


/**
  Return the maximum of two operands.

  This macro returns the maximum of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. Can be any numerical type as long as is
                    the same type as a.

  @return  Maximum of two operands.

**/



/**
  Return the minimum of two operands.

  This macro returns the minimal of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. It should be the same any numerical type with a.

  @return  Minimum of two operands.

**/



/**
  Return the absolute value of a signed operand.

  This macro returns the absolute value of the signed operand specified by a.

  @param   a        The signed operand.

  @return  The absolute value of the signed operand.

**/



//
// Status codes common to all execution phases
//
typedef UINTN RETURN_STATUS;

/**
  Produces a RETURN_STATUS code with the highest bit set.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit set.

**/


/**
  Produces a RETURN_STATUS code with the highest bit clear.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit clear.

**/


/**
  Returns TRUE if a specified RETURN_STATUS code is an error code.

  This function returns TRUE if StatusCode has the high bit set.  Otherwise, FALSE is returned.

  @param  StatusCode    The status code value to evaluate.

  @retval TRUE          The high bit of StatusCode is set.
  @retval FALSE         The high bit of StatusCode is clear.

**/


///
/// The operation completed successfully.
///


///
/// The image failed to load.
///


///
/// The parameter was incorrect.
///


///
/// The operation is not supported.
///


///
/// The buffer was not the proper size for the request.
///


///
/// The buffer was not large enough to hold the requested data.
/// The required buffer size is returned in the appropriate
/// parameter when this error occurs.
///


///
/// There is no data pending upon return.
///


///
/// The physical device reported an error while attempting the
/// operation.
///


///
/// The device can not be written to.
///


///
/// The resource has run out.
///


///
/// An inconsistency was detected on the file system causing the
/// operation to fail.
///


///
/// There is no more space on the file system.
///


///
/// The device does not contain any medium to perform the
/// operation.
///


///
/// The medium in the device has changed since the last
/// access.
///


///
/// The item was not found.
///


///
/// Access was denied.
///


///
/// The server was not found or did not respond to the request.
///


///
/// A mapping to the device does not exist.
///


///
/// A timeout time expired.
///


///
/// The protocol has not been started.
///


///
/// The protocol has already been started.
///


///
/// The operation was aborted.
///


///
/// An ICMP error occurred during the network operation.
///


///
/// A TFTP error occurred during the network operation.
///


///
/// A protocol error occurred during the network operation.
///


///
/// A function encountered an internal version that was
/// incompatible with a version requested by the caller.
///


///
/// The function was not performed due to a security violation.
///


///
/// A CRC error was detected.
///


///
/// The beginning or end of media was reached.
///


///
/// The end of the file was reached.
///


///
/// The language specified was invalid.
///


///
/// The security status of the data is unknown or compromised
/// and the data must be updated or replaced to restore a valid
/// security status.
///


///
/// There is an address conflict address allocation.
///


///
/// A HTTP error occurred during the network operation.
///


///
/// The string contained one or more characters that
/// the device could not render and were skipped.
///


///
/// The handle was closed, but the file was not deleted.
///


///
/// The handle was closed, but the data to the file was not
/// flushed properly.
///


///
/// The resulting buffer was too small, and the data was
/// truncated to the buffer size.
///


///
/// The data has not been updated within the timeframe set by
/// local policy for this type of data.
///


///
/// The resulting buffer contains UEFI-compliant file system.
///


///
/// The operation will be processed across a system reset.
///


/**
  Returns a 16-bit signature built from 2 ASCII characters.

  This macro returns a 16-bit value built from the two ASCII characters specified
  by A and B.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.

  @return A 16-bit value built from the two ASCII characters specified by A and B.

**/


/**
  Returns a 32-bit signature built from 4 ASCII characters.

  This macro returns a 32-bit value built from the four ASCII characters specified
  by A, B, C, and D.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.

  @return A 32-bit value built from the two ASCII characters specified by A, B,
          C and D.

**/


/**
  Returns a 64-bit signature built from 8 ASCII characters.

  This macro returns a 64-bit value built from the eight ASCII characters specified
  by A, B, C, D, E, F, G,and H.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.
  @param  E    The fifth ASCII character.
  @param  F    The sixth ASCII character.
  @param  G    The seventh ASCII character.
  @param  H    The eighth ASCII character.

  @return A 64-bit value built from the two ASCII characters specified by A, B,
          C, D, E, F, G and H.

**/




void *
_ReturnAddress (
  void
  );

  #pragma intrinsic(_ReturnAddress)

/**
  Get the return address of the calling function.

  Based on intrinsic function _ReturnAddress that provides the address of
  the instruction in the calling function that will be executed after
  control returns to the caller.

  @param L    Return Level.

  @return The return address of the calling function or 0 if L != 0.

**/


























#line 1381 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"

/**
  Return the number of elements in an array.

  @param  Array  An object of array type. Array is only used as an argument to
                 the sizeof operator, therefore Array is never evaluated. The
                 caller is responsible for ensuring that Array's type is not
                 incomplete; that is, Array must have known constant size.

  @return The number of elements in Array. The result has type UINTN.

**/


#line 1396 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Base.h"
#line 17 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"

//
// Basic data type definitions introduced in UEFI.
//

///
/// 128-bit buffer containing a unique identifier value.
///
typedef GUID EFI_GUID;
///
/// Function return status for EFI API.
///
typedef RETURN_STATUS EFI_STATUS;
///
/// A collection of related interfaces.
///
typedef void *EFI_HANDLE;
///
/// Handle to an event structure.
///
typedef void *EFI_EVENT;
///
/// Task priority level.
///
typedef UINTN EFI_TPL;
///
/// Logical block address.
///
typedef UINT64 EFI_LBA;

///
/// 64-bit physical memory address.
///
typedef UINT64 EFI_PHYSICAL_ADDRESS;

///
/// 64-bit virtual memory address.
///
typedef UINT64 EFI_VIRTUAL_ADDRESS;

///
/// EFI Time Abstraction:
///  Year:       1900 - 9999
///  Month:      1 - 12
///  Day:        1 - 31
///  Hour:       0 - 23
///  Minute:     0 - 59
///  Second:     0 - 59
///  Nanosecond: 0 - 999,999,999
///  TimeZone:   -1440 to 1440 or 2047
///
typedef struct {
  UINT16    Year;
  UINT8     Month;
  UINT8     Day;
  UINT8     Hour;
  UINT8     Minute;
  UINT8     Second;
  UINT8     Pad1;
  UINT32    Nanosecond;
  INT16     TimeZone;
  UINT8     Daylight;
  UINT8     Pad2;
} EFI_TIME;

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
typedef IPv4_ADDRESS EFI_IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
typedef IPv6_ADDRESS EFI_IPv6_ADDRESS;

///
/// 32-byte buffer containing a network Media Access Control address.
///
typedef struct {
  UINT8    Addr[32];
} EFI_MAC_ADDRESS;

///
/// 16-byte buffer aligned on a 4-byte boundary.
/// An IPv4 or IPv6 internet protocol address.
///
typedef union {
  UINT32              Addr[4];
  EFI_IPv4_ADDRESS    v4;
  EFI_IPv6_ADDRESS    v6;
} EFI_IP_ADDRESS;

///
/// Enumeration of EFI_STATUS.
///@{










































///@}

///
/// Define macro to encode the status code.
///




///
/// ICMP error definitions
///@{




///@}

///
/// Tcp connection status definitions
///@{



///@}

//
// The EFI memory allocation functions work in units of EFI_PAGEs that are
// 4KB. This should in no way be confused with the page size of the processor.
// An EFI_PAGE is just the quanta of memory in EFI.
//




/**
  Macro that converts a size, in bytes, to a number of EFI_PAGESs.

  @param  Size      A size in bytes.  This parameter is assumed to be type UINTN.
                    Passing in a parameter that is larger than UINTN may produce
                    unexpected results.

  @return  The number of EFI_PAGESs associated with the number of bytes specified
           by Size.

**/


/**
  Macro that converts a number of EFI_PAGEs to a size in bytes.

  @param  Pages     The number of EFI_PAGES.  This parameter is assumed to be
                    type UINTN.  Passing in a parameter that is larger than
                    UINTN may produce unexpected results.

  @return  The number of bytes associated with the number of EFI_PAGEs specified
           by Pages.

**/


///
/// PE32+ Machine type for IA32 UEFI images.
///


///
/// PE32+ Machine type for IA64 UEFI images.
///


///
/// PE32+ Machine type for EBC UEFI images.
///


///
/// PE32+ Machine type for X64 UEFI images.
///


///
/// PE32+ Machine type for ARM mixed ARM and Thumb/Thumb2 images.
///


///
/// PE32+ Machine type for AARCH64 A64 images.
///


///
/// PE32+ Machine type for RISC-V 32/64/128
///




///
/// PE32+ Machine type for LoongArch 32/64 images.
///




  






#line 267 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"






  





































#line 312 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"











#line 324 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"

#line 326 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiBaseType.h"
#line 14 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\PiDxe.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
/** @file
  Include file that supports UEFI.

  This include file must contain things defined in the UEFI 2.7 specification.
  If a code construct is defined in the UEFI 2.7 specification it must be included
  by this include file.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
Copyright (c) 2022, Loongson Technology Corporation Limited. All rights reserved.<BR>

SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiMultiPhase.h"
/** @file
  This includes some definitions introduced in UEFI that will be used in both PEI and DXE phases.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




///
/// Attributes of variable.
///



///
/// This attribute is identified by the mnemonic 'HR'
/// elsewhere in this specification.
///

///
/// Attributes of Authenticated Variable
///


///
/// NOTE: EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS is deprecated and should be considered reserved.
///



  #line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/WinCertificate.h"
/** @file
  GUID for UEFI WIN_CERTIFICATE structure.

  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  GUID defined in UEFI 2.0 spec.
**/




//
// _WIN_CERTIFICATE.wCertificateType
//




///
/// The WIN_CERTIFICATE structure is part of the PE/COFF specification.
///
typedef struct {
  ///
  /// The length of the entire certificate,
  /// including the length of the header, in bytes.
  ///
  UINT32    dwLength;
  ///
  /// The revision level of the WIN_CERTIFICATE
  /// structure. The current revision level is 0x0200.
  ///
  UINT16    wRevision;
  ///
  /// The certificate type. See WIN_CERT_TYPE_xxx for the UEFI
  /// certificate types. The UEFI specification reserves the range of
  /// certificate type values from 0x0EF0 to 0x0EFF.
  ///
  UINT16    wCertificateType;
  ///
  /// The following is the actual certificate. The format of
  /// the certificate depends on wCertificateType.
  ///
  /// UINT8 bCertificate[ANYSIZE_ARRAY];
  ///
} WIN_CERTIFICATE;

///
/// WIN_CERTIFICATE_UEFI_GUID.CertType
///



///
/// WIN_CERTIFICATE_UEFI_GUID.CertData
///
typedef struct {
  EFI_GUID    HashType;
  UINT8       PublicKey[256];
  UINT8       Signature[256];
} EFI_CERT_BLOCK_RSA_2048_SHA256;

///
/// Certificate which encapsulates a GUID-specific digital signature
///
typedef struct {
  ///
  /// This is the standard WIN_CERTIFICATE header, where
  /// wCertificateType is set to WIN_CERT_TYPE_EFI_GUID.
  ///
  WIN_CERTIFICATE    Hdr;
  ///
  /// This is the unique id which determines the
  /// format of the CertData. .
  ///
  EFI_GUID           CertType;
  ///
  /// The following is the certificate data. The format of
  /// the data is determined by the CertType.
  /// If CertType is EFI_CERT_TYPE_RSA2048_SHA256_GUID,
  /// the CertData will be EFI_CERT_BLOCK_RSA_2048_SHA256 structure.
  ///
  UINT8              CertData[1];
} WIN_CERTIFICATE_UEFI_GUID;

///
/// Certificate which encapsulates the RSASSA_PKCS1-v1_5 digital signature.
///
/// The WIN_CERTIFICATE_UEFI_PKCS1_15 structure is derived from
/// WIN_CERTIFICATE and encapsulate the information needed to
/// implement the RSASSA-PKCS1-v1_5 digital signature algorithm as
/// specified in RFC2437.
///
typedef struct {
  ///
  /// This is the standard WIN_CERTIFICATE header, where
  /// wCertificateType is set to WIN_CERT_TYPE_UEFI_PKCS1_15.
  ///
  WIN_CERTIFICATE    Hdr;
  ///
  /// This is the hashing algorithm which was performed on the
  /// UEFI executable when creating the digital signature.
  ///
  EFI_GUID           HashAlgorithm;
  ///
  /// The following is the actual digital signature. The
  /// size of the signature is the same size as the key
  /// (1024-bit key is 128 bytes) and can be determined by
  /// subtracting the length of the other parts of this header
  /// from the total length of the certificate as found in
  /// Hdr.dwLength.
  ///
  /// UINT8 Signature[];
  ///
} WIN_CERTIFICATE_EFI_PKCS1_15;

extern EFI_GUID  gEfiCertTypeRsa2048Sha256Guid;

#line 121 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/WinCertificate.h"
#line 35 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiMultiPhase.h"
///
/// Enumeration of memory types introduced in UEFI.
///
typedef enum {
  ///
  /// Not used.
  ///
  EfiReservedMemoryType,
  ///
  /// The code portions of a loaded application.
  /// (Note that UEFI OS loaders are UEFI applications.)
  ///
  EfiLoaderCode,
  ///
  /// The data portions of a loaded application and the default data allocation
  /// type used by an application to allocate pool memory.
  ///
  EfiLoaderData,
  ///
  /// The code portions of a loaded Boot Services Driver.
  ///
  EfiBootServicesCode,
  ///
  /// The data portions of a loaded Boot Serves Driver, and the default data
  /// allocation type used by a Boot Services Driver to allocate pool memory.
  ///
  EfiBootServicesData,
  ///
  /// The code portions of a loaded Runtime Services Driver.
  ///
  EfiRuntimeServicesCode,
  ///
  /// The data portions of a loaded Runtime Services Driver and the default
  /// data allocation type used by a Runtime Services Driver to allocate pool memory.
  ///
  EfiRuntimeServicesData,
  ///
  /// Free (unallocated) memory.
  ///
  EfiConventionalMemory,
  ///
  /// Memory in which errors have been detected.
  ///
  EfiUnusableMemory,
  ///
  /// Memory that holds the ACPI tables.
  ///
  EfiACPIReclaimMemory,
  ///
  /// Address space reserved for use by the firmware.
  ///
  EfiACPIMemoryNVS,
  ///
  /// Used by system firmware to request that a memory-mapped IO region
  /// be mapped by the OS to a virtual address so it can be accessed by EFI runtime services.
  ///
  EfiMemoryMappedIO,
  ///
  /// System memory-mapped IO region that is used to translate memory
  /// cycles to IO cycles by the processor.
  ///
  EfiMemoryMappedIOPortSpace,
  ///
  /// Address space reserved by the firmware for code that is part of the processor.
  ///
  EfiPalCode,
  ///
  /// A memory region that operates as EfiConventionalMemory,
  /// however it happens to also support byte-addressable non-volatility.
  ///
  EfiPersistentMemory,
  ///
  /// A memory region that describes system memory that has not been accepted
  /// by a corresponding call to the underlying isolation architecture.
  ///
  EfiUnacceptedMemoryType,
  EfiMaxMemoryType,
  //
  // +---------------------------------------------------+
  // | 0..(EfiMaxMemoryType - 1)    - Normal memory type |
  // +---------------------------------------------------+
  // | EfiMaxMemoryType..0x6FFFFFFF - Invalid            |
  // +---------------------------------------------------+
  // | 0x70000000..0x7FFFFFFF       - OEM reserved       |
  // +---------------------------------------------------+
  // | 0x80000000..0xFFFFFFFF       - OS reserved        |
  // +---------------------------------------------------+
  //
  MEMORY_TYPE_OEM_RESERVED_MIN = 0x70000000,
  MEMORY_TYPE_OEM_RESERVED_MAX = 0x7FFFFFFF,
  MEMORY_TYPE_OS_RESERVED_MIN  = 0x80000000,
  MEMORY_TYPE_OS_RESERVED_MAX  = 0xFFFFFFFF
} EFI_MEMORY_TYPE;

///
/// Enumeration of reset types.
///
typedef enum {
  ///
  /// Used to induce a system-wide reset. This sets all circuitry within the
  /// system to its initial state.  This type of reset is asynchronous to system
  /// operation and operates withgout regard to cycle boundaries.  EfiColdReset
  /// is tantamount to a system power cycle.
  ///
  EfiResetCold,
  ///
  /// Used to induce a system-wide initialization. The processors are set to their
  /// initial state, and pending cycles are not corrupted.  If the system does
  /// not support this reset type, then an EfiResetCold must be performed.
  ///
  EfiResetWarm,
  ///
  /// Used to induce an entry into a power state equivalent to the ACPI G2/S5 or G3
  /// state.  If the system does not support this reset type, then when the system
  /// is rebooted, it should exhibit the EfiResetCold attributes.
  ///
  EfiResetShutdown,
  ///
  /// Used to induce a system-wide reset. The exact type of the reset is defined by
  /// the EFI_GUID that follows the Null-terminated Unicode string passed into
  /// ResetData. If the platform does not recognize the EFI_GUID in ResetData the
  /// platform must pick a supported reset type to perform. The platform may
  /// optionally log the parameters from any non-normal reset that occurs.
  ///
  EfiResetPlatformSpecific
} EFI_RESET_TYPE;

///
/// Data structure that precedes all of the standard EFI table types.
///
typedef struct {
  ///
  /// A 64-bit signature that identifies the type of table that follows.
  /// Unique signatures have been generated for the EFI System Table,
  /// the EFI Boot Services Table, and the EFI Runtime Services Table.
  ///
  UINT64    Signature;
  ///
  /// The revision of the EFI Specification to which this table
  /// conforms. The upper 16 bits of this field contain the major
  /// revision value, and the lower 16 bits contain the minor revision
  /// value. The minor revision values are limited to the range of 00..99.
  ///
  UINT32    Revision;
  ///
  /// The size, in bytes, of the entire table including the EFI_TABLE_HEADER.
  ///
  UINT32    HeaderSize;
  ///
  /// The 32-bit CRC for the entire table. This value is computed by
  /// setting this field to 0, and computing the 32-bit CRC for HeaderSize bytes.
  ///
  UINT32    CRC32;
  ///
  /// Reserved field that must be set to 0.
  ///
  UINT32    Reserved;
} EFI_TABLE_HEADER;

///
/// AuthInfo is a WIN_CERTIFICATE using the wCertificateType
/// WIN_CERTIFICATE_UEFI_GUID and the CertType
/// EFI_CERT_TYPE_RSA2048_SHA256_GUID. If the attribute specifies
/// authenticated access, then the Data buffer should begin with an
/// authentication descriptor prior to the data payload and DataSize
/// should reflect the the data.and descriptor size. The caller
/// shall digest the Monotonic Count value and the associated data
/// for the variable update using the SHA-256 1-way hash algorithm.
/// The ensuing the 32-byte digest will be signed using the private
/// key associated w/ the public/private 2048-bit RSA key-pair. The
/// WIN_CERTIFICATE shall be used to describe the signature of the
/// Variable data *Data. In addition, the signature will also
/// include the MonotonicCount value to guard against replay attacks.
///
typedef struct {
  ///
  /// Included in the signature of
  /// AuthInfo.Used to ensure freshness/no
  /// replay. Incremented during each
  /// "Write" access.
  ///
  UINT64    MonotonicCount;
  ///
  /// Provides the authorization for the variable
  /// access. It is a signature across the
  /// variable data and the  Monotonic Count
  /// value. Caller uses Private key that is
  /// associated with a public key that has been
  /// provisioned via the key exchange.
  ///
  WIN_CERTIFICATE_UEFI_GUID    AuthInfo;
} EFI_VARIABLE_AUTHENTICATION;

///
/// When the attribute EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS is
/// set, then the Data buffer shall begin with an instance of a complete (and serialized)
/// EFI_VARIABLE_AUTHENTICATION_2 descriptor. The descriptor shall be followed by the new
/// variable value and DataSize shall reflect the combined size of the descriptor and the new
/// variable value. The authentication descriptor is not part of the variable data and is not
/// returned by subsequent calls to GetVariable().
///
typedef struct {
  ///
  /// For the TimeStamp value, components Pad1, Nanosecond, TimeZone, Daylight and
  /// Pad2 shall be set to 0. This means that the time shall always be expressed in GMT.
  ///
  EFI_TIME                     TimeStamp;
  ///
  /// Only a CertType of  EFI_CERT_TYPE_PKCS7_GUID is accepted.
  ///
  WIN_CERTIFICATE_UEFI_GUID    AuthInfo;
} EFI_VARIABLE_AUTHENTICATION_2;
#line 248 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiMultiPhase.h"

#line 250 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiMultiPhase.h"
#line 20 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"

#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DevicePath.h"
/** @file
  The device path protocol as defined in UEFI 2.0.

  The device path represents a programmatic path to a device,
  from a software point of view. The path must persist from boot to boot, so
  it can not contain things like PCI bus numbers that change from boot to boot.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/PcAnsi.h"
/** @file
  Terminal Device Path Vendor Guid.

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  GUIDs defined in UEFI 2.0 spec.

**/


































extern EFI_GUID  gEfiPcAnsiGuid;
extern EFI_GUID  gEfiVT100Guid;
extern EFI_GUID  gEfiVT100PlusGuid;
extern EFI_GUID  gEfiVTUTF8Guid;
extern EFI_GUID  gEfiUartDevicePathGuid;
extern EFI_GUID  gEfiSasDevicePathGuid;

#line 53 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/PcAnsi.h"
#line 17 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DevicePath.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Bluetooth.h"
/** @file
  This file contains the Bluetooth definitions that are consumed by drivers.
  These definitions are from Bluetooth Core Specification Version 4.0 June, 2010

  Copyright (c) 2015 - 2017, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#pragma pack(1)

///
/// BLUETOOTH_ADDRESS
///
typedef struct {
  ///
  /// 48bit Bluetooth device address.
  ///
  UINT8    Address[6];
} BLUETOOTH_ADDRESS;

///
/// BLUETOOTH_CLASS_OF_DEVICE. See Bluetooth specification for detail.
///
typedef struct {
  UINT8     FormatType        : 2;
  UINT8     MinorDeviceClass  : 6;
  UINT16    MajorDeviceClass  : 5;
  UINT16    MajorServiceClass : 11;
} BLUETOOTH_CLASS_OF_DEVICE;

///
/// BLUETOOTH_LE_ADDRESS
///
typedef struct {
  ///
  /// 48-bit Bluetooth device address
  ///
  UINT8    Address[6];
  ///
  /// 0x00 - Public Device Address
  /// 0x01 - Random Device Address
  ///
  UINT8    Type;
} BLUETOOTH_LE_ADDRESS;

#pragma pack()





#line 57 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Bluetooth.h"
#line 18 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DevicePath.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi60.h"
/** @file
  ACPI 6.0 definitions from the ACPI Specification Revision 6.0 Errata A January, 2016.

  Copyright (c) 2015 - 2022, Intel Corporation. All rights reserved.<BR>
  (C) Copyright 2015-2016 Hewlett Packard Enterprise Development LP<BR>
  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi51.h"
/** @file
  ACPI 5.1 definitions from the ACPI Specification Revision 5.1 Errata B January, 2016.

  Copyright (c) 2014 Hewlett-Packard Development Company, L.P.<BR>
  Copyright (c) 2014 - 2022, Intel Corporation. All rights reserved.<BR>
  (C) Copyright 2015 Hewlett Packard Enterprise Development LP<BR>
  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi50.h"
/** @file
  ACPI 5.0 definitions from the ACPI Specification Revision 5.0a November 13, 2013.

  Copyright (c) 2014 Hewlett-Packard Development Company, L.P.<BR>
  Copyright (c) 2011 - 2022, Intel Corporation. All rights reserved.<BR>
  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi40.h"
/** @file
  ACPI 4.0 definitions from the ACPI Specification Revision 4.0a April 5, 2010

  Copyright (c) 2010 - 2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi30.h"
/** @file
  ACPI 3.0 definitions from the ACPI Specification Revision 3.0b October 10, 2006

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi20.h"
/** @file
  ACPI 2.0 definitions from the ACPI Specification, revision 2.0

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi10.h"
/** @file
  ACPI 1.0b definitions from the ACPI Specification, revision 1.0b

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
Copyright (c) 2020, Arm Limited. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent
**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/AcpiAml.h"
/** @file
  This file contains AML code definition in the latest ACPI spec.

  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
  Copyright (c) 2019 - 2021, Arm Limited. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




//
// ACPI AML definition
//

//
// Primary OpCode
//




















































































































//
// Extended OpCode
//
































//
// FieldElement OpCode
//





//
// AML Name segment definitions
//


#line 185 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/AcpiAml.h"
#line 13 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi10.h"

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure.
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_COMMON_HEADER;

#pragma pack(1)
///
/// The common ACPI description table header.  This structure prefaces most ACPI tables.
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT8     Revision;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT64    OemTableId;
  UINT32    OemRevision;
  UINT32    CreatorId;
  UINT32    CreatorRevision;
} EFI_ACPI_DESCRIPTION_HEADER;
#pragma pack()

//
// Define for Descriptor
//



//
// Small Item Descriptor Name
//









//
// Large Item Descriptor Name
//









//
// Small Item Descriptor Value
//










//
// Large Item Descriptor Value
//









//
// Resource Type
//




///
/// Power Management Timer frequency is fixed at 3.579545MHz.
///


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// The common definition of QWORD, DWORD, and WORD
/// Address Space Descriptors.
///
typedef  struct {
  UINT8     Desc;
  UINT16    Len;
  UINT8     ResType;
  UINT8     GenFlag;
  UINT8     SpecificFlag;
  UINT64    AddrSpaceGranularity;
  UINT64    AddrRangeMin;
  UINT64    AddrRangeMax;
  UINT64    AddrTranslationOffset;
  UINT64    AddrLen;
} EFI_ACPI_ADDRESS_SPACE_DESCRIPTOR;

typedef  union {
  UINT8    Byte;
   struct {
    UINT8    Length : 3;
    UINT8    Name   : 4;
    UINT8    Type   : 1;
  } Bits;
} ACPI_SMALL_RESOURCE_HEADER;

typedef  struct {
   union {
    UINT8    Byte;
     struct {
      UINT8    Name : 7;
      UINT8    Type : 1;
    } Bits;
  } Header;
  UINT16    Length;
} ACPI_LARGE_RESOURCE_HEADER;

///
/// IRQ Descriptor.
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT16                        Mask;
} EFI_ACPI_IRQ_NOFLAG_DESCRIPTOR;

///
/// IRQ Descriptor.
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT16                        Mask;
  UINT8                         Information;
} EFI_ACPI_IRQ_DESCRIPTOR;

///
/// DMA Descriptor.
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT8                         ChannelMask;
  UINT8                         Information;
} EFI_ACPI_DMA_DESCRIPTOR;

///
/// I/O Port Descriptor
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT8                         Information;
  UINT16                        BaseAddressMin;
  UINT16                        BaseAddressMax;
  UINT8                         Alignment;
  UINT8                         Length;
} EFI_ACPI_IO_PORT_DESCRIPTOR;

///
/// Fixed Location I/O Port Descriptor.
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT16                        BaseAddress;
  UINT8                         Length;
} EFI_ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR;

///
/// 24-Bit Memory Range Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         Information;
  UINT16                        BaseAddressMin;
  UINT16                        BaseAddressMax;
  UINT16                        Alignment;
  UINT16                        Length;
} EFI_ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR;

///
/// 32-Bit Memory Range Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         Information;
  UINT32                        BaseAddressMin;
  UINT32                        BaseAddressMax;
  UINT32                        Alignment;
  UINT32                        Length;
} EFI_ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR;

///
/// Fixed 32-Bit Fixed Memory Range Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         Information;
  UINT32                        BaseAddress;
  UINT32                        Length;
} EFI_ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR;

///
/// QWORD Address Space Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         ResType;
  UINT8                         GenFlag;
  UINT8                         SpecificFlag;
  UINT64                        AddrSpaceGranularity;
  UINT64                        AddrRangeMin;
  UINT64                        AddrRangeMax;
  UINT64                        AddrTranslationOffset;
  UINT64                        AddrLen;
} EFI_ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// DWORD Address Space Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         ResType;
  UINT8                         GenFlag;
  UINT8                         SpecificFlag;
  UINT32                        AddrSpaceGranularity;
  UINT32                        AddrRangeMin;
  UINT32                        AddrRangeMax;
  UINT32                        AddrTranslationOffset;
  UINT32                        AddrLen;
} EFI_ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// WORD Address Space Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         ResType;
  UINT8                         GenFlag;
  UINT8                         SpecificFlag;
  UINT16                        AddrSpaceGranularity;
  UINT16                        AddrRangeMin;
  UINT16                        AddrRangeMax;
  UINT16                        AddrTranslationOffset;
  UINT16                        AddrLen;
} EFI_ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// Extended Interrupt Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         InterruptVectorFlags;
  UINT8                         InterruptTableLength;
  UINT32                        InterruptNumber[1];
} EFI_ACPI_EXTENDED_INTERRUPT_DESCRIPTOR;

#pragma pack()

///
/// The End tag identifies an end of resource data.
///
typedef struct {
  UINT8    Desc;
  UINT8    Checksum;
} EFI_ACPI_END_TAG_DESCRIPTOR;

//
// General use definitions
//





//
// Resource Type Specific Flags
// Ref ACPI specification 6.4.3.5.5
//
// Bit [0]    : Write Status, _RW
//


//
// Bit [2:1]  : Memory Attributes, _MEM
//




//
// Bit [4:3]  : Memory Attributes, _MTP
//




//
// Bit [5]    : Memory to I/O Translation, _TTP
//



//
// IRQ Information
// Ref ACPI specification 6.4.2.1
//











//
// DMA Information
// Ref ACPI specification 6.4.2.2
//














//
// IO Information
// Ref ACPI specification 6.4.2.5
//




//
// Memory Information
// Ref ACPI specification 6.4.3.4
//




//
// Interrupt Vector Flags definitions for Extended Interrupt Descriptor
// Ref ACPI specification 6.4.3.6
//






//
// Ensure proper structure formats
//
#pragma pack(1)
//
// ACPI 1.0b table structures
//

///
/// Root System Description Pointer Structure.
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Reserved;
  UINT32    RsdtAddress;
} EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 1.0b specification).
///


///
/// Fixed ACPI Description Table Structure (FADT).
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         FirmwareCtrl;
  UINT32                         Dsdt;
  UINT8                          IntModel;
  UINT8                          Reserved1;
  UINT16                         SciInt;
  UINT32                         SmiCmd;
  UINT8                          AcpiEnable;
  UINT8                          AcpiDisable;
  UINT8                          S4BiosReq;
  UINT8                          Reserved2;
  UINT32                         Pm1aEvtBlk;
  UINT32                         Pm1bEvtBlk;
  UINT32                         Pm1aCntBlk;
  UINT32                         Pm1bCntBlk;
  UINT32                         Pm2CntBlk;
  UINT32                         PmTmrBlk;
  UINT32                         Gpe0Blk;
  UINT32                         Gpe1Blk;
  UINT8                          Pm1EvtLen;
  UINT8                          Pm1CntLen;
  UINT8                          Pm2CntLen;
  UINT8                          PmTmLen;
  UINT8                          Gpe0BlkLen;
  UINT8                          Gpe1BlkLen;
  UINT8                          Gpe1Base;
  UINT8                          Reserved3;
  UINT16                         PLvl2Lat;
  UINT16                         PLvl3Lat;
  UINT16                         FlushSize;
  UINT16                         FlushStride;
  UINT8                          DutyOffset;
  UINT8                          DutyWidth;
  UINT8                          DayAlrm;
  UINT8                          MonAlrm;
  UINT8                          Century;
  UINT8                          Reserved4;
  UINT8                          Reserved5;
  UINT8                          Reserved6;
  UINT32                         Flags;
} EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 1.0b specification).
///





//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//











///
/// Firmware ACPI Control Structure.
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT8     Reserved[40];
} EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// Firmware Control Structure Feature Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform-specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 1.0b specification).
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x05 an 0xFF are reserved and
// will be ignored by OSPM.
//






//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition.
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    SystemVectorBase;
} EFI_ACPI_1_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterruptVector;
  UINT16    Flags;
} EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Non-Maskable Interrupt Source Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterruptVector;
} EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicInti;
} EFI_ACPI_1_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_1_0_SMART_BATTERY_DESCRIPTION_TABLE;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer.
///


///
/// "APIC" Multiple APIC Description Table.
///


///
/// "DSDT" Differentiated System Description Table.
///


///
/// "FACS" Firmware ACPI Control Structure.
///


///
/// "FACP" Fixed ACPI Description Table.
///


///
/// "PSDT" Persistent System Description Table.
///


///
/// "RSDT" Root System Description Table.
///


///
/// "SBST" Smart Battery Specification Table.
///


///
/// "SSDT" Secondary System Description Table.
///


#pragma pack()

#line 667 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi10.h"
#line 12 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi20.h"

//
// Define for Descriptor
//




//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// Generic Register Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         AddressSpaceId;
  UINT8                         RegisterBitWidth;
  UINT8                         RegisterBitOffset;
  UINT8                         AddressSize;
  UINT64                        RegisterAddress;
} EFI_ACPI_GENERIC_REGISTER_DESCRIPTOR;

#pragma pack()

//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 2.0 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     Reserved;
  UINT64    Address;
} EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//







//
// ACPI 2.0 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 2.0 spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_2_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 2.0 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 2.0 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT8                                     Reserved2[3];
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
} EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 2.0 spec.)
///


//
// Fixed ACPI Description Table Preferred Power Management Profile
//








//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//



//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//















///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved[31];
} EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 2.0 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///


///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 2.0 spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x09 an 0xFF are reserved and
// will be ignored by OSPM.
//










//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_2_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_2_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_2_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_2_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_2_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_2_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_2_0_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
} EFI_ACPI_2_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    Reserved;
} EFI_ACPI_2_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_2_0_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 2.0 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 2.0 spec.)
///


//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "SPIC" Multiple SAPIC Description Table
///
/// BUGBUG: Don't know where this came from except SR870BN4 uses it.
/// #define EFI_ACPI_2_0_MULTIPLE_SAPIC_DESCRIPTION_TABLE_SIGNATURE 0x43495053
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "DBGP" MS Bebug Port Spec
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SRAT" Static Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


#pragma pack()

#line 540 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi20.h"
#line 12 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi30.h"

//
// Define for Descriptor
//




///
/// C-state Coordination Types
/// See s8.4.2.2 _CSD (C-State Dependency)
///




///
/// _PSD Revision for ACPI 3.0
// See s8.4.4.5 _PSD (P-State Dependency)
///


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// Extended Address Space Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         ResType;
  UINT8                         GenFlag;
  UINT8                         SpecificFlag;
  UINT8                         RevisionId;
  UINT8                         Reserved;
  UINT64                        AddrSpaceGranularity;
  UINT64                        AddrRangeMin;
  UINT64                        AddrRangeMax;
  UINT64                        AddrTranslationOffset;
  UINT64                        AddrLen;
  UINT64                        TypeSpecificAttribute;
} EFI_ACPI_EXTENDED_ADDRESS_SPACE_DESCRIPTOR;

#pragma pack()

//
// Memory Type Specific Flags
//







//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 3.0 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     AccessSize;
  UINT64    Address;
} EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//







//
// Generic Address Space Access Sizes
//






//
// ACPI 3.0 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 3.0b spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_3_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 3.0 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 3.0 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT8                                     Reserved2[3];
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
} EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 3.0 spec.)
///


//
// Fixed ACPI Description Table Preferred Power Management Profile
//









//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//






//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//





















///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved[31];
} EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 3.0 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///


//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//



///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 3.0 spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x09 an 0xFF are reserved and
// will be ignored by OSPM.
//










//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_3_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_3_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
  UINT8     CpeiProcessorOverride;
  UINT8     Reserved[31];
} EFI_ACPI_3_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//



///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_3_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_3_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_3_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_3_0_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
  UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_3_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_3_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_3_0_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 3.0 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 3.0 spec.)
///


///
/// System Resource Affinity Table (SRAT.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved1; ///< Must be set to 1
  UINT64                         Reserved2;
} EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 3.0 spec.)
///


//
// SRAT structure types.
// All other values between 0x02 an 0xFF are reserved and
// will be ignored by OSPM.
//



///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProximityDomain7To0;
  UINT8     ApicId;
  UINT32    Flags;
  UINT8     LocalSapicEid;
  UINT8     ProximityDomain31To8[3];
  UINT8     Reserved[4];
} EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///


///
/// Memory Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT16    Reserved1;
  UINT32    AddressBaseLow;
  UINT32    AddressBaseHigh;
  UINT32    LengthLow;
  UINT32    LengthHigh;
  UINT32    Reserved2;
  UINT32    Flags;
  UINT64    Reserved3;
} EFI_ACPI_3_0_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//




///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_3_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 3.0 spec.)
///


//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SRAT" System Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "CPEP" Corrected Platform Error Polling Table
///


///
/// "DBGP" MS Debug Port Spec
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "HPET" IA-PC High Precision Event Timer Table
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///


///
/// "WDRT" Watchdog Resource Table
///


///
/// "WDAT" Watchdog Action Table
///


///
/// "WSPT" Windows Specific Properties Table
///


///
/// "iBFT" iSCSI Boot Firmware Table
///


#pragma pack()

#line 738 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi30.h"
#line 12 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi40.h"

///
/// _PSD Revision for ACPI 4.0
///


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 4.0 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     AccessSize;
  UINT64    Address;
} EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//







//
// Generic Address Space Access Sizes
//






//
// ACPI 4.0 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 4.0b spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_4_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 4.0 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 4.0 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT8                                     Reserved2[3];
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
} EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 4.0 spec.)
///


//
// Fixed ACPI Description Table Preferred Power Management Profile
//









//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//






//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//





















///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved0[3];
  UINT32    OspmFlags;
  UINT8     Reserved1[24];
} EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 4.0 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///



///
/// OSPM Enabled Firmware Control Structure Flags
/// All other bits are reserved and must be set to 0.
///


//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//



///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 4.0 spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x0B an 0xFF are reserved and
// will be ignored by OSPM.
//












//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_4_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_4_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
  UINT8     CpeiProcessorOverride;
  UINT8     Reserved[31];
} EFI_ACPI_4_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//



///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_4_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_4_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_4_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_4_0_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
  UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_4_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_4_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Processor Local x2APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved[2];
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    AcpiProcessorUid;
} EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;

///
/// Local x2APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    AcpiProcessorUid;
  UINT8     LocalX2ApicLint;
  UINT8     Reserved[3];
} EFI_ACPI_4_0_LOCAL_X2APIC_NMI_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_4_0_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 4.0 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 4.0 spec.)
///


///
/// System Resource Affinity Table (SRAT.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved1; ///< Must be set to 1
  UINT64                         Reserved2;
} EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 4.0 spec.)
///


//
// SRAT structure types.
// All other values between 0x03 an 0xFF are reserved and
// will be ignored by OSPM.
//




///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProximityDomain7To0;
  UINT8     ApicId;
  UINT32    Flags;
  UINT8     LocalSapicEid;
  UINT8     ProximityDomain31To8[3];
  UINT32    ClockDomain;
} EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///


///
/// Memory Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT16    Reserved1;
  UINT32    AddressBaseLow;
  UINT32    AddressBaseHigh;
  UINT32    LengthLow;
  UINT32    LengthHigh;
  UINT32    Reserved2;
  UINT32    Flags;
  UINT64    Reserved3;
} EFI_ACPI_4_0_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//




///
/// Processor Local x2APIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved1[2];
  UINT32    ProximityDomain;
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    ClockDomain;
  UINT8     Reserved2[4];
} EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_4_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 4.0 spec.)
///


///
/// Corrected Platform Error Polling Table (CPEP)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          Reserved[8];
} EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;

///
/// CPEP Version (as defined in ACPI 4.0 spec.)
///


//
// CPEP processor structure types.
//


///
/// Corrected Platform Error Polling Processor Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT32    PollingInterval;
} EFI_ACPI_4_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;

///
/// Maximum System Characteristics Table (MSCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         OffsetProxDomInfo;
  UINT32                         MaximumNumberOfProximityDomains;
  UINT32                         MaximumNumberOfClockDomains;
  UINT64                         MaximumPhysicalAddress;
} EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;

///
/// MSCT Version (as defined in ACPI 4.0 spec.)
///


///
/// Maximum Proximity Domain Information Structure Definition
///
typedef struct {
  UINT8     Revision;
  UINT8     Length;
  UINT32    ProximityDomainRangeLow;
  UINT32    ProximityDomainRangeHigh;
  UINT32    MaximumProcessorCapacity;
  UINT64    MaximumMemoryCapacity;
} EFI_ACPI_4_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;

///
/// Boot Error Record Table (BERT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         BootErrorRegionLength;
  UINT64                         BootErrorRegion;
} EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_HEADER;

///
/// BERT Version (as defined in ACPI 4.0 spec.)
///


///
/// Boot Error Region Block Status Definition
///
typedef struct {
  UINT32    UncorrectableErrorValid     : 1;
  UINT32    CorrectableErrorValid       : 1;
  UINT32    MultipleUncorrectableErrors : 1;
  UINT32    MultipleCorrectableErrors   : 1;
  UINT32    ErrorDataEntryCount         : 10;
  UINT32    Reserved                    : 18;
} EFI_ACPI_4_0_ERROR_BLOCK_STATUS;

///
/// Boot Error Region Definition
///
typedef struct {
  EFI_ACPI_4_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_4_0_BOOT_ERROR_REGION_STRUCTURE;

//
// Boot Error Severity types
//






///
/// Generic Error Data Entry Definition
///
typedef struct {
  UINT8     SectionType[16];
  UINT32    ErrorSeverity;
  UINT16    Revision;
  UINT8     ValidationBits;
  UINT8     Flags;
  UINT32    ErrorDataLength;
  UINT8     FruId[16];
  UINT8     FruText[20];
} EFI_ACPI_4_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;

///
/// Generic Error Data Entry Version (as defined in ACPI 4.0 spec.)
///


///
/// HEST - Hardware Error Source Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         ErrorSourceCount;
} EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;

///
/// HEST Version (as defined in ACPI 4.0 spec.)
///


//
// Error Source structure types.
//








//
// Error Source structure flags.
//



///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT64    GlobalCapabilityInitData;
  UINT64    GlobalControlInitData;
  UINT8     NumberOfHardwareBanks;
  UINT8     Reserved1[7];
} EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
typedef struct {
  UINT8     BankNumber;
  UINT8     ClearStatusOnInitialization;
  UINT8     StatusDataFormat;
  UINT8     Reserved0;
  UINT32    ControlRegisterMsrAddress;
  UINT64    ControlInitData;
  UINT32    StatusRegisterMsrAddress;
  UINT32    AddressRegisterMsrAddress;
  UINT32    MiscRegisterMsrAddress;
} EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure MCA data format
///




//
// Hardware Error Notification types. All other values are reserved
//






///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
typedef struct {
  UINT16    Type                           : 1;
  UINT16    PollInterval                   : 1;
  UINT16    SwitchToPollingThresholdValue  : 1;
  UINT16    SwitchToPollingThresholdWindow : 1;
  UINT16    ErrorThresholdValue            : 1;
  UINT16    ErrorThresholdWindow           : 1;
  UINT16    Reserved                       : 10;
} EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;

///
/// Hardware Error Notification Structure Definition
///
typedef struct {
  UINT8                                                                            Type;
  UINT8                                                                            Length;
  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE    ConfigurationWriteEnable;
  UINT32                                                                           PollInterval;
  UINT32                                                                           Vector;
  UINT32                                                                           SwitchToPollingThresholdValue;
  UINT32                                                                           SwitchToPollingThresholdWindow;
  UINT32                                                                           ErrorThresholdValue;
  UINT32                                                                           ErrorThresholdWindow;
} EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT8                                                 Reserved0[2];
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT8                                                 NumberOfHardwareBanks;
  UINT8                                                 Reserved1[3];
} EFI_ACPI_4_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;

///
/// IA-32 Architecture NMI Error Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    MaxRawDataLength;
} EFI_ACPI_4_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;

///
/// PCI Express Root Port AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    RootErrorCommand;
} EFI_ACPI_4_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;

///
/// PCI Express Device AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_4_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;

///
/// PCI Express Bridge AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    SecondaryUncorrectableErrorMask;
  UINT32    SecondaryUncorrectableErrorSeverity;
  UINT32    SecondaryAdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_4_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;

///
/// Generic Hardware Error Source Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT16                                                RelatedSourceId;
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  UINT32                                                MaxRawDataLength;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT32                                                ErrorStatusBlockLength;
} EFI_ACPI_4_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;

///
/// Generic Error Status Definition
///
typedef struct {
  EFI_ACPI_4_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_4_0_GENERIC_ERROR_STATUS_STRUCTURE;

///
/// ERST - Error Record Serialization Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         SerializationHeaderSize;
  UINT8                          Reserved0[4];
  UINT32                         InstructionEntryCount;
} EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;

///
/// ERST Version (as defined in ACPI 4.0 spec.)
///


///
/// ERST Serialization Actions
///
















///
/// ERST Action Command Status
///







///
/// ERST Serialization Instructions
///




















///
/// ERST Instruction Flags
///


///
/// ERST Serialization Instruction Entry
///
typedef struct {
  UINT8                                     SerializationAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_4_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;

///
/// EINJ - Error Injection Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         InjectionHeaderSize;
  UINT8                          InjectionFlags;
  UINT8                          Reserved0[3];
  UINT32                         InjectionEntryCount;
} EFI_ACPI_4_0_ERROR_INJECTION_TABLE_HEADER;

///
/// EINJ Version (as defined in ACPI 4.0 spec.)
///


///
/// EINJ Error Injection Actions
///










///
/// EINJ Action Command Status
///




///
/// EINJ Error Type Definition
///













///
/// EINJ Injection Instructions
///






///
/// EINJ Instruction Flags
///


///
/// EINJ Injection Instruction Entry
///
typedef struct {
  UINT8                                     InjectionAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_4_0_EINJ_INJECTION_INSTRUCTION_ENTRY;

///
/// EINJ Trigger Action Table
///
typedef struct {
  UINT32    HeaderSize;
  UINT32    Revision;
  UINT32    TableSize;
  UINT32    EntryCount;
} EFI_ACPI_4_0_EINJ_TRIGGER_ACTION_TABLE;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "BERT" Boot Error Record Table
///


///
/// "CPEP" Corrected Platform Error Polling Table
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "EINJ" Error Injection Table
///


///
/// "ERST" Error Record Serialization Table
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "HEST" Hardware Error Source Table
///


///
/// "MSCT" Maximum System Characteristics Table
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SRAT" System Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "DBGP" MS Debug Port Spec
///


///
/// "DMAR" DMA Remapping Table
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "HPET" IA-PC High Precision Event Timer Table
///


///
/// "iBFT" iSCSI Boot Firmware Table
///


///
/// "IVRS" I/O Virtualization Reporting Structure
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


///
/// "MCHI" Management Controller Host Interface Table
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///


///
/// "UEFI" UEFI ACPI Data Table
///


///
/// "WAET" Windows ACPI Enlightenment Table
///


///
/// "WDAT" Watchdog Action Table
///


///
/// "WDRT" Watchdog Resource Table
///


#pragma pack()

#line 1310 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi40.h"
#line 14 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi50.h"

//
// Define for Descriptor
//








///
/// _PSD Revision for ACPI 5.0
///


///
/// _CPC Revision for ACPI 5.0
///


#pragma pack(1)

///
/// Generic DMA Descriptor.
///
typedef  struct {
  ACPI_SMALL_RESOURCE_HEADER    Header;
  UINT16                        DmaRequestLine;
  UINT16                        DmaChannel;
  UINT8                         DmaTransferWidth;
} EFI_ACPI_FIXED_DMA_DESCRIPTOR;

///
/// GPIO Connection Descriptor
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         RevisionId;
  UINT8                         ConnectionType;
  UINT16                        GeneralFlags;
  UINT16                        InterruptFlags;
  UINT8                         PinConfiguration;
  UINT16                        OutputDriveStrength;
  UINT16                        DebounceTimeout;
  UINT16                        PinTableOffset;
  UINT8                         ResourceSourceIndex;
  UINT16                        ResourceSourceNameOffset;
  UINT16                        VendorDataOffset;
  UINT16                        VendorDataLength;
} EFI_ACPI_GPIO_CONNECTION_DESCRIPTOR;




///
/// Serial Bus Resource Descriptor (Generic)
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         RevisionId;
  UINT8                         ResourceSourceIndex;
  UINT8                         SerialBusType;
  UINT8                         GeneralFlags;
  UINT16                        TypeSpecificFlags;
  UINT8                         TypeSpecificRevisionId;
  UINT16                        TypeDataLength;
  // Type specific data
} EFI_ACPI_SERIAL_BUS_RESOURCE_DESCRIPTOR;





///
/// Serial Bus Resource Descriptor (I2C)
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         RevisionId;
  UINT8                         ResourceSourceIndex;
  UINT8                         SerialBusType;
  UINT8                         GeneralFlags;
  UINT16                        TypeSpecificFlags;
  UINT8                         TypeSpecificRevisionId;
  UINT16                        TypeDataLength;
  UINT32                        ConnectionSpeed;
  UINT16                        SlaveAddress;
} EFI_ACPI_SERIAL_BUS_RESOURCE_I2C_DESCRIPTOR;

///
/// Serial Bus Resource Descriptor (SPI)
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         RevisionId;
  UINT8                         ResourceSourceIndex;
  UINT8                         SerialBusType;
  UINT8                         GeneralFlags;
  UINT16                        TypeSpecificFlags;
  UINT8                         TypeSpecificRevisionId;
  UINT16                        TypeDataLength;
  UINT32                        ConnectionSpeed;
  UINT8                         DataBitLength;
  UINT8                         Phase;
  UINT8                         Polarity;
  UINT16                        DeviceSelection;
} EFI_ACPI_SERIAL_BUS_RESOURCE_SPI_DESCRIPTOR;

///
/// Serial Bus Resource Descriptor (UART)
///
typedef  struct {
  ACPI_LARGE_RESOURCE_HEADER    Header;
  UINT8                         RevisionId;
  UINT8                         ResourceSourceIndex;
  UINT8                         SerialBusType;
  UINT8                         GeneralFlags;
  UINT16                        TypeSpecificFlags;
  UINT8                         TypeSpecificRevisionId;
  UINT16                        TypeDataLength;
  UINT32                        DefaultBaudRate;
  UINT16                        RxFIFO;
  UINT16                        TxFIFO;
  UINT8                         Parity;
  UINT8                         SerialLinesEnabled;
} EFI_ACPI_SERIAL_BUS_RESOURCE_UART_DESCRIPTOR;

#pragma pack()

//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 5.0 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     AccessSize;
  UINT64    Address;
} EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//








//
// Generic Address Space Access Sizes
//






//
// ACPI 5.0 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 5.0 spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_5_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 5.0 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 5.0 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT8                                     Reserved2[3];
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    SleepControlReg;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    SleepStatusReg;
} EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 5.0 spec.)
///


//
// Fixed ACPI Description Table Preferred Power Management Profile
//










//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//







//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//























///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved0[3];
  UINT32    OspmFlags;
  UINT8     Reserved1[24];
} EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 5.0 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///



///
/// OSPM Enabled Firmware Control Structure Flags
/// All other bits are reserved and must be set to 0.
///


//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//



///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 5.0 spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x0D and 0x7F are reserved and
// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
//














//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_5_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_5_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
  UINT8     CpeiProcessorOverride;
  UINT8     Reserved[31];
} EFI_ACPI_5_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//



///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_5_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_5_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_5_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_5_0_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
  UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_5_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_5_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Processor Local x2APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved[2];
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    AcpiProcessorUid;
} EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;

///
/// Local x2APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    AcpiProcessorUid;
  UINT8     LocalX2ApicLint;
  UINT8     Reserved[3];
} EFI_ACPI_5_0_LOCAL_X2APIC_NMI_STRUCTURE;

///
/// GIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT32    GicId;
  UINT32    AcpiProcessorUid;
  UINT32    Flags;
  UINT32    ParkingProtocolVersion;
  UINT32    PerformanceInterruptGsiv;
  UINT64    ParkedAddress;
  UINT64    PhysicalBaseAddress;
} EFI_ACPI_5_0_GIC_STRUCTURE;

///
/// GIC Flags.  All other bits are reserved and must be 0.
///



///
/// GIC Distributor Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved1;
  UINT32    GicId;
  UINT64    PhysicalBaseAddress;
  UINT32    SystemVectorBase;
  UINT32    Reserved2;
} EFI_ACPI_5_0_GIC_DISTRIBUTOR_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_5_0_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 5.0 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 5.0 spec.)
///


///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved1; ///< Must be set to 1
  UINT64                         Reserved2;
} EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 5.0 spec.)
///


//
// SRAT structure types.
// All other values between 0x03 an 0xFF are reserved and
// will be ignored by OSPM.
//




///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProximityDomain7To0;
  UINT8     ApicId;
  UINT32    Flags;
  UINT8     LocalSapicEid;
  UINT8     ProximityDomain31To8[3];
  UINT32    ClockDomain;
} EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///


///
/// Memory Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT16    Reserved1;
  UINT32    AddressBaseLow;
  UINT32    AddressBaseHigh;
  UINT32    LengthLow;
  UINT32    LengthHigh;
  UINT32    Reserved2;
  UINT32    Flags;
  UINT64    Reserved3;
} EFI_ACPI_5_0_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//




///
/// Processor Local x2APIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved1[2];
  UINT32    ProximityDomain;
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    ClockDomain;
  UINT8     Reserved2[4];
} EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_5_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 5.0 spec.)
///


///
/// Corrected Platform Error Polling Table (CPEP)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          Reserved[8];
} EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;

///
/// CPEP Version (as defined in ACPI 5.0 spec.)
///


//
// CPEP processor structure types.
//


///
/// Corrected Platform Error Polling Processor Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT32    PollingInterval;
} EFI_ACPI_5_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;

///
/// Maximum System Characteristics Table (MSCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         OffsetProxDomInfo;
  UINT32                         MaximumNumberOfProximityDomains;
  UINT32                         MaximumNumberOfClockDomains;
  UINT64                         MaximumPhysicalAddress;
} EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;

///
/// MSCT Version (as defined in ACPI 5.0 spec.)
///


///
/// Maximum Proximity Domain Information Structure Definition
///
typedef struct {
  UINT8     Revision;
  UINT8     Length;
  UINT32    ProximityDomainRangeLow;
  UINT32    ProximityDomainRangeHigh;
  UINT32    MaximumProcessorCapacity;
  UINT64    MaximumMemoryCapacity;
} EFI_ACPI_5_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;

///
/// ACPI RAS Feature Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier[12];
} EFI_ACPI_5_0_RAS_FEATURE_TABLE;

///
/// RASF Version (as defined in ACPI 5.0 spec.)
///


///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT16    Version;
  UINT8     RASCapabilities[16];
  UINT8     SetRASCapabilities[16];
  UINT16    NumberOfRASFParameterBlocks;
  UINT32    SetRASCapabilitiesStatus;
} EFI_ACPI_5_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI RASF PCC command code
///


///
/// ACPI RASF Platform RAS Capabilities
///



///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
typedef struct {
  UINT16    Type;
  UINT16    Version;
  UINT16    Length;
  UINT16    PatrolScrubCommand;
  UINT64    RequestedAddressRange[2];
  UINT64    ActualAddressRange[2];
  UINT16    Flags;
  UINT8     RequestedSpeed;
} EFI_ACPI_5_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;

///
/// ACPI RASF Patrol Scrub command
///




///
/// Memory Power State Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier;
  UINT8                          Reserved[3];
  // Memory Power Node Structure
  // Memory Power State Characteristics
} EFI_ACPI_5_0_MEMORY_POWER_STATUS_TABLE;

///
/// MPST Version (as defined in ACPI 5.0 spec.)
///


///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT32    MemoryPowerCommandRegister;
  UINT32    MemoryPowerStatusRegister;
  UINT32    PowerStateId;
  UINT32    MemoryPowerNodeId;
  UINT64    MemoryEnergyConsumed;
  UINT64    ExpectedAveragePowerComsuned;
} EFI_ACPI_5_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI MPST PCC command code
///


///
/// ACPI MPST Memory Power command
///





///
/// MPST Memory Power Node Table
///
typedef struct {
  UINT8    PowerStateValue;
  UINT8    PowerStateInformationIndex;
} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE;

typedef struct {
  UINT8     Flag;
  UINT8     Reserved;
  UINT16    MemoryPowerNodeId;
  UINT32    Length;
  UINT64    AddressBase;
  UINT64    AddressLength;
  UINT32    NumberOfPowerStates;
  UINT32    NumberOfPhysicalComponents;
  // EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
  // UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
} EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerNodeCount;
  UINT8     Reserved[2];
} EFI_ACPI_5_0_MPST_MEMORY_POWER_NODE_TABLE;

///
/// MPST Memory Power State Characteristics Table
///
typedef struct {
  UINT8     PowerStateStructureID;
  UINT8     Flag;
  UINT16    Reserved;
  UINT32    AveragePowerConsumedInMPS0;
  UINT32    RelativePowerSavingToMPS0;
  UINT64    ExitLatencyToMPS0;
} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerStateCharacteristicsCount;
  UINT8     Reserved[2];
} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;

///
/// Memory Topology Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved;
} EFI_ACPI_5_0_MEMORY_TOPOLOGY_TABLE;

///
/// PMTT Version (as defined in ACPI 5.0 spec.)
///


///
/// Common Memory Aggregator Device Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Reserved;
  UINT16    Length;
  UINT16    Flags;
  UINT16    Reserved1;
} EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Memory Aggregator Device Type
///




///
/// Socket Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         SocketIdentifier;
  UINT16                                                         Reserved;
  // EFI_ACPI_5_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
} EFI_ACPI_5_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// MemoryController Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT32                                                         ReadLatency;
  UINT32                                                         WriteLatency;
  UINT32                                                         ReadBandwidth;
  UINT32                                                         WriteBandwidth;
  UINT16                                                         OptimalAccessUnit;
  UINT16                                                         OptimalAccessAlignment;
  UINT16                                                         Reserved;
  UINT16                                                         NumberOfProximityDomains;
  // UINT32                                                       ProximityDomain[NumberOfProximityDomains];
  // EFI_ACPI_5_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
} EFI_ACPI_5_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// DIMM Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         PhysicalComponentIdentifier;
  UINT16                                                         Reserved;
  UINT32                                                         SizeOfDimm;
  UINT32                                                         SmbiosHandle;
} EFI_ACPI_5_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Boot Graphics Resource Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  ///
  /// 2-bytes (16 bit) version ID. This value must be 1.
  ///
  UINT16                         Version;
  ///
  /// 1-byte status field indicating current status about the table.
  ///     Bits[7:1] = Reserved (must be zero)
  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
  ///
  UINT8                          Status;
  ///
  /// 1-byte enumerated type field indicating format of the image.
  ///     0 = Bitmap
  ///     1 - 255  Reserved (for future use)
  ///
  UINT8                          ImageType;
  ///
  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
  /// of the image bitmap.
  ///
  UINT64                         ImageAddress;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetX;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetY;
} EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE;

///
/// BGRT Revision
///


///
/// BGRT Version
///


///
/// BGRT Status
///





///
/// BGRT Image Type
///


///
/// FPDT Version (as defined in ACPI 5.0 spec.)
///


///
/// FPDT Performance Record Types
///



///
/// FPDT Performance Record Revision
///



///
/// FPDT Runtime Performance Record Types
///




///
/// FPDT Runtime Performance Record Revision
///




///
/// FPDT Performance Record header
///
typedef struct {
  UINT16    Type;
  UINT8     Length;
  UINT8     Revision;
} EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;

///
/// FPDT Performance Table header
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER;

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
  ///
  UINT64                                         BootPerformanceTablePointer;
} EFI_ACPI_5_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT S3 Performance Table Pointer Record Structure
///
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the S3 Performance Table.
  ///
  UINT64                                         S3PerformanceTablePointer;
} EFI_ACPI_5_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// Timer value logged at the beginning of firmware image execution.
  /// This may not always be zero or near zero.
  ///
  UINT64                                         ResetEnd;
  ///
  /// Timer value logged just prior to loading the OS boot loader into memory.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         OsLoaderLoadImageStart;
  ///
  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
  /// For non-UEFI compatible boots, the timer value logged will be just prior
  /// to the INT 19h handler invocation.
  ///
  UINT64                                         OsLoaderStartImageStart;
  ///
  /// Timer value logged at the point when the OS loader calls the
  /// ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesEntry;
  ///
  /// Timer value logged at the point just prior to when the OS loader gaining
  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesExit;
} EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD;

///
/// FPDT Firmware Basic Boot Performance Table signature
///


//
// FPDT Firmware Basic Boot Performance Table
//
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE;

///
/// FPDT "S3PT" S3 Performance Table
///


//
// FPDT Firmware S3 Boot Performance Table
//
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_5_0_FPDT_FIRMWARE_S3_BOOT_TABLE;

///
/// FPDT Basic S3 Resume Performance Record
///
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// A count of the number of S3 resume cycles since the last full boot sequence.
  ///
  UINT32                                         ResumeCount;
  ///
  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
  /// OS waking vector. Only the most recent resume cycle's time is retained.
  ///
  UINT64                                         FullResume;
  ///
  /// Average timer value of all resume cycles logged since the last full boot
  /// sequence, including the most recent resume.  Note that the entire log of
  /// timer values does not need to be retained in order to calculate this average.
  ///
  UINT64                                         AverageResume;
} EFI_ACPI_5_0_FPDT_S3_RESUME_RECORD;

///
/// FPDT Basic S3 Suspend Performance Record
///
typedef struct {
  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendStart;
  ///
  /// Timer value recorded at the final firmware write to SLP_TYP (or other
  /// mechanism) used to trigger hardware entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendEnd;
} EFI_ACPI_5_0_FPDT_S3_SUSPEND_RECORD;

///
/// Firmware Performance Record Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_RECORD_TABLE;

///
/// Generic Timer Description Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         PhysicalAddress;
  UINT32                         GlobalFlags;
  UINT32                         SecurePL1TimerGSIV;
  UINT32                         SecurePL1TimerFlags;
  UINT32                         NonSecurePL1TimerGSIV;
  UINT32                         NonSecurePL1TimerFlags;
  UINT32                         VirtualTimerGSIV;
  UINT32                         VirtualTimerFlags;
  UINT32                         NonSecurePL2TimerGSIV;
  UINT32                         NonSecurePL2TimerFlags;
} EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE;

///
/// GTDT Version (as defined in ACPI 5.0 spec.)
///


///
/// Global Flags.  All other bits are reserved and must be 0.
///



///
/// Timer Flags.  All other bits are reserved and must be 0.
///



///
/// Boot Error Record Table (BERT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         BootErrorRegionLength;
  UINT64                         BootErrorRegion;
} EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_HEADER;

///
/// BERT Version (as defined in ACPI 5.0 spec.)
///


///
/// Boot Error Region Block Status Definition
///
typedef struct {
  UINT32    UncorrectableErrorValid     : 1;
  UINT32    CorrectableErrorValid       : 1;
  UINT32    MultipleUncorrectableErrors : 1;
  UINT32    MultipleCorrectableErrors   : 1;
  UINT32    ErrorDataEntryCount         : 10;
  UINT32    Reserved                    : 18;
} EFI_ACPI_5_0_ERROR_BLOCK_STATUS;

///
/// Boot Error Region Definition
///
typedef struct {
  EFI_ACPI_5_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_5_0_BOOT_ERROR_REGION_STRUCTURE;

//
// Boot Error Severity types
//






///
/// Generic Error Data Entry Definition
///
typedef struct {
  UINT8     SectionType[16];
  UINT32    ErrorSeverity;
  UINT16    Revision;
  UINT8     ValidationBits;
  UINT8     Flags;
  UINT32    ErrorDataLength;
  UINT8     FruId[16];
  UINT8     FruText[20];
} EFI_ACPI_5_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;

///
/// Generic Error Data Entry Version (as defined in ACPI 5.0 spec.)
///


///
/// HEST - Hardware Error Source Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         ErrorSourceCount;
} EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;

///
/// HEST Version (as defined in ACPI 5.0 spec.)
///


//
// Error Source structure types.
//








//
// Error Source structure flags.
//



///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT64    GlobalCapabilityInitData;
  UINT64    GlobalControlInitData;
  UINT8     NumberOfHardwareBanks;
  UINT8     Reserved1[7];
} EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
typedef struct {
  UINT8     BankNumber;
  UINT8     ClearStatusOnInitialization;
  UINT8     StatusDataFormat;
  UINT8     Reserved0;
  UINT32    ControlRegisterMsrAddress;
  UINT64    ControlInitData;
  UINT32    StatusRegisterMsrAddress;
  UINT32    AddressRegisterMsrAddress;
  UINT32    MiscRegisterMsrAddress;
} EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure MCA data format
///




//
// Hardware Error Notification types. All other values are reserved
//






///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
typedef struct {
  UINT16    Type                           : 1;
  UINT16    PollInterval                   : 1;
  UINT16    SwitchToPollingThresholdValue  : 1;
  UINT16    SwitchToPollingThresholdWindow : 1;
  UINT16    ErrorThresholdValue            : 1;
  UINT16    ErrorThresholdWindow           : 1;
  UINT16    Reserved                       : 10;
} EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;

///
/// Hardware Error Notification Structure Definition
///
typedef struct {
  UINT8                                                                            Type;
  UINT8                                                                            Length;
  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE    ConfigurationWriteEnable;
  UINT32                                                                           PollInterval;
  UINT32                                                                           Vector;
  UINT32                                                                           SwitchToPollingThresholdValue;
  UINT32                                                                           SwitchToPollingThresholdWindow;
  UINT32                                                                           ErrorThresholdValue;
  UINT32                                                                           ErrorThresholdWindow;
} EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT8                                                 Reserved0[2];
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT8                                                 NumberOfHardwareBanks;
  UINT8                                                 Reserved1[3];
} EFI_ACPI_5_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;

///
/// IA-32 Architecture NMI Error Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    MaxRawDataLength;
} EFI_ACPI_5_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;

///
/// PCI Express Root Port AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    RootErrorCommand;
} EFI_ACPI_5_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;

///
/// PCI Express Device AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_5_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;

///
/// PCI Express Bridge AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    SecondaryUncorrectableErrorMask;
  UINT32    SecondaryUncorrectableErrorSeverity;
  UINT32    SecondaryAdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_5_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;

///
/// Generic Hardware Error Source Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT16                                                RelatedSourceId;
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  UINT32                                                MaxRawDataLength;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT32                                                ErrorStatusBlockLength;
} EFI_ACPI_5_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;

///
/// Generic Error Status Definition
///
typedef struct {
  EFI_ACPI_5_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_5_0_GENERIC_ERROR_STATUS_STRUCTURE;

///
/// ERST - Error Record Serialization Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         SerializationHeaderSize;
  UINT8                          Reserved0[4];
  UINT32                         InstructionEntryCount;
} EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;

///
/// ERST Version (as defined in ACPI 5.0 spec.)
///


///
/// ERST Serialization Actions
///
















///
/// ERST Action Command Status
///







///
/// ERST Serialization Instructions
///




















///
/// ERST Instruction Flags
///


///
/// ERST Serialization Instruction Entry
///
typedef struct {
  UINT8                                     SerializationAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_5_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;

///
/// EINJ - Error Injection Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         InjectionHeaderSize;
  UINT8                          InjectionFlags;
  UINT8                          Reserved0[3];
  UINT32                         InjectionEntryCount;
} EFI_ACPI_5_0_ERROR_INJECTION_TABLE_HEADER;

///
/// EINJ Version (as defined in ACPI 5.0 spec.)
///


///
/// EINJ Error Injection Actions
///










///
/// EINJ Action Command Status
///




///
/// EINJ Error Type Definition
///













///
/// EINJ Injection Instructions
///






///
/// EINJ Instruction Flags
///


///
/// EINJ Injection Instruction Entry
///
typedef struct {
  UINT8                                     InjectionAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_5_0_EINJ_INJECTION_INSTRUCTION_ENTRY;

///
/// EINJ Trigger Action Table
///
typedef struct {
  UINT32    HeaderSize;
  UINT32    Revision;
  UINT32    TableSize;
  UINT32    EntryCount;
} EFI_ACPI_5_0_EINJ_TRIGGER_ACTION_TABLE;

///
/// Platform Communications Channel Table (PCCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Flags;
  UINT64                         Reserved;
} EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;

///
/// PCCT Version (as defined in ACPI 5.0 spec.)
///


///
/// PCCT Global Flags
///


//
// PCCT Subspace type
//


///
/// PCC Subspace Structure Header
///
typedef struct {
  UINT8    Type;
  UINT8    Length;
} EFI_ACPI_5_0_PCCT_SUBSPACE_HEADER;

///
/// Generic Communications Subspace Structure
///
typedef struct {
  UINT8                                     Type;
  UINT8                                     Length;
  UINT8                                     Reserved[6];
  UINT64                                    BaseAddress;
  UINT64                                    AddressLength;
  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
  UINT64                                    DoorbellPreserve;
  UINT64                                    DoorbellWrite;
  UINT32                                    NominalLatency;
  UINT32                                    MaximumPeriodicAccessRate;
  UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_5_0_PCCT_SUBSPACE_GENERIC;

///
/// Generic Communications Channel Shared Memory Region
///

typedef struct {
  UINT8    Command;
  UINT8    Reserved    : 7;
  UINT8    GenerateSci : 1;
} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;

typedef struct {
  UINT8    CommandComplete      : 1;
  UINT8    SciDoorbell          : 1;
  UINT8    Error                : 1;
  UINT8    PlatformNotification : 1;
  UINT8    Reserved             : 4;
  UINT8    Reserved1;
} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;

typedef struct {
  UINT32                                                    Signature;
  EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
  EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "BERT" Boot Error Record Table
///


///
/// "BGRT" Boot Graphics Resource Table
///


///
/// "CPEP" Corrected Platform Error Polling Table
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "EINJ" Error Injection Table
///


///
/// "ERST" Error Record Serialization Table
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "FPDT" Firmware Performance Data Table
///


///
/// "GTDT" Generic Timer Description Table
///


///
/// "HEST" Hardware Error Source Table
///


///
/// "MPST" Memory Power State Table
///


///
/// "MSCT" Maximum System Characteristics Table
///


///
/// "PMTT" Platform Memory Topology Table
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RASF" ACPI RAS Feature Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SRAT" System Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "CSRT" MS Core System Resource Table
///


///
/// "DBG2" MS Debug Port 2 Spec
///


///
/// "DBGP" MS Debug Port Spec
///


///
/// "DMAR" DMA Remapping Table
///


///
/// "DRTM" Dynamic Root of Trust for Measurement Table
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "HPET" IA-PC High Precision Event Timer Table
///


///
/// "iBFT" iSCSI Boot Firmware Table
///


///
/// "IVRS" I/O Virtualization Reporting Structure
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


///
/// "MCHI" Management Controller Host Interface Table
///


///
/// "MSDM" MS Data Management Table
///


///
/// "PCCT" Platform Communications Channel Table
///


///
/// "SLIC" MS Software Licensing Table Specification
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///


///
/// "TPM2" Trusted Computing Platform 1 Table
///


///
/// "UEFI" UEFI ACPI Data Table
///


///
/// "WAET" Windows ACPI Emulated Devices Table
///



///
/// "WDAT" Watchdog Action Table
///


///
/// "WDRT" Watchdog Resource Table
///


///
/// "WPBT" MS Platform Binary Table
///


#pragma pack()

#line 2131 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi50.h"
#line 15 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi51.h"

///
/// _PSD Revision for ACPI 5.1
///


///
/// _CPC Revision for ACPI 5.1
///


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 5.1 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     AccessSize;
  UINT64    Address;
} EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//








//
// Generic Address Space Access Sizes
//






//
// ACPI 5.1 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 5.1 spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_5_1_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 5.1 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 5.1 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT16                                    ArmBootArch;
  UINT8                                     MinorVersion;
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    SleepControlReg;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    SleepStatusReg;
} EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 5.1 spec.)
///



//
// Fixed ACPI Description Table Preferred Power Management Profile
//










//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//







//
// Fixed ACPI Description Table Arm Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//



//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//























///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved0[3];
  UINT32    OspmFlags;
  UINT8     Reserved1[24];
} EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 5.1 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///



///
/// OSPM Enabled Firmware Control Structure Flags
/// All other bits are reserved and must be set to 0.
///


//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//



///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 5.1 spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x0D and 0x7F are reserved and
// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
//
















//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_5_1_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_5_1_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
  UINT8     CpeiProcessorOverride;
  UINT8     Reserved[31];
} EFI_ACPI_5_1_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//



///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_5_1_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_5_1_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_5_1_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_5_1_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
  UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_5_1_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_5_1_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Processor Local x2APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved[2];
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    AcpiProcessorUid;
} EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_STRUCTURE;

///
/// Local x2APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    AcpiProcessorUid;
  UINT8     LocalX2ApicLint;
  UINT8     Reserved[3];
} EFI_ACPI_5_1_LOCAL_X2APIC_NMI_STRUCTURE;

///
/// GIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT32    CPUInterfaceNumber;
  UINT32    AcpiProcessorUid;
  UINT32    Flags;
  UINT32    ParkingProtocolVersion;
  UINT32    PerformanceInterruptGsiv;
  UINT64    ParkedAddress;
  UINT64    PhysicalBaseAddress;
  UINT64    GICV;
  UINT64    GICH;
  UINT32    VGICMaintenanceInterrupt;
  UINT64    GICRBaseAddress;
  UINT64    MPIDR;
} EFI_ACPI_5_1_GIC_STRUCTURE;

///
/// GIC Flags.  All other bits are reserved and must be 0.
///




///
/// GIC Distributor Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved1;
  UINT32    GicId;
  UINT64    PhysicalBaseAddress;
  UINT32    SystemVectorBase;
  UINT8     GicVersion;
  UINT8     Reserved2[3];
} EFI_ACPI_5_1_GIC_DISTRIBUTOR_STRUCTURE;

///
/// GIC Version
///





///
/// GIC MSI Frame Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved1;
  UINT32    GicMsiFrameId;
  UINT64    PhysicalBaseAddress;
  UINT32    Flags;
  UINT16    SPICount;
  UINT16    SPIBase;
} EFI_ACPI_5_1_GIC_MSI_FRAME_STRUCTURE;

///
/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
///


///
/// GICR Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    DiscoveryRangeBaseAddress;
  UINT32    DiscoveryRangeLength;
} EFI_ACPI_5_1_GICR_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_5_1_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 5.1 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 5.1 spec.)
///


///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved1; ///< Must be set to 1
  UINT64                         Reserved2;
} EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 5.1 spec.)
///


//
// SRAT structure types.
// All other values between 0x04 an 0xFF are reserved and
// will be ignored by OSPM.
//





///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProximityDomain7To0;
  UINT8     ApicId;
  UINT32    Flags;
  UINT8     LocalSapicEid;
  UINT8     ProximityDomain31To8[3];
  UINT32    ClockDomain;
} EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///


///
/// Memory Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT16    Reserved1;
  UINT32    AddressBaseLow;
  UINT32    AddressBaseHigh;
  UINT32    LengthLow;
  UINT32    LengthHigh;
  UINT32    Reserved2;
  UINT32    Flags;
  UINT64    Reserved3;
} EFI_ACPI_5_1_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//




///
/// Processor Local x2APIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved1[2];
  UINT32    ProximityDomain;
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    ClockDomain;
  UINT8     Reserved2[4];
} EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;

///
/// GICC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT32    AcpiProcessorUid;
  UINT32    Flags;
  UINT32    ClockDomain;
} EFI_ACPI_5_1_GICC_AFFINITY_STRUCTURE;

///
/// GICC Flags.  All other bits are reserved and must be 0.
///


///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_5_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 5.1 spec.)
///


///
/// Corrected Platform Error Polling Table (CPEP)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          Reserved[8];
} EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;

///
/// CPEP Version (as defined in ACPI 5.1 spec.)
///


//
// CPEP processor structure types.
//


///
/// Corrected Platform Error Polling Processor Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT32    PollingInterval;
} EFI_ACPI_5_1_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;

///
/// Maximum System Characteristics Table (MSCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         OffsetProxDomInfo;
  UINT32                         MaximumNumberOfProximityDomains;
  UINT32                         MaximumNumberOfClockDomains;
  UINT64                         MaximumPhysicalAddress;
} EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;

///
/// MSCT Version (as defined in ACPI 5.1 spec.)
///


///
/// Maximum Proximity Domain Information Structure Definition
///
typedef struct {
  UINT8     Revision;
  UINT8     Length;
  UINT32    ProximityDomainRangeLow;
  UINT32    ProximityDomainRangeHigh;
  UINT32    MaximumProcessorCapacity;
  UINT64    MaximumMemoryCapacity;
} EFI_ACPI_5_1_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;

///
/// ACPI RAS Feature Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier[12];
} EFI_ACPI_5_1_RAS_FEATURE_TABLE;

///
/// RASF Version (as defined in ACPI 5.1 spec.)
///


///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT16    Version;
  UINT8     RASCapabilities[16];
  UINT8     SetRASCapabilities[16];
  UINT16    NumberOfRASFParameterBlocks;
  UINT32    SetRASCapabilitiesStatus;
} EFI_ACPI_5_1_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI RASF PCC command code
///


///
/// ACPI RASF Platform RAS Capabilities
///



///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
typedef struct {
  UINT16    Type;
  UINT16    Version;
  UINT16    Length;
  UINT16    PatrolScrubCommand;
  UINT64    RequestedAddressRange[2];
  UINT64    ActualAddressRange[2];
  UINT16    Flags;
  UINT8     RequestedSpeed;
} EFI_ACPI_5_1_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;

///
/// ACPI RASF Patrol Scrub command
///




///
/// Memory Power State Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier;
  UINT8                          Reserved[3];
  // Memory Power Node Structure
  // Memory Power State Characteristics
} EFI_ACPI_5_1_MEMORY_POWER_STATUS_TABLE;

///
/// MPST Version (as defined in ACPI 5.1 spec.)
///


///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT32    MemoryPowerCommandRegister;
  UINT32    MemoryPowerStatusRegister;
  UINT32    PowerStateId;
  UINT32    MemoryPowerNodeId;
  UINT64    MemoryEnergyConsumed;
  UINT64    ExpectedAveragePowerComsuned;
} EFI_ACPI_5_1_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI MPST PCC command code
///


///
/// ACPI MPST Memory Power command
///





///
/// MPST Memory Power Node Table
///
typedef struct {
  UINT8    PowerStateValue;
  UINT8    PowerStateInformationIndex;
} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE;

typedef struct {
  UINT8     Flag;
  UINT8     Reserved;
  UINT16    MemoryPowerNodeId;
  UINT32    Length;
  UINT64    AddressBase;
  UINT64    AddressLength;
  UINT32    NumberOfPowerStates;
  UINT32    NumberOfPhysicalComponents;
  // EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
  // UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
} EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerNodeCount;
  UINT8     Reserved[2];
} EFI_ACPI_5_1_MPST_MEMORY_POWER_NODE_TABLE;

///
/// MPST Memory Power State Characteristics Table
///
typedef struct {
  UINT8     PowerStateStructureID;
  UINT8     Flag;
  UINT16    Reserved;
  UINT32    AveragePowerConsumedInMPS0;
  UINT32    RelativePowerSavingToMPS0;
  UINT64    ExitLatencyToMPS0;
} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerStateCharacteristicsCount;
  UINT8     Reserved[2];
} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;

///
/// Memory Topology Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved;
} EFI_ACPI_5_1_MEMORY_TOPOLOGY_TABLE;

///
/// PMTT Version (as defined in ACPI 5.1 spec.)
///


///
/// Common Memory Aggregator Device Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Reserved;
  UINT16    Length;
  UINT16    Flags;
  UINT16    Reserved1;
} EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Memory Aggregator Device Type
///




///
/// Socket Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         SocketIdentifier;
  UINT16                                                         Reserved;
  // EFI_ACPI_5_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
} EFI_ACPI_5_1_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// MemoryController Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT32                                                         ReadLatency;
  UINT32                                                         WriteLatency;
  UINT32                                                         ReadBandwidth;
  UINT32                                                         WriteBandwidth;
  UINT16                                                         OptimalAccessUnit;
  UINT16                                                         OptimalAccessAlignment;
  UINT16                                                         Reserved;
  UINT16                                                         NumberOfProximityDomains;
  // UINT32                                                       ProximityDomain[NumberOfProximityDomains];
  // EFI_ACPI_5_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
} EFI_ACPI_5_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// DIMM Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         PhysicalComponentIdentifier;
  UINT16                                                         Reserved;
  UINT32                                                         SizeOfDimm;
  UINT32                                                         SmbiosHandle;
} EFI_ACPI_5_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Boot Graphics Resource Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  ///
  /// 2-bytes (16 bit) version ID. This value must be 1.
  ///
  UINT16                         Version;
  ///
  /// 1-byte status field indicating current status about the table.
  ///     Bits[7:1] = Reserved (must be zero)
  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
  ///
  UINT8                          Status;
  ///
  /// 1-byte enumerated type field indicating format of the image.
  ///     0 = Bitmap
  ///     1 - 255  Reserved (for future use)
  ///
  UINT8                          ImageType;
  ///
  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
  /// of the image bitmap.
  ///
  UINT64                         ImageAddress;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetX;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetY;
} EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE;

///
/// BGRT Revision
///


///
/// BGRT Version
///


///
/// BGRT Status
///



///
/// BGRT Image Type
///


///
/// FPDT Version (as defined in ACPI 5.1 spec.)
///


///
/// FPDT Performance Record Types
///



///
/// FPDT Performance Record Revision
///



///
/// FPDT Runtime Performance Record Types
///




///
/// FPDT Runtime Performance Record Revision
///




///
/// FPDT Performance Record header
///
typedef struct {
  UINT16    Type;
  UINT8     Length;
  UINT8     Revision;
} EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;

///
/// FPDT Performance Table header
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER;

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
  ///
  UINT64                                         BootPerformanceTablePointer;
} EFI_ACPI_5_1_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT S3 Performance Table Pointer Record Structure
///
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the S3 Performance Table.
  ///
  UINT64                                         S3PerformanceTablePointer;
} EFI_ACPI_5_1_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// Timer value logged at the beginning of firmware image execution.
  /// This may not always be zero or near zero.
  ///
  UINT64                                         ResetEnd;
  ///
  /// Timer value logged just prior to loading the OS boot loader into memory.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         OsLoaderLoadImageStart;
  ///
  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
  /// For non-UEFI compatible boots, the timer value logged will be just prior
  /// to the INT 19h handler invocation.
  ///
  UINT64                                         OsLoaderStartImageStart;
  ///
  /// Timer value logged at the point when the OS loader calls the
  /// ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesEntry;
  ///
  /// Timer value logged at the point just prior to when the OS loader gaining
  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesExit;
} EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_RECORD;

///
/// FPDT Firmware Basic Boot Performance Table signature
///


//
// FPDT Firmware Basic Boot Performance Table
//
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_TABLE;

///
/// FPDT "S3PT" S3 Performance Table
///


//
// FPDT Firmware S3 Boot Performance Table
//
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_5_1_FPDT_FIRMWARE_S3_BOOT_TABLE;

///
/// FPDT Basic S3 Resume Performance Record
///
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// A count of the number of S3 resume cycles since the last full boot sequence.
  ///
  UINT32                                         ResumeCount;
  ///
  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
  /// OS waking vector. Only the most recent resume cycle's time is retained.
  ///
  UINT64                                         FullResume;
  ///
  /// Average timer value of all resume cycles logged since the last full boot
  /// sequence, including the most recent resume.  Note that the entire log of
  /// timer values does not need to be retained in order to calculate this average.
  ///
  UINT64                                         AverageResume;
} EFI_ACPI_5_1_FPDT_S3_RESUME_RECORD;

///
/// FPDT Basic S3 Suspend Performance Record
///
typedef struct {
  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendStart;
  ///
  /// Timer value recorded at the final firmware write to SLP_TYP (or other
  /// mechanism) used to trigger hardware entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendEnd;
} EFI_ACPI_5_1_FPDT_S3_SUSPEND_RECORD;

///
/// Firmware Performance Record Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_RECORD_TABLE;

///
/// Generic Timer Description Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         CntControlBasePhysicalAddress;
  UINT32                         Reserved;
  UINT32                         SecurePL1TimerGSIV;
  UINT32                         SecurePL1TimerFlags;
  UINT32                         NonSecurePL1TimerGSIV;
  UINT32                         NonSecurePL1TimerFlags;
  UINT32                         VirtualTimerGSIV;
  UINT32                         VirtualTimerFlags;
  UINT32                         NonSecurePL2TimerGSIV;
  UINT32                         NonSecurePL2TimerFlags;
  UINT64                         CntReadBasePhysicalAddress;
  UINT32                         PlatformTimerCount;
  UINT32                         PlatformTimerOffset;
} EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE;

///
/// GTDT Version (as defined in ACPI 5.1 spec.)
///


///
/// Timer Flags.  All other bits are reserved and must be 0.
///




///
/// Platform Timer Type
///



///
/// GT Block Structure
///
typedef struct {
  UINT8     Type;
  UINT16    Length;
  UINT8     Reserved;
  UINT64    CntCtlBase;
  UINT32    GTBlockTimerCount;
  UINT32    GTBlockTimerOffset;
} EFI_ACPI_5_1_GTDT_GT_BLOCK_STRUCTURE;

///
/// GT Block Timer Structure
///
typedef struct {
  UINT8     GTFrameNumber;
  UINT8     Reserved[3];
  UINT64    CntBaseX;
  UINT64    CntEL0BaseX;
  UINT32    GTxPhysicalTimerGSIV;
  UINT32    GTxPhysicalTimerFlags;
  UINT32    GTxVirtualTimerGSIV;
  UINT32    GTxVirtualTimerFlags;
  UINT32    GTxCommonFlags;
} EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_STRUCTURE;

///
/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
///



///
/// Common Flags Flags.  All other bits are reserved and must be 0.
///



///
/// SBSA Generic Watchdog Structure
///
typedef struct {
  UINT8     Type;
  UINT16    Length;
  UINT8     Reserved;
  UINT64    RefreshFramePhysicalAddress;
  UINT64    WatchdogControlFramePhysicalAddress;
  UINT32    WatchdogTimerGSIV;
  UINT32    WatchdogTimerFlags;
} EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;

///
/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
///




///
/// Boot Error Record Table (BERT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         BootErrorRegionLength;
  UINT64                         BootErrorRegion;
} EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_HEADER;

///
/// BERT Version (as defined in ACPI 5.1 spec.)
///


///
/// Boot Error Region Block Status Definition
///
typedef struct {
  UINT32    UncorrectableErrorValid     : 1;
  UINT32    CorrectableErrorValid       : 1;
  UINT32    MultipleUncorrectableErrors : 1;
  UINT32    MultipleCorrectableErrors   : 1;
  UINT32    ErrorDataEntryCount         : 10;
  UINT32    Reserved                    : 18;
} EFI_ACPI_5_1_ERROR_BLOCK_STATUS;

///
/// Boot Error Region Definition
///
typedef struct {
  EFI_ACPI_5_1_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_5_1_BOOT_ERROR_REGION_STRUCTURE;

//
// Boot Error Severity types
//




//
// The term 'Correctable' is no longer being used as an error severity of the
// reported error since ACPI Specification Version 5.1 Errata B.
// The below macro is considered as deprecated and should no longer be used.
//


///
/// Generic Error Data Entry Definition
///
typedef struct {
  UINT8     SectionType[16];
  UINT32    ErrorSeverity;
  UINT16    Revision;
  UINT8     ValidationBits;
  UINT8     Flags;
  UINT32    ErrorDataLength;
  UINT8     FruId[16];
  UINT8     FruText[20];
} EFI_ACPI_5_1_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;

///
/// Generic Error Data Entry Version (as defined in ACPI 5.1 spec.)
///


///
/// HEST - Hardware Error Source Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         ErrorSourceCount;
} EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_HEADER;

///
/// HEST Version (as defined in ACPI 5.1 spec.)
///


//
// Error Source structure types.
//








//
// Error Source structure flags.
//



///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT64    GlobalCapabilityInitData;
  UINT64    GlobalControlInitData;
  UINT8     NumberOfHardwareBanks;
  UINT8     Reserved1[7];
} EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
typedef struct {
  UINT8     BankNumber;
  UINT8     ClearStatusOnInitialization;
  UINT8     StatusDataFormat;
  UINT8     Reserved0;
  UINT32    ControlRegisterMsrAddress;
  UINT64    ControlInitData;
  UINT32    StatusRegisterMsrAddress;
  UINT32    AddressRegisterMsrAddress;
  UINT32    MiscRegisterMsrAddress;
} EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure MCA data format
///




//
// Hardware Error Notification types. All other values are reserved
//






///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
typedef struct {
  UINT16    Type                           : 1;
  UINT16    PollInterval                   : 1;
  UINT16    SwitchToPollingThresholdValue  : 1;
  UINT16    SwitchToPollingThresholdWindow : 1;
  UINT16    ErrorThresholdValue            : 1;
  UINT16    ErrorThresholdWindow           : 1;
  UINT16    Reserved                       : 10;
} EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;

///
/// Hardware Error Notification Structure Definition
///
typedef struct {
  UINT8                                                                            Type;
  UINT8                                                                            Length;
  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE    ConfigurationWriteEnable;
  UINT32                                                                           PollInterval;
  UINT32                                                                           Vector;
  UINT32                                                                           SwitchToPollingThresholdValue;
  UINT32                                                                           SwitchToPollingThresholdWindow;
  UINT32                                                                           ErrorThresholdValue;
  UINT32                                                                           ErrorThresholdWindow;
} EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT8                                                 Reserved0[2];
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT8                                                 NumberOfHardwareBanks;
  UINT8                                                 Reserved1[3];
} EFI_ACPI_5_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;

///
/// IA-32 Architecture NMI Error Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    MaxRawDataLength;
} EFI_ACPI_5_1_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;

///
/// PCI Express Root Port AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    RootErrorCommand;
} EFI_ACPI_5_1_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;

///
/// PCI Express Device AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_5_1_PCI_EXPRESS_DEVICE_AER_STRUCTURE;

///
/// PCI Express Bridge AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    SecondaryUncorrectableErrorMask;
  UINT32    SecondaryUncorrectableErrorSeverity;
  UINT32    SecondaryAdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_5_1_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;

///
/// Generic Hardware Error Source Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT16                                                RelatedSourceId;
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  UINT32                                                MaxRawDataLength;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT32                                                ErrorStatusBlockLength;
} EFI_ACPI_5_1_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;

///
/// Generic Error Status Definition
///
typedef struct {
  EFI_ACPI_5_1_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_5_1_GENERIC_ERROR_STATUS_STRUCTURE;

///
/// ERST - Error Record Serialization Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         SerializationHeaderSize;
  UINT8                          Reserved0[4];
  UINT32                         InstructionEntryCount;
} EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;

///
/// ERST Version (as defined in ACPI 5.1 spec.)
///


///
/// ERST Serialization Actions
///
















///
/// ERST Action Command Status
///







///
/// ERST Serialization Instructions
///




















///
/// ERST Instruction Flags
///


///
/// ERST Serialization Instruction Entry
///
typedef struct {
  UINT8                                     SerializationAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_5_1_ERST_SERIALIZATION_INSTRUCTION_ENTRY;

///
/// EINJ - Error Injection Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         InjectionHeaderSize;
  UINT8                          InjectionFlags;
  UINT8                          Reserved0[3];
  UINT32                         InjectionEntryCount;
} EFI_ACPI_5_1_ERROR_INJECTION_TABLE_HEADER;

///
/// EINJ Version (as defined in ACPI 5.1 spec.)
///


///
/// EINJ Error Injection Actions
///











///
/// EINJ Action Command Status
///




///
/// EINJ Error Type Definition
///













///
/// EINJ Injection Instructions
///






///
/// EINJ Instruction Flags
///


///
/// EINJ Injection Instruction Entry
///
typedef struct {
  UINT8                                     InjectionAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_5_1_EINJ_INJECTION_INSTRUCTION_ENTRY;

///
/// EINJ Trigger Action Table
///
typedef struct {
  UINT32    HeaderSize;
  UINT32    Revision;
  UINT32    TableSize;
  UINT32    EntryCount;
} EFI_ACPI_5_1_EINJ_TRIGGER_ACTION_TABLE;

///
/// Platform Communications Channel Table (PCCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Flags;
  UINT64                         Reserved;
} EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;

///
/// PCCT Version (as defined in ACPI 5.1 spec.)
///


///
/// PCCT Global Flags
///


//
// PCCT Subspace type
//


///
/// PCC Subspace Structure Header
///
typedef struct {
  UINT8    Type;
  UINT8    Length;
} EFI_ACPI_5_1_PCCT_SUBSPACE_HEADER;

///
/// Generic Communications Subspace Structure
///
typedef struct {
  UINT8                                     Type;
  UINT8                                     Length;
  UINT8                                     Reserved[6];
  UINT64                                    BaseAddress;
  UINT64                                    AddressLength;
  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
  UINT64                                    DoorbellPreserve;
  UINT64                                    DoorbellWrite;
  UINT32                                    NominalLatency;
  UINT32                                    MaximumPeriodicAccessRate;
  UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_5_1_PCCT_SUBSPACE_GENERIC;

///
/// Generic Communications Channel Shared Memory Region
///

typedef struct {
  UINT8    Command;
  UINT8    Reserved    : 7;
  UINT8    GenerateSci : 1;
} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;

typedef struct {
  UINT8    CommandComplete      : 1;
  UINT8    SciDoorbell          : 1;
  UINT8    Error                : 1;
  UINT8    PlatformNotification : 1;
  UINT8    Reserved             : 4;
  UINT8    Reserved1;
} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;

typedef struct {
  UINT32                                                    Signature;
  EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
  EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "BERT" Boot Error Record Table
///


///
/// "BGRT" Boot Graphics Resource Table
///


///
/// "CPEP" Corrected Platform Error Polling Table
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "EINJ" Error Injection Table
///


///
/// "ERST" Error Record Serialization Table
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "FPDT" Firmware Performance Data Table
///


///
/// "GTDT" Generic Timer Description Table
///


///
/// "HEST" Hardware Error Source Table
///


///
/// "MPST" Memory Power State Table
///


///
/// "MSCT" Maximum System Characteristics Table
///


///
/// "PMTT" Platform Memory Topology Table
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RASF" ACPI RAS Feature Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SRAT" System Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "CSRT" MS Core System Resource Table
///


///
/// "DBG2" MS Debug Port 2 Spec
///


///
/// "DBGP" MS Debug Port Spec
///


///
/// "DMAR" DMA Remapping Table
///


///
/// "DRTM" Dynamic Root of Trust for Measurement Table
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "HPET" IA-PC High Precision Event Timer Table
///


///
/// "iBFT" iSCSI Boot Firmware Table
///


///
/// "IVRS" I/O Virtualization Reporting Structure
///


///
/// "LPIT" Low Power Idle Table
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


///
/// "MCHI" Management Controller Host Interface Table
///


///
/// "MSDM" MS Data Management Table
///


///
/// "PCCT" Platform Communications Channel Table
///


///
/// "SLIC" MS Software Licensing Table Specification
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///


///
/// "TPM2" Trusted Computing Platform 1 Table
///


///
/// "UEFI" UEFI ACPI Data Table
///


///
/// "WAET" Windows ACPI Emulated Devices Table
///


///
/// "WDAT" Watchdog Action Table
///


///
/// "WDRT" Watchdog Resource Table
///


///
/// "WPBT" MS Platform Binary Table
///


#pragma pack()

#line 2157 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi51.h"
#line 14 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi60.h"

///
/// _PSD Revision for ACPI 6.0
///


///
/// _CPC Revision for ACPI 6.0
///


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 6.0 Generic Address Space definition
///
typedef struct {
  UINT8     AddressSpaceId;
  UINT8     RegisterBitWidth;
  UINT8     RegisterBitOffset;
  UINT8     AccessSize;
  UINT64    Address;
} EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//








//
// Generic Address Space Access Sizes
//






//
// ACPI 6.0 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
  UINT64    Signature;
  UINT8     Checksum;
  UINT8     OemId[6];
  UINT8     Revision;
  UINT32    RsdtAddress;
  UINT32    Length;
  UINT64    XsdtAddress;
  UINT8     ExtendedChecksum;
  UINT8     Reserved[3];
} EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 6.0 spec.)
///


///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_6_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 6.0 spec.)
///


//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 6.0 spec.)
///


///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  UINT32                                    FirmwareCtrl;
  UINT32                                    Dsdt;
  UINT8                                     Reserved0;
  UINT8                                     PreferredPmProfile;
  UINT16                                    SciInt;
  UINT32                                    SmiCmd;
  UINT8                                     AcpiEnable;
  UINT8                                     AcpiDisable;
  UINT8                                     S4BiosReq;
  UINT8                                     PstateCnt;
  UINT32                                    Pm1aEvtBlk;
  UINT32                                    Pm1bEvtBlk;
  UINT32                                    Pm1aCntBlk;
  UINT32                                    Pm1bCntBlk;
  UINT32                                    Pm2CntBlk;
  UINT32                                    PmTmrBlk;
  UINT32                                    Gpe0Blk;
  UINT32                                    Gpe1Blk;
  UINT8                                     Pm1EvtLen;
  UINT8                                     Pm1CntLen;
  UINT8                                     Pm2CntLen;
  UINT8                                     PmTmrLen;
  UINT8                                     Gpe0BlkLen;
  UINT8                                     Gpe1BlkLen;
  UINT8                                     Gpe1Base;
  UINT8                                     CstCnt;
  UINT16                                    PLvl2Lat;
  UINT16                                    PLvl3Lat;
  UINT16                                    FlushSize;
  UINT16                                    FlushStride;
  UINT8                                     DutyOffset;
  UINT8                                     DutyWidth;
  UINT8                                     DayAlrm;
  UINT8                                     MonAlrm;
  UINT8                                     Century;
  UINT16                                    IaPcBootArch;
  UINT8                                     Reserved1;
  UINT32                                    Flags;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
  UINT8                                     ResetValue;
  UINT16                                    ArmBootArch;
  UINT8                                     MinorVersion;
  UINT64                                    XFirmwareCtrl;
  UINT64                                    XDsdt;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    SleepControlReg;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    SleepStatusReg;
  UINT64                                    HypervisorVendorIdentity;
} EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 6.0 spec.)
///



//
// Fixed ACPI Description Table Preferred Power Management Profile
//










//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//







//
// Fixed ACPI Description Table Arm Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//



//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//























///
/// Firmware ACPI Control Structure
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
  UINT32    HardwareSignature;
  UINT32    FirmwareWakingVector;
  UINT32    GlobalLock;
  UINT32    Flags;
  UINT64    XFirmwareWakingVector;
  UINT8     Version;
  UINT8     Reserved0[3];
  UINT32    OspmFlags;
  UINT8     Reserved1[24];
} EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 6.0 spec.)
///


///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///



///
/// OSPM Enabled Firmware Control Structure Flags
/// All other bits are reserved and must be set to 0.
///


//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//



///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         LocalApicAddress;
  UINT32                         Flags;
} EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 6.0 Errata A spec.)
///


///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///


//
// Multiple APIC Description Table APIC structure types
// All other values between 0x0D and 0x7F are reserved and
// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
//

















//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorUid;
  UINT8     ApicId;
  UINT32    Flags;
} EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///


///
/// IO APIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    IoApicAddress;
  UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_6_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Bus;
  UINT8     Source;
  UINT32    GlobalSystemInterrupt;
  UINT16    Flags;
} EFI_ACPI_6_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
  UINT8     CpeiProcessorOverride;
  UINT8     Reserved[31];
} EFI_ACPI_6_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//



///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    GlobalSystemInterrupt;
} EFI_ACPI_6_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorUid;
  UINT16    Flags;
  UINT8     LocalApicLint;
} EFI_ACPI_6_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    LocalApicAddress;
} EFI_ACPI_6_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     IoApicId;
  UINT8     Reserved;
  UINT32    GlobalSystemInterruptBase;
  UINT64    IoSapicAddress;
} EFI_ACPI_6_0_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     AcpiProcessorId;
  UINT8     LocalSapicId;
  UINT8     LocalSapicEid;
  UINT8     Reserved[3];
  UINT32    Flags;
  UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_6_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT8     InterruptType;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT8     IoSapicVector;
  UINT32    GlobalSystemInterrupt;
  UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_6_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///


///
/// Processor Local x2APIC Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved[2];
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    AcpiProcessorUid;
} EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;

///
/// Local x2APIC NMI Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Flags;
  UINT32    AcpiProcessorUid;
  UINT8     LocalX2ApicLint;
  UINT8     Reserved[3];
} EFI_ACPI_6_0_LOCAL_X2APIC_NMI_STRUCTURE;

///
/// GIC Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT32    CPUInterfaceNumber;
  UINT32    AcpiProcessorUid;
  UINT32    Flags;
  UINT32    ParkingProtocolVersion;
  UINT32    PerformanceInterruptGsiv;
  UINT64    ParkedAddress;
  UINT64    PhysicalBaseAddress;
  UINT64    GICV;
  UINT64    GICH;
  UINT32    VGICMaintenanceInterrupt;
  UINT64    GICRBaseAddress;
  UINT64    MPIDR;
  UINT8     ProcessorPowerEfficiencyClass;
  UINT8     Reserved2[3];
} EFI_ACPI_6_0_GIC_STRUCTURE;

///
/// GIC Flags.  All other bits are reserved and must be 0.
///




///
/// GIC Distributor Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved1;
  UINT32    GicId;
  UINT64    PhysicalBaseAddress;
  UINT32    SystemVectorBase;
  UINT8     GicVersion;
  UINT8     Reserved2[3];
} EFI_ACPI_6_0_GIC_DISTRIBUTOR_STRUCTURE;

///
/// GIC Version
///





///
/// GIC MSI Frame Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved1;
  UINT32    GicMsiFrameId;
  UINT64    PhysicalBaseAddress;
  UINT32    Flags;
  UINT16    SPICount;
  UINT16    SPIBase;
} EFI_ACPI_6_0_GIC_MSI_FRAME_STRUCTURE;

///
/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
///


///
/// GICR Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT64    DiscoveryRangeBaseAddress;
  UINT32    DiscoveryRangeLength;
} EFI_ACPI_6_0_GICR_STRUCTURE;

///
/// GIC Interrupt Translation Service Structure
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT16    Reserved;
  UINT32    GicItsId;
  UINT64    PhysicalBaseAddress;
  UINT32    Reserved2;
} EFI_ACPI_6_0_GIC_ITS_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         WarningEnergyLevel;
  UINT32                         LowEnergyLevel;
  UINT32                         CriticalEnergyLevel;
} EFI_ACPI_6_0_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 6.0 spec.)
///


///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER               Header;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    EcControl;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    EcData;
  UINT32                                    Uid;
  UINT8                                     GpeBit;
} EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 6.0 spec.)
///


///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved1; ///< Must be set to 1
  UINT64                         Reserved2;
} EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 6.0 spec.)
///


//
// SRAT structure types.
// All other values between 0x04 an 0xFF are reserved and
// will be ignored by OSPM.
//





///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProximityDomain7To0;
  UINT8     ApicId;
  UINT32    Flags;
  UINT8     LocalSapicEid;
  UINT8     ProximityDomain31To8[3];
  UINT32    ClockDomain;
} EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///


///
/// Memory Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT16    Reserved1;
  UINT32    AddressBaseLow;
  UINT32    AddressBaseHigh;
  UINT32    LengthLow;
  UINT32    LengthHigh;
  UINT32    Reserved2;
  UINT32    Flags;
  UINT64    Reserved3;
} EFI_ACPI_6_0_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//




///
/// Processor Local x2APIC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     Reserved1[2];
  UINT32    ProximityDomain;
  UINT32    X2ApicId;
  UINT32    Flags;
  UINT32    ClockDomain;
  UINT8     Reserved2[4];
} EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;

///
/// GICC Affinity Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT32    ProximityDomain;
  UINT32    AcpiProcessorUid;
  UINT32    Flags;
  UINT32    ClockDomain;
} EFI_ACPI_6_0_GICC_AFFINITY_STRUCTURE;

///
/// GICC Flags.  All other bits are reserved and must be 0.
///


///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_6_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 6.0 spec.)
///


///
/// Corrected Platform Error Polling Table (CPEP)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          Reserved[8];
} EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;

///
/// CPEP Version (as defined in ACPI 6.0 spec.)
///


//
// CPEP processor structure types.
//


///
/// Corrected Platform Error Polling Processor Structure Definition
///
typedef struct {
  UINT8     Type;
  UINT8     Length;
  UINT8     ProcessorId;
  UINT8     ProcessorEid;
  UINT32    PollingInterval;
} EFI_ACPI_6_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;

///
/// Maximum System Characteristics Table (MSCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         OffsetProxDomInfo;
  UINT32                         MaximumNumberOfProximityDomains;
  UINT32                         MaximumNumberOfClockDomains;
  UINT64                         MaximumPhysicalAddress;
} EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;

///
/// MSCT Version (as defined in ACPI 6.0 spec.)
///


///
/// Maximum Proximity Domain Information Structure Definition
///
typedef struct {
  UINT8     Revision;
  UINT8     Length;
  UINT32    ProximityDomainRangeLow;
  UINT32    ProximityDomainRangeHigh;
  UINT32    MaximumProcessorCapacity;
  UINT64    MaximumMemoryCapacity;
} EFI_ACPI_6_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;

///
/// ACPI RAS Feature Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier[12];
} EFI_ACPI_6_0_RAS_FEATURE_TABLE;

///
/// RASF Version (as defined in ACPI 6.0 spec.)
///


///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT16    Version;
  UINT8     RASCapabilities[16];
  UINT8     SetRASCapabilities[16];
  UINT16    NumberOfRASFParameterBlocks;
  UINT32    SetRASCapabilitiesStatus;
} EFI_ACPI_6_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI RASF PCC command code
///


///
/// ACPI RASF Platform RAS Capabilities
///



///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
typedef struct {
  UINT16    Type;
  UINT16    Version;
  UINT16    Length;
  UINT16    PatrolScrubCommand;
  UINT64    RequestedAddressRange[2];
  UINT64    ActualAddressRange[2];
  UINT16    Flags;
  UINT8     RequestedSpeed;
} EFI_ACPI_6_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;

///
/// ACPI RASF Patrol Scrub command
///




///
/// Memory Power State Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT8                          PlatformCommunicationChannelIdentifier;
  UINT8                          Reserved[3];
  // Memory Power Node Structure
  // Memory Power State Characteristics
} EFI_ACPI_6_0_MEMORY_POWER_STATUS_TABLE;

///
/// MPST Version (as defined in ACPI 6.0 spec.)
///


///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
  UINT32    Signature;
  UINT16    Command;
  UINT16    Status;
  UINT32    MemoryPowerCommandRegister;
  UINT32    MemoryPowerStatusRegister;
  UINT32    PowerStateId;
  UINT32    MemoryPowerNodeId;
  UINT64    MemoryEnergyConsumed;
  UINT64    ExpectedAveragePowerComsuned;
} EFI_ACPI_6_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI MPST PCC command code
///


///
/// ACPI MPST Memory Power command
///





///
/// MPST Memory Power Node Table
///
typedef struct {
  UINT8    PowerStateValue;
  UINT8    PowerStateInformationIndex;
} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE;

typedef struct {
  UINT8     Flag;
  UINT8     Reserved;
  UINT16    MemoryPowerNodeId;
  UINT32    Length;
  UINT64    AddressBase;
  UINT64    AddressLength;
  UINT32    NumberOfPowerStates;
  UINT32    NumberOfPhysicalComponents;
  // EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
  // UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
} EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerNodeCount;
  UINT8     Reserved[2];
} EFI_ACPI_6_0_MPST_MEMORY_POWER_NODE_TABLE;

///
/// MPST Memory Power State Characteristics Table
///
typedef struct {
  UINT8     PowerStateStructureID;
  UINT8     Flag;
  UINT16    Reserved;
  UINT32    AveragePowerConsumedInMPS0;
  UINT32    RelativePowerSavingToMPS0;
  UINT64    ExitLatencyToMPS0;
} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;





typedef struct {
  UINT16    MemoryPowerStateCharacteristicsCount;
  UINT8     Reserved[2];
} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;

///
/// Memory Topology Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved;
} EFI_ACPI_6_0_MEMORY_TOPOLOGY_TABLE;

///
/// PMTT Version (as defined in ACPI 6.0 spec.)
///


///
/// Common Memory Aggregator Device Structure.
///
typedef struct {
  UINT8     Type;
  UINT8     Reserved;
  UINT16    Length;
  UINT16    Flags;
  UINT16    Reserved1;
} EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Memory Aggregator Device Type
///




///
/// Socket Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         SocketIdentifier;
  UINT16                                                         Reserved;
  // EFI_ACPI_6_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
} EFI_ACPI_6_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// MemoryController Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT32                                                         ReadLatency;
  UINT32                                                         WriteLatency;
  UINT32                                                         ReadBandwidth;
  UINT32                                                         WriteBandwidth;
  UINT16                                                         OptimalAccessUnit;
  UINT16                                                         OptimalAccessAlignment;
  UINT16                                                         Reserved;
  UINT16                                                         NumberOfProximityDomains;
  // UINT32                                                       ProximityDomain[NumberOfProximityDomains];
  // EFI_ACPI_6_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
} EFI_ACPI_6_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// DIMM Memory Aggregator Device Structure.
///
typedef struct {
  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    Header;
  UINT16                                                         PhysicalComponentIdentifier;
  UINT16                                                         Reserved;
  UINT32                                                         SizeOfDimm;
  UINT32                                                         SmbiosHandle;
} EFI_ACPI_6_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;

///
/// Boot Graphics Resource Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  ///
  /// 2-bytes (16 bit) version ID. This value must be 1.
  ///
  UINT16                         Version;
  ///
  /// 1-byte status field indicating current status about the table.
  ///     Bits[7:1] = Reserved (must be zero)
  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
  ///
  UINT8                          Status;
  ///
  /// 1-byte enumerated type field indicating format of the image.
  ///     0 = Bitmap
  ///     1 - 255  Reserved (for future use)
  ///
  UINT8                          ImageType;
  ///
  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
  /// of the image bitmap.
  ///
  UINT64                         ImageAddress;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetX;
  ///
  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
  /// (X, Y) display offset of the top left corner of the boot image.
  /// The top left corner of the display is at offset (0, 0).
  ///
  UINT32                         ImageOffsetY;
} EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE;

///
/// BGRT Revision
///


///
/// BGRT Version
///


///
/// BGRT Status
///



///
/// BGRT Image Type
///


///
/// FPDT Version (as defined in ACPI 6.0 spec.)
///


///
/// FPDT Performance Record Types
///



///
/// FPDT Performance Record Revision
///



///
/// FPDT Runtime Performance Record Types
///




///
/// FPDT Runtime Performance Record Revision
///




///
/// FPDT Performance Record header
///
typedef struct {
  UINT16    Type;
  UINT8     Length;
  UINT8     Revision;
} EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;

///
/// FPDT Performance Table header
///
typedef struct {
  UINT32    Signature;
  UINT32    Length;
} EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER;

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
  ///
  UINT64                                         BootPerformanceTablePointer;
} EFI_ACPI_6_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT S3 Performance Table Pointer Record Structure
///
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// 64-bit processor-relative physical address of the S3 Performance Table.
  ///
  UINT64                                         S3PerformanceTablePointer;
} EFI_ACPI_6_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  UINT32                                         Reserved;
  ///
  /// Timer value logged at the beginning of firmware image execution.
  /// This may not always be zero or near zero.
  ///
  UINT64                                         ResetEnd;
  ///
  /// Timer value logged just prior to loading the OS boot loader into memory.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         OsLoaderLoadImageStart;
  ///
  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
  /// For non-UEFI compatible boots, the timer value logged will be just prior
  /// to the INT 19h handler invocation.
  ///
  UINT64                                         OsLoaderStartImageStart;
  ///
  /// Timer value logged at the point when the OS loader calls the
  /// ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesEntry;
  ///
  /// Timer value logged at the point just prior to when the OS loader gaining
  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
  /// For non-UEFI compatible boots, this field must be zero.
  ///
  UINT64                                         ExitBootServicesExit;
} EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD;

///
/// FPDT Firmware Basic Boot Performance Table signature
///


//
// FPDT Firmware Basic Boot Performance Table
//
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE;

///
/// FPDT "S3PT" S3 Performance Table
///


//
// FPDT Firmware S3 Boot Performance Table
//
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER    Header;
  //
  // one or more Performance Records.
  //
} EFI_ACPI_6_0_FPDT_FIRMWARE_S3_BOOT_TABLE;

///
/// FPDT Basic S3 Resume Performance Record
///
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// A count of the number of S3 resume cycles since the last full boot sequence.
  ///
  UINT32                                         ResumeCount;
  ///
  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
  /// OS waking vector. Only the most recent resume cycle's time is retained.
  ///
  UINT64                                         FullResume;
  ///
  /// Average timer value of all resume cycles logged since the last full boot
  /// sequence, including the most recent resume.  Note that the entire log of
  /// timer values does not need to be retained in order to calculate this average.
  ///
  UINT64                                         AverageResume;
} EFI_ACPI_6_0_FPDT_S3_RESUME_RECORD;

///
/// FPDT Basic S3 Suspend Performance Record
///
typedef struct {
  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER    Header;
  ///
  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendStart;
  ///
  /// Timer value recorded at the final firmware write to SLP_TYP (or other
  /// mechanism) used to trigger hardware entry to S3.
  /// Only the most recent suspend cycle's timer value is retained.
  ///
  UINT64                                         SuspendEnd;
} EFI_ACPI_6_0_FPDT_S3_SUSPEND_RECORD;

///
/// Firmware Performance Record Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_RECORD_TABLE;

///
/// Generic Timer Description Table definition.
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT64                         CntControlBasePhysicalAddress;
  UINT32                         Reserved;
  UINT32                         SecurePL1TimerGSIV;
  UINT32                         SecurePL1TimerFlags;
  UINT32                         NonSecurePL1TimerGSIV;
  UINT32                         NonSecurePL1TimerFlags;
  UINT32                         VirtualTimerGSIV;
  UINT32                         VirtualTimerFlags;
  UINT32                         NonSecurePL2TimerGSIV;
  UINT32                         NonSecurePL2TimerFlags;
  UINT64                         CntReadBasePhysicalAddress;
  UINT32                         PlatformTimerCount;
  UINT32                         PlatformTimerOffset;
} EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE;

///
/// GTDT Version (as defined in ACPI 6.0 spec.)
///


///
/// Timer Flags.  All other bits are reserved and must be 0.
///




///
/// Platform Timer Type
///



///
/// GT Block Structure
///
typedef struct {
  UINT8     Type;
  UINT16    Length;
  UINT8     Reserved;
  UINT64    CntCtlBase;
  UINT32    GTBlockTimerCount;
  UINT32    GTBlockTimerOffset;
} EFI_ACPI_6_0_GTDT_GT_BLOCK_STRUCTURE;

///
/// GT Block Timer Structure
///
typedef struct {
  UINT8     GTFrameNumber;
  UINT8     Reserved[3];
  UINT64    CntBaseX;
  UINT64    CntEL0BaseX;
  UINT32    GTxPhysicalTimerGSIV;
  UINT32    GTxPhysicalTimerFlags;
  UINT32    GTxVirtualTimerGSIV;
  UINT32    GTxVirtualTimerFlags;
  UINT32    GTxCommonFlags;
} EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_STRUCTURE;

///
/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
///



///
/// Common Flags Flags.  All other bits are reserved and must be 0.
///



///
/// SBSA Generic Watchdog Structure
///
typedef struct {
  UINT8     Type;
  UINT16    Length;
  UINT8     Reserved;
  UINT64    RefreshFramePhysicalAddress;
  UINT64    WatchdogControlFramePhysicalAddress;
  UINT32    WatchdogTimerGSIV;
  UINT32    WatchdogTimerFlags;
} EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;

///
/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
///




//
// NVDIMM Firmware Interface Table definition.
//
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Reserved;
} EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE;

//
// NFIT Version (as defined in ACPI 6.0 spec.)
//


//
// Definition for NFIT Table Structure Types
//








//
// Definition for NFIT Structure Header
//
typedef struct {
  UINT16    Type;
  UINT16    Length;
} EFI_ACPI_6_0_NFIT_STRUCTURE_HEADER;

//
// Definition for System Physical Address Range Structure
//










typedef struct {
  UINT16    Type;
  UINT16    Length;
  UINT16    SPARangeStructureIndex;
  UINT16    Flags;
  UINT32    Reserved_8;
  UINT32    ProximityDomain;
  GUID      AddressRangeTypeGUID;
  UINT64    SystemPhysicalAddressRangeBase;
  UINT64    SystemPhysicalAddressRangeLength;
  UINT64    AddressRangeMemoryMappingAttribute;
} EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;

//
// Definition for Memory Device to System Physical Address Range Mapping Structure
//
typedef struct {
  UINT32    DIMMNumber          : 4;
  UINT32    MemoryChannelNumber : 4;
  UINT32    MemoryControllerID  : 4;
  UINT32    SocketID            : 4;
  UINT32    NodeControllerID    : 12;
  UINT32    Reserved_28         : 4;
} EFI_ACPI_6_0_NFIT_DEVICE_HANDLE;







typedef struct {
  UINT16                             Type;
  UINT16                             Length;
  EFI_ACPI_6_0_NFIT_DEVICE_HANDLE    NFITDeviceHandle;
  UINT16                             MemoryDevicePhysicalID;
  UINT16                             MemoryDeviceRegionID;
  UINT16                             SPARangeStructureIndex;
  UINT16                             NVDIMMControlRegionStructureIndex;
  UINT64                             MemoryDeviceRegionSize;
  UINT64                             RegionOffset;
  UINT64                             MemoryDevicePhysicalAddressRegionBase;
  UINT16                             InterleaveStructureIndex;
  UINT16                             InterleaveWays;
  UINT16                             MemoryDeviceStateFlags;
  UINT16                             Reserved_46;
} EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_TO_SYSTEM_ADDRESS_RANGE_MAP_STRUCTURE;

//
// Definition for Interleave Structure
//
typedef struct {
  UINT16    Type;
  UINT16    Length;
  UINT16    InterleaveStructureIndex;
  UINT16    Reserved_6;
  UINT32    NumberOfLines;
  UINT32    LineSize;
  // UINT32                                      LineOffset[NumberOfLines];
} EFI_ACPI_6_0_NFIT_INTERLEAVE_STRUCTURE;

//
// Definition for SMBIOS Management Information Structure
//
typedef struct {
  UINT16    Type;
  UINT16    Length;
  UINT32    Reserved_4;
  // UINT8                                       Data[];
} EFI_ACPI_6_0_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;

//
// Definition for NVDIMM Control Region Structure
//

typedef struct {
  UINT16    Type;
  UINT16    Length;
  UINT16    NVDIMMControlRegionStructureIndex;
  UINT16    VendorID;
  UINT16    DeviceID;
  UINT16    RevisionID;
  UINT16    SubsystemVendorID;
  UINT16    SubsystemDeviceID;
  UINT16    SubsystemRevisionID;
  UINT8     Reserved_18[6];
  UINT32    SerialNumber;
  UINT16    RegionFormatInterfaceCode;
  UINT16    NumberOfBlockControlWindows;
  UINT64    SizeOfBlockControlWindow;
  UINT64    CommandRegisterOffsetInBlockControlWindow;
  UINT64    SizeOfCommandRegisterInBlockControlWindows;
  UINT64    StatusRegisterOffsetInBlockControlWindow;
  UINT64    SizeOfStatusRegisterInBlockControlWindows;
  UINT16    NVDIMMControlRegionFlag;
  UINT8     Reserved_74[6];
} EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;

//
// Definition for NVDIMM Block Data Window Region Structure
//
typedef struct {
  UINT16    Type;
  UINT16    Length;
  UINT16    NVDIMMControlRegionStructureIndex;
  UINT16    NumberOfBlockDataWindows;
  UINT64    BlockDataWindowStartOffset;
  UINT64    SizeOfBlockDataWindow;
  UINT64    BlockAccessibleMemoryCapacity;
  UINT64    BeginningAddressOfFirstBlockInBlockAccessibleMemory;
} EFI_ACPI_6_0_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;

//
// Definition for Flush Hint Address Structure
//
typedef struct {
  UINT16                             Type;
  UINT16                             Length;
  EFI_ACPI_6_0_NFIT_DEVICE_HANDLE    NFITDeviceHandle;
  UINT16                             NumberOfFlushHintAddresses;
  UINT8                              Reserved_10[6];
  // UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
} EFI_ACPI_6_0_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;

///
/// Boot Error Record Table (BERT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         BootErrorRegionLength;
  UINT64                         BootErrorRegion;
} EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER;

///
/// BERT Version (as defined in ACPI 6.0 spec.)
///


///
/// Boot Error Region Block Status Definition
///
typedef struct {
  UINT32    UncorrectableErrorValid     : 1;
  UINT32    CorrectableErrorValid       : 1;
  UINT32    MultipleUncorrectableErrors : 1;
  UINT32    MultipleCorrectableErrors   : 1;
  UINT32    ErrorDataEntryCount         : 10;
  UINT32    Reserved                    : 18;
} EFI_ACPI_6_0_ERROR_BLOCK_STATUS;

///
/// Boot Error Region Definition
///
typedef struct {
  EFI_ACPI_6_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_6_0_BOOT_ERROR_REGION_STRUCTURE;

//
// Boot Error Severity types
//




//
// The term 'Correctable' is no longer being used as an error severity of the
// reported error since ACPI Specification Version 5.1 Errata B.
// The below macro is considered as deprecated and should no longer be used.
//


///
/// Generic Error Data Entry Definition
///
typedef struct {
  UINT8     SectionType[16];
  UINT32    ErrorSeverity;
  UINT16    Revision;
  UINT8     ValidationBits;
  UINT8     Flags;
  UINT32    ErrorDataLength;
  UINT8     FruId[16];
  UINT8     FruText[20];
} EFI_ACPI_6_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;

///
/// Generic Error Data Entry Version (as defined in ACPI 6.0 spec.)
///


///
/// HEST - Hardware Error Source Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         ErrorSourceCount;
} EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;

///
/// HEST Version (as defined in ACPI 6.0 spec.)
///


//
// Error Source structure types.
//








//
// Error Source structure flags.
//



///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT64    GlobalCapabilityInitData;
  UINT64    GlobalControlInitData;
  UINT8     NumberOfHardwareBanks;
  UINT8     Reserved1[7];
} EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
typedef struct {
  UINT8     BankNumber;
  UINT8     ClearStatusOnInitialization;
  UINT8     StatusDataFormat;
  UINT8     Reserved0;
  UINT32    ControlRegisterMsrAddress;
  UINT64    ControlInitData;
  UINT32    StatusRegisterMsrAddress;
  UINT32    AddressRegisterMsrAddress;
  UINT32    MiscRegisterMsrAddress;
} EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure MCA data format
///




//
// Hardware Error Notification types. All other values are reserved
//









///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
typedef struct {
  UINT16    Type                           : 1;
  UINT16    PollInterval                   : 1;
  UINT16    SwitchToPollingThresholdValue  : 1;
  UINT16    SwitchToPollingThresholdWindow : 1;
  UINT16    ErrorThresholdValue            : 1;
  UINT16    ErrorThresholdWindow           : 1;
  UINT16    Reserved                       : 10;
} EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;

///
/// Hardware Error Notification Structure Definition
///
typedef struct {
  UINT8                                                                            Type;
  UINT8                                                                            Length;
  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE    ConfigurationWriteEnable;
  UINT32                                                                           PollInterval;
  UINT32                                                                           Vector;
  UINT32                                                                           SwitchToPollingThresholdValue;
  UINT32                                                                           SwitchToPollingThresholdWindow;
  UINT32                                                                           ErrorThresholdValue;
  UINT32                                                                           ErrorThresholdWindow;
} EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT8                                                 Reserved0[2];
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT8                                                 NumberOfHardwareBanks;
  UINT8                                                 Reserved1[3];
} EFI_ACPI_6_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;

///
/// IA-32 Architecture NMI Error Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    MaxRawDataLength;
} EFI_ACPI_6_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;

///
/// PCI Express Root Port AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    RootErrorCommand;
} EFI_ACPI_6_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;

///
/// PCI Express Device AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_6_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;

///
/// PCI Express Bridge AER Structure Definition
///
typedef struct {
  UINT16    Type;
  UINT16    SourceId;
  UINT8     Reserved0[2];
  UINT8     Flags;
  UINT8     Enabled;
  UINT32    NumberOfRecordsToPreAllocate;
  UINT32    MaxSectionsPerRecord;
  UINT32    Bus;
  UINT16    Device;
  UINT16    Function;
  UINT16    DeviceControl;
  UINT8     Reserved1[2];
  UINT32    UncorrectableErrorMask;
  UINT32    UncorrectableErrorSeverity;
  UINT32    CorrectableErrorMask;
  UINT32    AdvancedErrorCapabilitiesAndControl;
  UINT32    SecondaryUncorrectableErrorMask;
  UINT32    SecondaryUncorrectableErrorSeverity;
  UINT32    SecondaryAdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_6_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;

///
/// Generic Hardware Error Source Structure Definition
///
typedef struct {
  UINT16                                                Type;
  UINT16                                                SourceId;
  UINT16                                                RelatedSourceId;
  UINT8                                                 Flags;
  UINT8                                                 Enabled;
  UINT32                                                NumberOfRecordsToPreAllocate;
  UINT32                                                MaxSectionsPerRecord;
  UINT32                                                MaxRawDataLength;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
  UINT32                                                ErrorStatusBlockLength;
} EFI_ACPI_6_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;

///
/// Generic Error Status Definition
///
typedef struct {
  EFI_ACPI_6_0_ERROR_BLOCK_STATUS    BlockStatus;
  UINT32                             RawDataOffset;
  UINT32                             RawDataLength;
  UINT32                             DataLength;
  UINT32                             ErrorSeverity;
} EFI_ACPI_6_0_GENERIC_ERROR_STATUS_STRUCTURE;

///
/// ERST - Error Record Serialization Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         SerializationHeaderSize;
  UINT8                          Reserved0[4];
  UINT32                         InstructionEntryCount;
} EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;

///
/// ERST Version (as defined in ACPI 6.0 spec.)
///


///
/// ERST Serialization Actions
///
















///
/// ERST Action Command Status
///







///
/// ERST Serialization Instructions
///




















///
/// ERST Instruction Flags
///


///
/// ERST Serialization Instruction Entry
///
typedef struct {
  UINT8                                     SerializationAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_6_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;

///
/// EINJ - Error Injection Table
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         InjectionHeaderSize;
  UINT8                          InjectionFlags;
  UINT8                          Reserved0[3];
  UINT32                         InjectionEntryCount;
} EFI_ACPI_6_0_ERROR_INJECTION_TABLE_HEADER;

///
/// EINJ Version (as defined in ACPI 6.0 spec.)
///


///
/// EINJ Error Injection Actions
///











///
/// EINJ Action Command Status
///




///
/// EINJ Error Type Definition
///













///
/// EINJ Injection Instructions
///






///
/// EINJ Instruction Flags
///


///
/// EINJ Injection Instruction Entry
///
typedef struct {
  UINT8                                     InjectionAction;
  UINT8                                     Instruction;
  UINT8                                     Flags;
  UINT8                                     Reserved0;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
  UINT64                                    Value;
  UINT64                                    Mask;
} EFI_ACPI_6_0_EINJ_INJECTION_INSTRUCTION_ENTRY;

///
/// EINJ Trigger Action Table
///
typedef struct {
  UINT32    HeaderSize;
  UINT32    Revision;
  UINT32    TableSize;
  UINT32    EntryCount;
} EFI_ACPI_6_0_EINJ_TRIGGER_ACTION_TABLE;

///
/// Platform Communications Channel Table (PCCT)
///
typedef struct {
  EFI_ACPI_DESCRIPTION_HEADER    Header;
  UINT32                         Flags;
  UINT64                         Reserved;
} EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;

///
/// PCCT Version (as defined in ACPI 6.0 spec.)
///


///
/// PCCT Global Flags
///


//
// PCCT Subspace type
//




///
/// PCC Subspace Structure Header
///
typedef struct {
  UINT8    Type;
  UINT8    Length;
} EFI_ACPI_6_0_PCCT_SUBSPACE_HEADER;

///
/// Generic Communications Subspace Structure
///
typedef struct {
  UINT8                                     Type;
  UINT8                                     Length;
  UINT8                                     Reserved[6];
  UINT64                                    BaseAddress;
  UINT64                                    AddressLength;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
  UINT64                                    DoorbellPreserve;
  UINT64                                    DoorbellWrite;
  UINT32                                    NominalLatency;
  UINT32                                    MaximumPeriodicAccessRate;
  UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_6_0_PCCT_SUBSPACE_GENERIC;

///
/// Generic Communications Channel Shared Memory Region
///

typedef struct {
  UINT8    Command;
  UINT8    Reserved    : 7;
  UINT8    GenerateSci : 1;
} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;

typedef struct {
  UINT8    CommandComplete      : 1;
  UINT8    SciDoorbell          : 1;
  UINT8    Error                : 1;
  UINT8    PlatformNotification : 1;
  UINT8    Reserved             : 4;
  UINT8    Reserved1;
} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;

typedef struct {
  UINT32                                                    Signature;
  EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
  EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;




///
/// Type 1 HW-Reduced Communications Subspace Structure
///
typedef struct {
  UINT8                                     Type;
  UINT8                                     Length;
  UINT32                                    DoorbellInterrupt;
  UINT8                                     DoorbellInterruptFlags;
  UINT8                                     Reserved;
  UINT64                                    BaseAddress;
  UINT64                                    AddressLength;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
  UINT64                                    DoorbellPreserve;
  UINT64                                    DoorbellWrite;
  UINT32                                    NominalLatency;
  UINT32                                    MaximumPeriodicAccessRate;
  UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_6_0_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;

///
/// Type 2 HW-Reduced Communications Subspace Structure
///
typedef struct {
  UINT8                                     Type;
  UINT8                                     Length;
  UINT32                                    DoorbellInterrupt;
  UINT8                                     DoorbellInterruptFlags;
  UINT8                                     Reserved;
  UINT64                                    BaseAddress;
  UINT64                                    AddressLength;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
  UINT64                                    DoorbellPreserve;
  UINT64                                    DoorbellWrite;
  UINT32                                    NominalLatency;
  UINT32                                    MaximumPeriodicAccessRate;
  UINT16                                    MinimumRequestTurnaroundTime;
  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE    DoorbellAckRegister;
  UINT64                                    DoorbellAckPreserve;
  UINT64                                    DoorbellAckWrite;
} EFI_ACPI_6_0_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///


///
/// "APIC" Multiple APIC Description Table
///


///
/// "BERT" Boot Error Record Table
///


///
/// "BGRT" Boot Graphics Resource Table
///


///
/// "CPEP" Corrected Platform Error Polling Table
///


///
/// "DSDT" Differentiated System Description Table
///


///
/// "ECDT" Embedded Controller Boot Resources Table
///


///
/// "EINJ" Error Injection Table
///


///
/// "ERST" Error Record Serialization Table
///


///
/// "FACP" Fixed ACPI Description Table
///


///
/// "FACS" Firmware ACPI Control Structure
///


///
/// "FPDT" Firmware Performance Data Table
///


///
/// "GTDT" Generic Timer Description Table
///


///
/// "HEST" Hardware Error Source Table
///


///
/// "MPST" Memory Power State Table
///


///
/// "MSCT" Maximum System Characteristics Table
///


///
/// "NFIT" NVDIMM Firmware Interface Table
///


///
/// "PMTT" Platform Memory Topology Table
///


///
/// "PSDT" Persistent System Description Table
///


///
/// "RASF" ACPI RAS Feature Table
///


///
/// "RSDT" Root System Description Table
///


///
/// "SBST" Smart Battery Specification Table
///


///
/// "SLIT" System Locality Information Table
///


///
/// "SRAT" System Resource Affinity Table
///


///
/// "SSDT" Secondary System Description Table
///


///
/// "XSDT" Extended System Description Table
///


///
/// "BOOT" MS Simple Boot Spec
///


///
/// "CSRT" MS Core System Resource Table
///


///
/// "DBG2" MS Debug Port 2 Spec
///


///
/// "DBGP" MS Debug Port Spec
///


///
/// "DMAR" DMA Remapping Table
///


///
/// "DRTM" Dynamic Root of Trust for Measurement Table
///


///
/// "ETDT" Event Timer Description Table
///


///
/// "HPET" IA-PC High Precision Event Timer Table
///


///
/// "iBFT" iSCSI Boot Firmware Table
///


///
/// "IORT" I/O Remapping Table
///


///
/// "IVRS" I/O Virtualization Reporting Structure
///


///
/// "LPIT" Low Power Idle Table
///


///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///


///
/// "MCHI" Management Controller Host Interface Table
///


///
/// "MSDM" MS Data Management Table
///


///
/// "PCCT" Platform Communications Channel Table
///


///
/// "SLIC" MS Software Licensing Table Specification
///


///
/// "SPCR" Serial Port Console Redirection Table
///


///
/// "SPMI" Server Platform Management Interface Table
///


///
/// "STAO" _STA Override Table
///


///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///


///
/// "TPM2" Trusted Computing Platform 1 Table
///


///
/// "UEFI" UEFI ACPI Data Table
///


///
/// "WAET" Windows ACPI Emulated Devices Table
///


///
/// "WDAT" Watchdog Action Table
///


///
/// "WDRT" Watchdog Resource Table
///


///
/// "WPBT" MS Platform Binary Table
///


///
/// "XENV" Xen Project Table
///


#pragma pack()

#line 2410 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/Acpi60.h"
#line 19 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DevicePath.h"

///
/// Device Path protocol.
///





///
/// Device Path guid definition for backward-compatible with EFI1.1.
///


#pragma pack(1)

/**
  This protocol can be used on any device handle to obtain generic path/location
  information concerning the physical device or logical device. If the handle does
  not logically map to a physical device, the handle may not necessarily support
  the device path protocol. The device path describes the location of the device
  the handle is for. The size of the Device Path can be determined from the structures
  that make up the Device Path.
**/
typedef struct {
  UINT8    Type;    ///< 0x01 Hardware Device Path.
                    ///< 0x02 ACPI Device Path.
                    ///< 0x03 Messaging Device Path.
                    ///< 0x04 Media Device Path.
                    ///< 0x05 BIOS Boot Specification Device Path.
                    ///< 0x7F End of Hardware Device Path.

  UINT8    SubType; ///< Varies by Type
                    ///< 0xFF End Entire Device Path, or
                    ///< 0x01 End This Instance of a Device Path and start a new
                    ///< Device Path.

  UINT8    Length[2]; ///< Specific Device Path data. Type and Sub-Type define
                      ///< type of data. Size of data is included in Length.
} EFI_DEVICE_PATH_PROTOCOL;

///
/// Device Path protocol definition for backward-compatible with EFI1.1.
///
typedef EFI_DEVICE_PATH_PROTOCOL EFI_DEVICE_PATH;

///
/// Hardware Device Paths.
///


///
/// PCI Device Path SubType.
///


///
/// PCI Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// PCI Function Number.
  ///
  UINT8                       Function;
  ///
  /// PCI Device Number.
  ///
  UINT8                       Device;
} PCI_DEVICE_PATH;

///
/// PCCARD Device Path SubType.
///


///
/// PCCARD Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Function Number (0 = First Function).
  ///
  UINT8                       FunctionNumber;
} PCCARD_DEVICE_PATH;

///
/// Memory Mapped Device Path SubType.
///


///
/// Memory Mapped Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// EFI_MEMORY_TYPE
  ///
  UINT32                      MemoryType;
  ///
  /// Starting Memory Address.
  ///
  EFI_PHYSICAL_ADDRESS        StartingAddress;
  ///
  /// Ending Memory Address.
  ///
  EFI_PHYSICAL_ADDRESS        EndingAddress;
} MEMMAP_DEVICE_PATH;

///
/// Hardware Vendor Device Path SubType.
///


///
/// The Vendor Device Path allows the creation of vendor-defined Device Paths. A vendor must
/// allocate a Vendor GUID for a Device Path. The Vendor GUID can then be used to define the
/// contents on the n bytes that follow in the Vendor Device Path node.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Vendor-assigned GUID that defines the data that follows.
  ///
  EFI_GUID                    Guid;
  ///
  /// Vendor-defined variable size data.
  ///
} VENDOR_DEVICE_PATH;

///
/// Controller Device Path SubType.
///


///
/// Controller Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Controller number.
  ///
  UINT32                      ControllerNumber;
} CONTROLLER_DEVICE_PATH;

///
/// BMC Device Path SubType.
///


///
/// BMC Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Interface Type.
  ///
  UINT8                       InterfaceType;
  ///
  /// Base Address.
  ///
  UINT8                       BaseAddress[8];
} BMC_DEVICE_PATH;

///
/// ACPI Device Paths.
///


///
/// ACPI Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Device's PnP hardware ID stored in a numeric 32-bit
  /// compressed EISA-type ID. This value must match the
  /// corresponding _HID in the ACPI name space.
  ///
  UINT32                      HID;
  ///
  /// Unique ID that is required by ACPI if two devices have the
  /// same _HID. This value must also match the corresponding
  /// _UID/_HID pair in the ACPI name space. Only the 32-bit
  /// numeric value type of _UID is supported. Thus, strings must
  /// not be used for the _UID in the ACPI name space.
  ///
  UINT32                      UID;
} ACPI_HID_DEVICE_PATH;

///
/// Expanded ACPI Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Device's PnP hardware ID stored in a numeric 32-bit
  /// compressed EISA-type ID. This value must match the
  /// corresponding _HID in the ACPI name space.
  ///
  UINT32                      HID;
  ///
  /// Unique ID that is required by ACPI if two devices have the
  /// same _HID. This value must also match the corresponding
  /// _UID/_HID pair in the ACPI name space.
  ///
  UINT32                      UID;
  ///
  /// Device's compatible PnP hardware ID stored in a numeric
  /// 32-bit compressed EISA-type ID. This value must match at
  /// least one of the compatible device IDs returned by the
  /// corresponding _CID in the ACPI name space.
  ///
  UINT32                      CID;
  ///
  /// Optional variable length _HIDSTR.
  /// Optional variable length _UIDSTR.
  /// Optional variable length _CIDSTR.
  ///
} ACPI_EXTENDED_HID_DEVICE_PATH;

//
//  EISA ID Macro
//  EISA ID Definition 32-bits
//   bits[15:0] - three character compressed ASCII EISA ID.
//   bits[31:16] - binary number
//    Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
//








///
/// ACPI _ADR Device Path SubType.
///


///
/// The _ADR device path is used to contain video output device attributes to support the Graphics
/// Output Protocol. The device path can contain multiple _ADR entries if multiple video output
/// devices are displaying the same output.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// _ADR value. For video output devices the value of this
  /// field comes from Table B-2 of the ACPI 3.0 specification. At
  /// least one _ADR value is required.
  ///
  UINT32                      ADR;
  //
  // This device path may optionally contain more than one _ADR entry.
  //
} ACPI_ADR_DEVICE_PATH;

///
/// ACPI NVDIMM Device Path SubType.
///

///
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// NFIT Device Handle, the _ADR of the NVDIMM device.
  /// The value of this field comes from Section 9.20.3 of the ACPI 6.2A specification.
  ///
  UINT32                      NFITDeviceHandle;
} ACPI_NVDIMM_DEVICE_PATH;

















///
/// Messaging Device Paths.
/// This Device Path is used to describe the connection of devices outside the resource domain of the
/// system. This Device Path can describe physical messaging information like SCSI ID, or abstract
/// information like networking protocol IP addresses.
///


///
/// ATAPI Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Set to zero for primary, or one for secondary.
  ///
  UINT8                       PrimarySecondary;
  ///
  /// Set to zero for master, or one for slave mode.
  ///
  UINT8                       SlaveMaster;
  ///
  /// Logical Unit Number.
  ///
  UINT16                      Lun;
} ATAPI_DEVICE_PATH;

///
/// SCSI Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Target ID on the SCSI bus (PUN).
  ///
  UINT16                      Pun;
  ///
  /// Logical Unit Number (LUN).
  ///
  UINT16                      Lun;
} SCSI_DEVICE_PATH;

///
/// Fibre Channel SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Reserved for the future.
  ///
  UINT32                      Reserved;
  ///
  /// Fibre Channel World Wide Number.
  ///
  UINT64                      WWN;
  ///
  /// Fibre Channel Logical Unit Number.
  ///
  UINT64                      Lun;
} FIBRECHANNEL_DEVICE_PATH;

///
/// Fibre Channel Ex SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Reserved for the future.
  ///
  UINT32                      Reserved;
  ///
  /// 8 byte array containing Fibre Channel End Device Port Name.
  ///
  UINT8                       WWN[8];
  ///
  /// 8 byte array containing Fibre Channel Logical Unit Number.
  ///
  UINT8                       Lun[8];
} FIBRECHANNELEX_DEVICE_PATH;

///
/// 1394 Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Reserved for the future.
  ///
  UINT32                      Reserved;
  ///
  /// 1394 Global Unique ID (GUID).
  ///
  UINT64                      Guid;
} F1394_DEVICE_PATH;

///
/// USB Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// USB Parent Port Number.
  ///
  UINT8                       ParentPortNumber;
  ///
  /// USB Interface Number.
  ///
  UINT8                       InterfaceNumber;
} USB_DEVICE_PATH;

///
/// USB Class Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Vendor ID assigned by USB-IF. A value of 0xFFFF will
  /// match any Vendor ID.
  ///
  UINT16                      VendorId;
  ///
  /// Product ID assigned by USB-IF. A value of 0xFFFF will
  /// match any Product ID.
  ///
  UINT16                      ProductId;
  ///
  /// The class code assigned by the USB-IF. A value of 0xFF
  /// will match any class code.
  ///
  UINT8                       DeviceClass;
  ///
  /// The subclass code assigned by the USB-IF. A value of
  /// 0xFF will match any subclass code.
  ///
  UINT8                       DeviceSubClass;
  ///
  /// The protocol code assigned by the USB-IF. A value of
  /// 0xFF will match any protocol code.
  ///
  UINT8                       DeviceProtocol;
} USB_CLASS_DEVICE_PATH;

///
/// USB WWID Device Path SubType.
///


///
/// This device path describes a USB device using its serial number.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// USB interface number.
  ///
  UINT16                      InterfaceNumber;
  ///
  /// USB vendor id of the device.
  ///
  UINT16                      VendorId;
  ///
  /// USB product id of the device.
  ///
  UINT16                      ProductId;
  ///
  /// Last 64-or-fewer UTF-16 characters of the USB
  /// serial number. The length of the string is
  /// determined by the Length field less the offset of the
  /// Serial Number field (10)
  ///
  /// CHAR16                     SerialNumber[...];
} USB_WWID_DEVICE_PATH;

///
/// Device Logical Unit SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Logical Unit Number for the interface.
  ///
  UINT8                       Lun;
} DEVICE_LOGICAL_UNIT_DEVICE_PATH;

///
/// SATA Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// The HBA port number that facilitates the connection to the
  /// device or a port multiplier. The value 0xFFFF is reserved.
  ///
  UINT16                      HBAPortNumber;
  ///
  /// The Port multiplier port number that facilitates the connection
  /// to the device. Must be set to 0xFFFF if the device is directly
  /// connected to the HBA.
  ///
  UINT16                      PortMultiplierPortNumber;
  ///
  /// Logical Unit Number.
  ///
  UINT16                      Lun;
} SATA_DEVICE_PATH;

///
/// Flag for if the device is directly connected to the HBA.
///


///
/// I2O Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Target ID (TID) for a device.
  ///
  UINT32                      Tid;
} I2O_DEVICE_PATH;

///
/// MAC Address Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// The MAC address for a network interface padded with 0s.
  ///
  EFI_MAC_ADDRESS             MacAddress;
  ///
  /// Network interface type(i.e. 802.3, FDDI).
  ///
  UINT8                       IfType;
} MAC_ADDR_DEVICE_PATH;

///
/// IPv4 Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// The local IPv4 address.
  ///
  EFI_IPv4_ADDRESS            LocalIpAddress;
  ///
  /// The remote IPv4 address.
  ///
  EFI_IPv4_ADDRESS            RemoteIpAddress;
  ///
  /// The local port number.
  ///
  UINT16                      LocalPort;
  ///
  /// The remote port number.
  ///
  UINT16                      RemotePort;
  ///
  /// The network protocol(i.e. UDP, TCP).
  ///
  UINT16                      Protocol;
  ///
  /// 0x00 - The Source IP Address was assigned though DHCP.
  /// 0x01 - The Source IP Address is statically bound.
  ///
  BOOLEAN                     StaticIpAddress;
  ///
  /// The gateway IP address
  ///
  EFI_IPv4_ADDRESS            GatewayIpAddress;
  ///
  /// The subnet mask
  ///
  EFI_IPv4_ADDRESS            SubnetMask;
} IPv4_DEVICE_PATH;

///
/// IPv6 Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// The local IPv6 address.
  ///
  EFI_IPv6_ADDRESS            LocalIpAddress;
  ///
  /// The remote IPv6 address.
  ///
  EFI_IPv6_ADDRESS            RemoteIpAddress;
  ///
  /// The local port number.
  ///
  UINT16                      LocalPort;
  ///
  /// The remote port number.
  ///
  UINT16                      RemotePort;
  ///
  /// The network protocol(i.e. UDP, TCP).
  ///
  UINT16                      Protocol;
  ///
  /// 0x00 - The Local IP Address was manually configured.
  /// 0x01 - The Local IP Address is assigned through IPv6
  /// stateless auto-configuration.
  /// 0x02 - The Local IP Address is assigned through IPv6
  /// stateful configuration.
  ///
  UINT8                       IpAddressOrigin;
  ///
  /// The prefix length
  ///
  UINT8                       PrefixLength;
  ///
  /// The gateway IP address
  ///
  EFI_IPv6_ADDRESS            GatewayIpAddress;
} IPv6_DEVICE_PATH;

///
/// InfiniBand Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Flags to help identify/manage InfiniBand device path elements:
  /// Bit 0 - IOC/Service (0b = IOC, 1b = Service).
  /// Bit 1 - Extend Boot Environment.
  /// Bit 2 - Console Protocol.
  /// Bit 3 - Storage Protocol.
  /// Bit 4 - Network Protocol.
  /// All other bits are reserved.
  ///
  UINT32    ResourceFlags;
  ///
  /// 128-bit Global Identifier for remote fabric port.
  ///
  UINT8     PortGid[16];
  ///
  /// 64-bit unique identifier to remote IOC or server process.
  /// Interpretation of field specified by Resource Flags (bit 0).
  ///
  UINT64    ServiceId;
  ///
  /// 64-bit persistent ID of remote IOC port.
  ///
  UINT64    TargetPortId;
  ///
  /// 64-bit persistent ID of remote device.
  ///
  UINT64    DeviceId;
} INFINIBAND_DEVICE_PATH;







///
/// UART Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Reserved.
  ///
  UINT32                      Reserved;
  ///
  /// The baud rate setting for the UART style device. A value of 0
  /// means that the device's default baud rate will be used.
  ///
  UINT64                      BaudRate;
  ///
  /// The number of data bits for the UART style device. A value
  /// of 0 means that the device's default number of data bits will be used.
  ///
  UINT8                       DataBits;
  ///
  /// The parity setting for the UART style device.
  /// Parity 0x00 - Default Parity.
  /// Parity 0x01 - No Parity.
  /// Parity 0x02 - Even Parity.
  /// Parity 0x03 - Odd Parity.
  /// Parity 0x04 - Mark Parity.
  /// Parity 0x05 - Space Parity.
  ///
  UINT8    Parity;
  ///
  /// The number of stop bits for the UART style device.
  /// Stop Bits 0x00 - Default Stop Bits.
  /// Stop Bits 0x01 - 1 Stop Bit.
  /// Stop Bits 0x02 - 1.5 Stop Bits.
  /// Stop Bits 0x03 - 2 Stop Bits.
  ///
  UINT8    StopBits;
} UART_DEVICE_PATH;

///
/// NVDIMM Namespace Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Namespace unique label identifier UUID.
  ///
  EFI_GUID                    Uuid;
} NVDIMM_NAMESPACE_DEVICE_PATH;

//
// Use VENDOR_DEVICE_PATH struct
//

typedef VENDOR_DEVICE_PATH VENDOR_DEFINED_DEVICE_PATH;






///
/// A new device path node is defined to declare flow control characteristics.
/// UART Flow Control Messaging Device Path
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL GUID.
  ///
  EFI_GUID                    Guid;
  ///
  /// Bitmap of supported flow control types.
  /// Bit 0 set indicates hardware flow control.
  /// Bit 1 set indicates Xon/Xoff flow control.
  /// All other bits are reserved and are clear.
  ///
  UINT32                      FlowControlMap;
} UART_FLOW_CONTROL_DEVICE_PATH;





///
/// Serial Attached SCSI (SAS) Device Path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// DEVICE_PATH_MESSAGING_SAS GUID.
  ///
  EFI_GUID                    Guid;
  ///
  /// Reserved for future use.
  ///
  UINT32                      Reserved;
  ///
  /// SAS Address for Serial Attached SCSI Target.
  ///
  UINT64                      SasAddress;
  ///
  /// SAS Logical Unit Number.
  ///
  UINT64                      Lun;
  ///
  /// More Information about the device and its interconnect.
  ///
  UINT16                      DeviceTopology;
  ///
  /// Relative Target Port (RTP).
  ///
  UINT16                      RelativeTargetPort;
} SAS_DEVICE_PATH;

///
/// Serial Attached SCSI (SAS) Ex Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// 8-byte array of the SAS Address for Serial Attached SCSI Target Port.
  ///
  UINT8                       SasAddress[8];
  ///
  /// 8-byte array of the SAS Logical Unit Number.
  ///
  UINT8                       Lun[8];
  ///
  /// More Information about the device and its interconnect.
  ///
  UINT16                      DeviceTopology;
  ///
  /// Relative Target Port (RTP).
  ///
  UINT16                      RelativeTargetPort;
} SASEX_DEVICE_PATH;

///
/// NvmExpress Namespace Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  UINT32                      NamespaceId;
  UINT64                      NamespaceUuid;
} NVME_NAMESPACE_DEVICE_PATH;

///
/// NVMe over Fabric (NVMe-oF) Namespace Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Namespace Identifier Type (NIDT)
  ///
  UINT8                       NamespaceIdType;
  ///
  /// Namespace Identifier (NID)
  ///
  UINT8                       NamespaceId[16];
  ///
  /// Unique identifier of an NVM subsystem
  ///
  CHAR8                       SubsystemNqn[];
} NVME_OF_NAMESPACE_DEVICE_PATH;

///
/// DNS Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Indicates the DNS server address is IPv4 or IPv6 address.
  ///
  UINT8                       IsIPv6;
  ///
  /// Instance of the DNS server address.
  ///
  EFI_IP_ADDRESS              DnsServerIp[];
} DNS_DEVICE_PATH;

///
/// Uniform Resource Identifiers (URI) Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Instance of the URI pursuant to RFC 3986.
  ///
  CHAR8                       Uri[];
} URI_DEVICE_PATH;

///
/// Universal Flash Storage (UFS) Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Target ID on the UFS bus (PUN).
  ///
  UINT8                       Pun;
  ///
  /// Logical Unit Number (LUN).
  ///
  UINT8                       Lun;
} UFS_DEVICE_PATH;

///
/// SD (Secure Digital) Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  UINT8                       SlotNumber;
} SD_DEVICE_PATH;

///
/// EMMC (Embedded MMC) Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  UINT8                       SlotNumber;
} EMMC_DEVICE_PATH;

///
/// iSCSI Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Network Protocol (0 = TCP, 1+ = reserved).
  ///
  UINT16                      NetworkProtocol;
  ///
  /// iSCSI Login Options.
  ///
  UINT16                      LoginOption;
  ///
  /// iSCSI Logical Unit Number.
  ///
  UINT64                      Lun;
  ///
  /// iSCSI Target Portal group tag the initiator intends
  /// to establish a session with.
  ///
  UINT16                      TargetPortalGroupTag;
  ///
  /// iSCSI NodeTarget Name. The length of the name
  /// is determined by subtracting the offset of this field from Length.
  ///
  /// CHAR8                        iSCSI Target Name.
} ISCSI_DEVICE_PATH;










///
/// VLAN Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// VLAN identifier (0-4094).
  ///
  UINT16                      VlanId;
} VLAN_DEVICE_PATH;

///
/// Bluetooth Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// 48bit Bluetooth device address.
  ///
  BLUETOOTH_ADDRESS           BD_ADDR;
} BLUETOOTH_DEVICE_PATH;

///
/// Wi-Fi Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Service set identifier. A 32-byte octets string.
  ///
  UINT8                       SSId[32];
} WIFI_DEVICE_PATH;

///
/// Bluetooth LE Device Path SubType.
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  BLUETOOTH_LE_ADDRESS        Address;
} BLUETOOTH_LE_DEVICE_PATH;

//
// Media Device Path
//


///
/// Hard Drive Media Device Path SubType.
///


///
/// The Hard Drive Media Device Path is used to represent a partition on a hard drive.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Describes the entry in a partition table, starting with entry 1.
  /// Partition number zero represents the entire device. Valid
  /// partition numbers for a MBR partition are [1, 4]. Valid
  /// partition numbers for a GPT partition are [1, NumberOfPartitionEntries].
  ///
  UINT32                      PartitionNumber;
  ///
  /// Starting LBA of the partition on the hard drive.
  ///
  UINT64                      PartitionStart;
  ///
  /// Size of the partition in units of Logical Blocks.
  ///
  UINT64                      PartitionSize;
  ///
  /// Signature unique to this partition:
  /// If SignatureType is 0, this field has to be initialized with 16 zeros.
  /// If SignatureType is 1, the MBR signature is stored in the first 4 bytes of this field.
  /// The other 12 bytes are initialized with zeros.
  /// If SignatureType is 2, this field contains a 16 byte signature.
  ///
  UINT8                       Signature[16];
  ///
  /// Partition Format: (Unused values reserved).
  /// 0x01 - PC-AT compatible legacy MBR.
  /// 0x02 - GUID Partition Table.
  ///
  UINT8                       MBRType;
  ///
  /// Type of Disk Signature: (Unused values reserved).
  /// 0x00 - No Disk Signature.
  /// 0x01 - 32-bit signature from address 0x1b8 of the type 0x01 MBR.
  /// 0x02 - GUID signature.
  ///
  UINT8                       SignatureType;
} HARDDRIVE_DEVICE_PATH;








///
/// CD-ROM Media Device Path SubType.
///


///
/// The CD-ROM Media Device Path is used to define a system partition that exists on a CD-ROM.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Boot Entry number from the Boot Catalog. The Initial/Default entry is defined as zero.
  ///
  UINT32                      BootEntry;
  ///
  /// Starting RBA of the partition on the medium. CD-ROMs use Relative logical Block Addressing.
  ///
  UINT64                      PartitionStart;
  ///
  /// Size of the partition in units of Blocks, also called Sectors.
  ///
  UINT64                      PartitionSize;
} CDROM_DEVICE_PATH;

//
// Use VENDOR_DEVICE_PATH struct
//


///
/// File Path Media Device Path SubType
///

typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// A NULL-terminated Path string including directory and file names.
  ///
  CHAR16                      PathName[1];
} FILEPATH_DEVICE_PATH;



///
/// Media Protocol Device Path SubType.
///


///
/// The Media Protocol Device Path is used to denote the protocol that is being
/// used in a device path at the location of the path specified.
/// Many protocols are inherent to the style of device path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// The ID of the protocol.
  ///
  EFI_GUID                    Protocol;
} MEDIA_PROTOCOL_DEVICE_PATH;

///
/// PIWG Firmware File SubType.
///


///
/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware file.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Firmware file name
  ///
  EFI_GUID                    FvFileName;
} MEDIA_FW_VOL_FILEPATH_DEVICE_PATH;

///
/// PIWG Firmware Volume Device Path SubType.
///


///
/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware volume.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Firmware volume name.
  ///
  EFI_GUID                    FvName;
} MEDIA_FW_VOL_DEVICE_PATH;

///
/// Media relative offset range device path.
///


///
/// Used to describe the offset range of media relative.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  UINT32                      Reserved;
  UINT64                      StartingOffset;
  UINT64                      EndingOffset;
} MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH;

///
/// This GUID defines a RAM Disk supporting a raw disk format in volatile memory.
///


extern  EFI_GUID  gEfiVirtualDiskGuid;

///
/// This GUID defines a RAM Disk supporting an ISO image in volatile memory.
///


extern  EFI_GUID  gEfiVirtualCdGuid;

///
/// This GUID defines a RAM Disk supporting a raw disk format in persistent memory.
///


extern  EFI_GUID  gEfiPersistentVirtualDiskGuid;

///
/// This GUID defines a RAM Disk supporting an ISO image in persistent memory.
///


extern  EFI_GUID  gEfiPersistentVirtualCdGuid;

///
/// Media ram disk device path.
///


///
/// Used to describe the ram disk device path.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Starting Memory Address.
  ///
  UINT32                      StartingAddr[2];
  ///
  /// Ending Memory Address.
  ///
  UINT32                      EndingAddr[2];
  ///
  /// GUID that defines the type of the RAM Disk.
  ///
  EFI_GUID                    TypeGuid;
  ///
  /// RAM Diskinstance number, if supported. The default value is zero.
  ///
  UINT16                      Instance;
} MEDIA_RAM_DISK_DEVICE_PATH;

///
/// BIOS Boot Specification Device Path.
///


///
/// BIOS Boot Specification Device Path SubType.
///


///
/// This Device Path is used to describe the booting of non-EFI-aware operating systems.
///
typedef struct {
  EFI_DEVICE_PATH_PROTOCOL    Header;
  ///
  /// Device Type as defined by the BIOS Boot Specification.
  ///
  UINT16                      DeviceType;
  ///
  /// Status Flags as defined by the BIOS Boot Specification.
  ///
  UINT16                      StatusFlag;
  ///
  /// Null-terminated ASCII string that describes the boot device to a user.
  ///
  CHAR8                       String[1];
} BBS_BBS_DEVICE_PATH;

//
// DeviceType definitions - from BBS specification
//









///
/// Union of all possible Device Paths and pointers to Device Paths.
///
typedef union {
  EFI_DEVICE_PATH_PROTOCOL                   DevPath;
  PCI_DEVICE_PATH                            Pci;
  PCCARD_DEVICE_PATH                         PcCard;
  MEMMAP_DEVICE_PATH                         MemMap;
  VENDOR_DEVICE_PATH                         Vendor;

  CONTROLLER_DEVICE_PATH                     Controller;
  BMC_DEVICE_PATH                            Bmc;
  ACPI_HID_DEVICE_PATH                       Acpi;
  ACPI_EXTENDED_HID_DEVICE_PATH              ExtendedAcpi;
  ACPI_ADR_DEVICE_PATH                       AcpiAdr;

  ATAPI_DEVICE_PATH                          Atapi;
  SCSI_DEVICE_PATH                           Scsi;
  ISCSI_DEVICE_PATH                          Iscsi;
  FIBRECHANNEL_DEVICE_PATH                   FibreChannel;
  FIBRECHANNELEX_DEVICE_PATH                 FibreChannelEx;

  F1394_DEVICE_PATH                          F1394;
  USB_DEVICE_PATH                            Usb;
  SATA_DEVICE_PATH                           Sata;
  USB_CLASS_DEVICE_PATH                      UsbClass;
  USB_WWID_DEVICE_PATH                       UsbWwid;
  DEVICE_LOGICAL_UNIT_DEVICE_PATH            LogicUnit;
  I2O_DEVICE_PATH                            I2O;
  MAC_ADDR_DEVICE_PATH                       MacAddr;
  IPv4_DEVICE_PATH                           Ipv4;
  IPv6_DEVICE_PATH                           Ipv6;
  VLAN_DEVICE_PATH                           Vlan;
  INFINIBAND_DEVICE_PATH                     InfiniBand;
  UART_DEVICE_PATH                           Uart;
  UART_FLOW_CONTROL_DEVICE_PATH              UartFlowControl;
  SAS_DEVICE_PATH                            Sas;
  SASEX_DEVICE_PATH                          SasEx;
  NVME_NAMESPACE_DEVICE_PATH                 NvmeNamespace;
  NVME_OF_NAMESPACE_DEVICE_PATH              NvmeOfNamespace;
  DNS_DEVICE_PATH                            Dns;
  URI_DEVICE_PATH                            Uri;
  BLUETOOTH_DEVICE_PATH                      Bluetooth;
  WIFI_DEVICE_PATH                           WiFi;
  UFS_DEVICE_PATH                            Ufs;
  SD_DEVICE_PATH                             Sd;
  EMMC_DEVICE_PATH                           Emmc;
  HARDDRIVE_DEVICE_PATH                      HardDrive;
  CDROM_DEVICE_PATH                          CD;

  FILEPATH_DEVICE_PATH                       FilePath;
  MEDIA_PROTOCOL_DEVICE_PATH                 MediaProtocol;

  MEDIA_FW_VOL_DEVICE_PATH                   FirmwareVolume;
  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH          FirmwareFile;
  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH    Offset;
  MEDIA_RAM_DISK_DEVICE_PATH                 RamDisk;
  BBS_BBS_DEVICE_PATH                        Bbs;
} EFI_DEV_PATH;

typedef union {
  EFI_DEVICE_PATH_PROTOCOL                   *DevPath;
  PCI_DEVICE_PATH                            *Pci;
  PCCARD_DEVICE_PATH                         *PcCard;
  MEMMAP_DEVICE_PATH                         *MemMap;
  VENDOR_DEVICE_PATH                         *Vendor;

  CONTROLLER_DEVICE_PATH                     *Controller;
  BMC_DEVICE_PATH                            *Bmc;
  ACPI_HID_DEVICE_PATH                       *Acpi;
  ACPI_EXTENDED_HID_DEVICE_PATH              *ExtendedAcpi;
  ACPI_ADR_DEVICE_PATH                       *AcpiAdr;

  ATAPI_DEVICE_PATH                          *Atapi;
  SCSI_DEVICE_PATH                           *Scsi;
  ISCSI_DEVICE_PATH                          *Iscsi;
  FIBRECHANNEL_DEVICE_PATH                   *FibreChannel;
  FIBRECHANNELEX_DEVICE_PATH                 *FibreChannelEx;

  F1394_DEVICE_PATH                          *F1394;
  USB_DEVICE_PATH                            *Usb;
  SATA_DEVICE_PATH                           *Sata;
  USB_CLASS_DEVICE_PATH                      *UsbClass;
  USB_WWID_DEVICE_PATH                       *UsbWwid;
  DEVICE_LOGICAL_UNIT_DEVICE_PATH            *LogicUnit;
  I2O_DEVICE_PATH                            *I2O;
  MAC_ADDR_DEVICE_PATH                       *MacAddr;
  IPv4_DEVICE_PATH                           *Ipv4;
  IPv6_DEVICE_PATH                           *Ipv6;
  VLAN_DEVICE_PATH                           *Vlan;
  INFINIBAND_DEVICE_PATH                     *InfiniBand;
  UART_DEVICE_PATH                           *Uart;
  UART_FLOW_CONTROL_DEVICE_PATH              *UartFlowControl;
  SAS_DEVICE_PATH                            *Sas;
  SASEX_DEVICE_PATH                          *SasEx;
  NVME_NAMESPACE_DEVICE_PATH                 *NvmeNamespace;
  NVME_OF_NAMESPACE_DEVICE_PATH              *NvmeOfNamespace;
  DNS_DEVICE_PATH                            *Dns;
  URI_DEVICE_PATH                            *Uri;
  BLUETOOTH_DEVICE_PATH                      *Bluetooth;
  WIFI_DEVICE_PATH                           *WiFi;
  UFS_DEVICE_PATH                            *Ufs;
  SD_DEVICE_PATH                             *Sd;
  EMMC_DEVICE_PATH                           *Emmc;
  HARDDRIVE_DEVICE_PATH                      *HardDrive;
  CDROM_DEVICE_PATH                          *CD;

  FILEPATH_DEVICE_PATH                       *FilePath;
  MEDIA_PROTOCOL_DEVICE_PATH                 *MediaProtocol;

  MEDIA_FW_VOL_DEVICE_PATH                   *FirmwareVolume;
  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH          *FirmwareFile;
  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH    *Offset;
  MEDIA_RAM_DISK_DEVICE_PATH                 *RamDisk;
  BBS_BBS_DEVICE_PATH                        *Bbs;
  UINT8                                      *Raw;
} EFI_DEV_PATH_PTR;

#pragma pack()





extern EFI_GUID  gEfiDevicePathProtocolGuid;

#line 1398 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DevicePath.h"
#line 22 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextIn.h"
/** @file
  Simple Text Input protocol from the UEFI 2.0 specification.

  Abstraction of a very simple input device like a keyboard or serial
  terminal.

  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/









typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL EFI_SIMPLE_TEXT_INPUT_PROTOCOL;

///
/// Protocol GUID name defined in EFI1.1.
///


///
/// Protocol name in EFI1.1 for backward-compatible.
///
typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL SIMPLE_INPUT_INTERFACE;

///
/// The keystroke information for the key that was pressed.
///
typedef struct {
  UINT16    ScanCode;
  CHAR16    UnicodeChar;
} EFI_INPUT_KEY;

//
// Required unicode control chars
//





//
// EFI Scan codes
//























/**
  Reset the input device and optionally run diagnostics

  @param  This                 Protocol instance pointer.
  @param  ExtendedVerification Driver may perform diagnostics on reset.

  @retval EFI_SUCCESS          The device was reset.
  @retval EFI_DEVICE_ERROR     The device is not functioning properly and could not be reset.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INPUT_RESET)(
   EFI_SIMPLE_TEXT_INPUT_PROTOCOL       *This,
   BOOLEAN                              ExtendedVerification
  );

/**
  Reads the next keystroke from the input device. The WaitForKey Event can
  be used to test for existence of a keystroke via WaitForEvent () call.

  @param  This  Protocol instance pointer.
  @param  Key   A pointer to a buffer that is filled in with the keystroke
                information for the key that was pressed.

  @retval EFI_SUCCESS      The keystroke information was returned.
  @retval EFI_NOT_READY    There was no keystroke data available.
  @retval EFI_DEVICE_ERROR The keystroke information was not returned due to
                           hardware errors.
  @retval EFI_UNSUPPORTED  The device does not support the ability to read keystroke data.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INPUT_READ_KEY)(
   EFI_SIMPLE_TEXT_INPUT_PROTOCOL       *This,
   EFI_INPUT_KEY                       *Key
  );

///
/// The EFI_SIMPLE_TEXT_INPUT_PROTOCOL is used on the ConsoleIn device.
/// It is the minimum required protocol for ConsoleIn.
///
struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL {
  EFI_INPUT_RESET       Reset;
  EFI_INPUT_READ_KEY    ReadKeyStroke;
  ///
  /// Event to use with WaitForEvent() to wait for a key to be available
  ///
  EFI_EVENT             WaitForKey;
};

extern EFI_GUID  gEfiSimpleTextInProtocolGuid;

#line 129 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextIn.h"
#line 23 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextInEx.h"
/** @file
  Simple Text Input Ex protocol from the UEFI 2.0 specification.

  This protocol defines an extension to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL
  which exposes much more state and modifier information from the input device,
  also allows one to register a notification for a particular keystroke.

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/









typedef struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL;

/**
  The Reset() function resets the input device hardware. As part
  of initialization process, the firmware/device will make a quick
  but reasonable attempt to verify that the device is functioning.
  If the ExtendedVerification flag is TRUE the firmware may take
  an extended amount of time to verify the device is operating on
  reset. Otherwise the reset operation is to occur as quickly as
  possible. The hardware verification process is not defined by
  this specification and is left up to the platform firmware or
  driver to implement.

  @param This                 A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

  @param ExtendedVerification Indicates that the driver may
                              perform a more exhaustive
                              verification operation of the
                              device during reset.


  @retval EFI_SUCCESS       The device was reset.

  @retval EFI_DEVICE_ERROR  The device is not functioning
                            correctly and could not be reset.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INPUT_RESET_EX)(
   EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
   BOOLEAN                           ExtendedVerification
  );

///
/// EFI_KEY_TOGGLE_STATE. The toggle states are defined.
/// They are: EFI_TOGGLE_STATE_VALID, EFI_SCROLL_LOCK_ACTIVE
/// EFI_NUM_LOCK_ACTIVE, EFI_CAPS_LOCK_ACTIVE
///
typedef UINT8 EFI_KEY_TOGGLE_STATE;

typedef struct _EFI_KEY_STATE {
  ///
  /// Reflects the currently pressed shift
  /// modifiers for the input device. The
  /// returned value is valid only if the high
  /// order bit has been set.
  ///
  UINT32                  KeyShiftState;
  ///
  /// Reflects the current internal state of
  /// various toggled attributes. The returned
  /// value is valid only if the high order
  /// bit has been set.
  ///
  EFI_KEY_TOGGLE_STATE    KeyToggleState;
} EFI_KEY_STATE;

typedef struct {
  ///
  /// The EFI scan code and Unicode value returned from the input device.
  ///
  EFI_INPUT_KEY    Key;
  ///
  /// The current state of various toggled attributes as well as input modifier values.
  ///
  EFI_KEY_STATE    KeyState;
} EFI_KEY_DATA;

//
// Any Shift or Toggle State that is valid should have
// high order bit set.
//
// Shift state
//












//
// Toggle state
//






//
// EFI Scan codes
//


























/**
  The function reads the next keystroke from the input device. If
  there is no pending keystroke the function returns
  EFI_NOT_READY. If there is a pending keystroke, then
  KeyData.Key.ScanCode is the EFI scan code defined in Error!
  Reference source not found. The KeyData.Key.UnicodeChar is the
  actual printable character or is zero if the key does not
  represent a printable character (control key, function key,
  etc.). The KeyData.KeyState is shift state for the character
  reflected in KeyData.Key.UnicodeChar or KeyData.Key.ScanCode .
  When interpreting the data from this function, it should be
  noted that if a class of printable characters that are
  normally adjusted by shift modifiers (e.g. Shift Key + "f"
  key) would be presented solely as a KeyData.Key.UnicodeChar
  without the associated shift state. So in the previous example
  of a Shift Key + "f" key being pressed, the only pertinent
  data returned would be KeyData.Key.UnicodeChar with the value
  of "F". This of course would not typically be the case for
  non-printable characters such as the pressing of the Right
  Shift Key + F10 key since the corresponding returned data
  would be reflected both in the KeyData.KeyState.KeyShiftState
  and KeyData.Key.ScanCode values. UEFI drivers which implement
  the EFI_SIMPLE_TEXT_INPUT_EX protocol are required to return
  KeyData.Key and KeyData.KeyState values. These drivers must
  always return the most current state of
  KeyData.KeyState.KeyShiftState and
  KeyData.KeyState.KeyToggleState. It should also be noted that
  certain input devices may not be able to produce shift or toggle
  state information, and in those cases the high order bit in the
  respective Toggle and Shift state fields should not be active.


  @param This     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

  @param KeyData  A pointer to a buffer that is filled in with
                  the keystroke state data for the key that was
                  pressed.


  @retval EFI_SUCCESS      The keystroke information was returned.
  @retval EFI_NOT_READY    There was no keystroke data available.
  @retval EFI_DEVICE_ERROR The keystroke information was not returned due to
                           hardware errors.
  @retval EFI_UNSUPPORTED  The device does not support the ability to read keystroke data.


**/
typedef
EFI_STATUS
(__cdecl *EFI_INPUT_READ_KEY_EX)(
    EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
   EFI_KEY_DATA                      *KeyData
  );

/**
  The SetState() function allows the input device hardware to
  have state settings adjusted.

  @param This           A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

  @param KeyToggleState Pointer to the EFI_KEY_TOGGLE_STATE to
                        set the state for the input device.


  @retval EFI_SUCCESS       The device state was set appropriately.

  @retval EFI_DEVICE_ERROR  The device is not functioning
                            correctly and could not have the
                            setting adjusted.

  @retval EFI_UNSUPPORTED   The device does not support the
                            ability to have its state set.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_STATE)(
   EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
   EFI_KEY_TOGGLE_STATE              *KeyToggleState
  );

///
/// The function will be called when the key sequence is typed specified by KeyData.
///
typedef
EFI_STATUS
(__cdecl *EFI_KEY_NOTIFY_FUNCTION)(
   EFI_KEY_DATA *KeyData
  );

/**
  The RegisterKeystrokeNotify() function registers a function
  which will be called when a specified keystroke will occur.

  @param This                     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

  @param KeyData                  A pointer to a buffer that is filled in with
                                  the keystroke information for the key that was
                                  pressed. If KeyData.Key, KeyData.KeyState.KeyToggleState
                                  and KeyData.KeyState.KeyShiftState are 0, then any incomplete
                                  keystroke will trigger a notification of the KeyNotificationFunction.

  @param KeyNotificationFunction  Points to the function to be called when the key sequence
                                  is typed specified by KeyData. This notification function
                                  should be called at <=TPL_CALLBACK.


  @param NotifyHandle             Points to the unique handle assigned to
                                  the registered notification.

  @retval EFI_SUCCESS           Key notify was registered successfully.

  @retval EFI_OUT_OF_RESOURCES  Unable to allocate necessary
                                data structures.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REGISTER_KEYSTROKE_NOTIFY)(
    EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
    EFI_KEY_DATA                      *KeyData,
    EFI_KEY_NOTIFY_FUNCTION           KeyNotificationFunction,
   void                              **NotifyHandle
  );

/**
  The UnregisterKeystrokeNotify() function removes the
  notification which was previously registered.

  @param This               A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

  @param NotificationHandle The handle of the notification
                            function being unregistered.

  @retval EFI_SUCCESS           Key notify was unregistered successfully.

  @retval EFI_INVALID_PARAMETER The NotificationHandle is
                                invalid.

**/
typedef
EFI_STATUS
(__cdecl *EFI_UNREGISTER_KEYSTROKE_NOTIFY)(
   EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL  *This,
   void                               *NotificationHandle
  );

///
/// The EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL is used on the ConsoleIn
/// device. It is an extension to the Simple Text Input protocol
/// which allows a variety of extended shift state information to be
/// returned.
///
struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL {
  EFI_INPUT_RESET_EX                 Reset;
  EFI_INPUT_READ_KEY_EX              ReadKeyStrokeEx;
  ///
  /// Event to use with WaitForEvent() to wait for a key to be available.
  ///
  EFI_EVENT                          WaitForKeyEx;
  EFI_SET_STATE                      SetState;
  EFI_REGISTER_KEYSTROKE_NOTIFY      RegisterKeyNotify;
  EFI_UNREGISTER_KEYSTROKE_NOTIFY    UnregisterKeyNotify;
};

extern EFI_GUID  gEfiSimpleTextInputExProtocolGuid;

#line 314 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextInEx.h"
#line 24 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextOut.h"
/** @file
  Simple Text Out protocol from the UEFI 2.0 specification.

  Abstraction of a very simple text based output device like VGA text mode or
  a serial terminal. The Simple Text Out protocol instance can represent
  a single hardware device or a virtual device that is an aggregation
  of multiple physical devices.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/









///
/// Protocol GUID defined in EFI1.1.
///


typedef struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

///
/// Backward-compatible with EFI1.1.
///
typedef EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL SIMPLE_TEXT_OUTPUT_INTERFACE;

//
// Defines for required EFI Unicode Box Draw characters
//









































//
// EFI Required Block Elements Code Chart
//



//
// EFI Required Geometric Shapes Code Chart
//





//
// EFI Required Arrow shapes
//





//
// EFI Console Colours
//


















//
// Macro to accept color values in their raw form to create
// a value that represents both a foreground and background
// color in a single byte.
// For Foreground, and EFI_* value is valid from EFI_BLACK(0x00) to
// EFI_WHITE (0x0F).
// For Background, only EFI_BLACK, EFI_BLUE, EFI_GREEN, EFI_CYAN,
// EFI_RED, EFI_MAGENTA, EFI_BROWN, and EFI_LIGHTGRAY are acceptable
//
// Do not use EFI_BACKGROUND_xxx values with this macro.
//











//
// We currently define attributes from 0 - 7F for color manipulations
// To internally handle the local display characteristics for a particular character,
// Bit 7 signifies the local glyph representation for a character.  If turned on, glyphs will be
// pulled from the wide glyph database and will display locally as a wide character (16 X 19 versus 8 X 19)
// If bit 7 is off, the narrow glyph database will be used.  This does NOT affect information that is sent to
// non-local displays, such as serial or LAN consoles.
//


/**
  Reset the text output device hardware and optionally run diagnostics

  @param  This                 The protocol instance pointer.
  @param  ExtendedVerification Driver may perform more exhaustive verification
                               operation of the device during reset.

  @retval EFI_SUCCESS          The text output device was reset.
  @retval EFI_DEVICE_ERROR     The text output device is not functioning correctly and
                               could not be reset.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_RESET)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   BOOLEAN                                ExtendedVerification
  );

/**
  Write a string to the output device.

  @param  This   The protocol instance pointer.
  @param  String The NULL-terminated string to be displayed on the output
                 device(s). All output devices must also support the Unicode
                 drawing character codes defined in this file.

  @retval EFI_SUCCESS             The string was output to the device.
  @retval EFI_DEVICE_ERROR        The device reported an error while attempting to output
                                  the text.
  @retval EFI_UNSUPPORTED         The output device's mode is not currently in a
                                  defined text mode.
  @retval EFI_WARN_UNKNOWN_GLYPH  This warning code indicates that some of the
                                  characters in the string could not be
                                  rendered and were skipped.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_STRING)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   CHAR16                                 *String
  );

/**
  Verifies that all characters in a string can be output to the
  target device.

  @param  This   The protocol instance pointer.
  @param  String The NULL-terminated string to be examined for the output
                 device(s).

  @retval EFI_SUCCESS      The device(s) are capable of rendering the output string.
  @retval EFI_UNSUPPORTED  Some of the characters in the string cannot be
                           rendered by one or more of the output devices mapped
                           by the EFI handle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_TEST_STRING)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   CHAR16                                 *String
  );

/**
  Returns information for an available text mode that the output device(s)
  supports.

  @param  This       The protocol instance pointer.
  @param  ModeNumber The mode number to return information on.
  @param  Columns    Returns the geometry of the text output device for the
                     requested ModeNumber.
  @param  Rows       Returns the geometry of the text output device for the
                     requested ModeNumber.

  @retval EFI_SUCCESS      The requested mode information was returned.
  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED  The mode number was not valid.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_QUERY_MODE)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   UINTN                                  ModeNumber,
   UINTN                                 *Columns,
   UINTN                                 *Rows
  );

/**
  Sets the output device(s) to a specified mode.

  @param  This       The protocol instance pointer.
  @param  ModeNumber The mode number to set.

  @retval EFI_SUCCESS      The requested text mode was set.
  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED  The mode number was not valid.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_SET_MODE)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   UINTN                                  ModeNumber
  );

/**
  Sets the background and foreground colors for the OutputString () and
  ClearScreen () functions.

  @param  This      The protocol instance pointer.
  @param  Attribute The attribute to set. Bits 0..3 are the foreground color, and
                    bits 4..6 are the background color. All other bits are undefined
                    and must be zero. The valid Attributes are defined in this file.

  @retval EFI_SUCCESS       The attribute was set.
  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED   The attribute requested is not defined.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_SET_ATTRIBUTE)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   UINTN                                  Attribute
  );

/**
  Clears the output device(s) display to the currently selected background
  color.

  @param  This              The protocol instance pointer.

  @retval  EFI_SUCCESS      The operation completed successfully.
  @retval  EFI_DEVICE_ERROR The device had an error and could not complete the request.
  @retval  EFI_UNSUPPORTED  The output device is not in a valid text mode.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_CLEAR_SCREEN)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   *This
  );

/**
  Sets the current coordinates of the cursor position

  @param  This        The protocol instance pointer.
  @param  Column      The position to set the cursor to. Must be greater than or
                      equal to zero and less than the number of columns and rows
                      by QueryMode ().
  @param  Row         The position to set the cursor to. Must be greater than or
                      equal to zero and less than the number of columns and rows
                      by QueryMode ().

  @retval EFI_SUCCESS      The operation completed successfully.
  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED  The output device is not in a valid text mode, or the
                           cursor position is invalid for the current mode.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_SET_CURSOR_POSITION)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   UINTN                                  Column,
   UINTN                                  Row
  );

/**
  Makes the cursor visible or invisible

  @param  This    The protocol instance pointer.
  @param  Visible If TRUE, the cursor is set to be visible. If FALSE, the cursor is
                  set to be invisible.

  @retval EFI_SUCCESS      The operation completed successfully.
  @retval EFI_DEVICE_ERROR The device had an error and could not complete the
                           request, or the device does not support changing
                           the cursor mode.
  @retval EFI_UNSUPPORTED  The output device is not in a valid text mode.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TEXT_ENABLE_CURSOR)(
   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
   BOOLEAN                                Visible
  );

/**
  @par Data Structure Description:
  Mode Structure pointed to by Simple Text Out protocol.
**/
typedef struct {
  ///
  /// The number of modes supported by QueryMode () and SetMode ().
  ///
  INT32    MaxMode;

  //
  // current settings
  //

  ///
  /// The text mode of the output device(s).
  ///
  INT32      Mode;
  ///
  /// The current character output attribute.
  ///
  INT32      Attribute;
  ///
  /// The cursor's column.
  ///
  INT32      CursorColumn;
  ///
  /// The cursor's row.
  ///
  INT32      CursorRow;
  ///
  /// The cursor is currently visible or not.
  ///
  BOOLEAN    CursorVisible;
} EFI_SIMPLE_TEXT_OUTPUT_MODE;

///
/// The SIMPLE_TEXT_OUTPUT protocol is used to control text-based output devices.
/// It is the minimum required protocol for any handle supplied as the ConsoleOut
/// or StandardError device. In addition, the minimum supported text mode of such
/// devices is at least 80 x 25 characters.
///
struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
  EFI_TEXT_RESET                  Reset;

  EFI_TEXT_STRING                 OutputString;
  EFI_TEXT_TEST_STRING            TestString;

  EFI_TEXT_QUERY_MODE             QueryMode;
  EFI_TEXT_SET_MODE               SetMode;
  EFI_TEXT_SET_ATTRIBUTE          SetAttribute;

  EFI_TEXT_CLEAR_SCREEN           ClearScreen;
  EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
  EFI_TEXT_ENABLE_CURSOR          EnableCursor;

  ///
  /// Pointer to SIMPLE_TEXT_OUTPUT_MODE data.
  ///
  EFI_SIMPLE_TEXT_OUTPUT_MODE     *Mode;
};

extern EFI_GUID  gEfiSimpleTextOutProtocolGuid;

#line 410 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/SimpleTextOut.h"
#line 25 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"

///
/// Enumeration of EFI memory allocation types.
///
typedef enum {
  ///
  /// Allocate any available range of pages that satisfies the request.
  ///
  AllocateAnyPages,
  ///
  /// Allocate any available range of pages whose uppermost address is less than
  /// or equal to a specified maximum address.
  ///
  AllocateMaxAddress,
  ///
  /// Allocate pages at a specified address.
  ///
  AllocateAddress,
  ///
  /// Maximum enumeration value that may be used for bounds checking.
  ///
  MaxAllocateType
} EFI_ALLOCATE_TYPE;

//
// Bit definitions for EFI_TIME.Daylight
//



///
/// Value definition for EFI_TIME.TimeZone.
///


//
// Memory cacheability attributes
//





//
// Physical memory protection attributes
//
// Note: UEFI spec 2.5 and following: use EFI_MEMORY_RO as write-protected physical memory
// protection attribute. Also, EFI_MEMORY_WP means cacheability attribute.
//




//
// Physical memory persistence attribute.
// The memory region supports byte-addressable non-volatility.
//

//
// The memory region provides higher reliability relative to other memory in the system.
// If all memory has the same reliability, then this bit is not used.
//


//
// Note: UEFI spec 2.8 and following:
//
// Specific-purpose memory (SPM). The memory is earmarked for
// specific purposes such as for specific device drivers or applications.
// The SPM attribute serves as a hint to the OS to avoid allocating this
// memory for core OS data or code that can not be relocated.
//

//
// If this flag is set, the memory region is capable of being
// protected with the CPU's memory cryptographic
// capabilities. If this flag is clear, the memory region is not
// capable of being protected with the CPU's memory
// cryptographic capabilities or the CPU does not support CPU
// memory cryptographic capabilities.
//


//
// Runtime memory attribute
//


//
// If this flag is set, the memory region is
// described with additional ISA-specific memory attributes
// as specified in EFI_MEMORY_ISA_MASK.
//


//
// Defines the bits reserved for describing optional ISA-specific cacheability
// attributes that are not covered by the standard UEFI Memory Attributes cacheability
// bits (EFI_MEMORY_UC, EFI_MEMORY_WC, EFI_MEMORY_WT, EFI_MEMORY_WB and EFI_MEMORY_UCE).
// See Calling Conventions for further ISA-specific enumeration of these bits.
//


//
// Attributes bitmasks, grouped by type
//




///
/// Memory descriptor version number.
///


///
/// Definition of an EFI memory descriptor.
///
typedef struct {
  ///
  /// Type of the memory region.
  /// Type EFI_MEMORY_TYPE is defined in the
  /// AllocatePages() function description.
  ///
  UINT32                  Type;
  ///
  /// Physical address of the first byte in the memory region. PhysicalStart must be
  /// aligned on a 4 KiB boundary, and must not be above 0xfffffffffffff000. Type
  /// EFI_PHYSICAL_ADDRESS is defined in the AllocatePages() function description
  ///
  EFI_PHYSICAL_ADDRESS    PhysicalStart;
  ///
  /// Virtual address of the first byte in the memory region.
  /// VirtualStart must be aligned on a 4 KiB boundary,
  /// and must not be above 0xfffffffffffff000.
  ///
  EFI_VIRTUAL_ADDRESS     VirtualStart;
  ///
  /// NumberOfPagesNumber of 4 KiB pages in the memory region.
  /// NumberOfPages must not be 0, and must not be any value
  /// that would represent a memory page with a start address,
  /// either physical or virtual, above 0xfffffffffffff000.
  ///
  UINT64                  NumberOfPages;
  ///
  /// Attributes of the memory region that describe the bit mask of capabilities
  /// for that memory region, and not necessarily the current settings for that
  /// memory region.
  ///
  UINT64                  Attribute;
} EFI_MEMORY_DESCRIPTOR;

/**
  Allocates memory pages from the system.

  @param[in]       Type         The type of allocation to perform.
  @param[in]       MemoryType   The type of memory to allocate.
                                MemoryType values in the range 0x70000000..0x7FFFFFFF
                                are reserved for OEM use. MemoryType values in the range
                                0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders
                                that are provided by operating system vendors.
  @param[in]       Pages        The number of contiguous 4 KB pages to allocate.
  @param[in, out]  Memory       The pointer to a physical address. On input, the way in which the address is
                                used depends on the value of Type.

  @retval EFI_SUCCESS           The requested pages were allocated.
  @retval EFI_INVALID_PARAMETER 1) Type is not AllocateAnyPages or
                                AllocateMaxAddress or AllocateAddress.
                                2) MemoryType is in the range
                                EfiMaxMemoryType..0x6FFFFFFF.
                                3) Memory is NULL.
                                4) MemoryType is EfiPersistentMemory.
  @retval EFI_OUT_OF_RESOURCES  The pages could not be allocated.
  @retval EFI_NOT_FOUND         The requested pages could not be found.

**/
typedef
EFI_STATUS
(__cdecl *EFI_ALLOCATE_PAGES)(
       EFI_ALLOCATE_TYPE            Type,
       EFI_MEMORY_TYPE              MemoryType,
       UINTN                        Pages,
    EFI_PHYSICAL_ADDRESS         *Memory
  );

/**
  Frees memory pages.

  @param[in]  Memory      The base physical address of the pages to be freed.
  @param[in]  Pages       The number of contiguous 4 KB pages to free.

  @retval EFI_SUCCESS           The requested pages were freed.
  @retval EFI_INVALID_PARAMETER Memory is not a page-aligned address or Pages is invalid.
  @retval EFI_NOT_FOUND         The requested memory pages were not allocated with
                                AllocatePages().

**/
typedef
EFI_STATUS
(__cdecl *EFI_FREE_PAGES)(
    EFI_PHYSICAL_ADDRESS         Memory,
    UINTN                        Pages
  );

/**
  Returns the current memory map.

  @param[in, out]  MemoryMapSize         A pointer to the size, in bytes, of the MemoryMap buffer.
                                         On input, this is the size of the buffer allocated by the caller.
                                         On output, it is the size of the buffer returned by the firmware if
                                         the buffer was large enough, or the size of the buffer needed to contain
                                         the map if the buffer was too small.
  @param[out]      MemoryMap             A pointer to the buffer in which firmware places the current memory
                                         map.
  @param[out]      MapKey                A pointer to the location in which firmware returns the key for the
                                         current memory map.
  @param[out]      DescriptorSize        A pointer to the location in which firmware returns the size, in bytes, of
                                         an individual EFI_MEMORY_DESCRIPTOR.
  @param[out]      DescriptorVersion     A pointer to the location in which firmware returns the version number
                                         associated with the EFI_MEMORY_DESCRIPTOR.

  @retval EFI_SUCCESS           The memory map was returned in the MemoryMap buffer.
  @retval EFI_BUFFER_TOO_SMALL  The MemoryMap buffer was too small. The current buffer size
                                needed to hold the memory map is returned in MemoryMapSize.
  @retval EFI_INVALID_PARAMETER 1) MemoryMapSize is NULL.
                                2) The MemoryMap buffer is not too small and MemoryMap is
                                   NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_MEMORY_MAP)(
    UINTN                       *MemoryMapSize,
      EFI_MEMORY_DESCRIPTOR       *MemoryMap,
      UINTN                       *MapKey,
      UINTN                       *DescriptorSize,
      UINT32                      *DescriptorVersion
  );

/**
  Allocates pool memory.

  @param[in]   PoolType         The type of pool to allocate.
                                MemoryType values in the range 0x70000000..0x7FFFFFFF
                                are reserved for OEM use. MemoryType values in the range
                                0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders
                                that are provided by operating system vendors.
  @param[in]   Size             The number of bytes to allocate from the pool.
  @param[out]  Buffer           A pointer to a pointer to the allocated buffer if the call succeeds;
                                undefined otherwise.

  @retval EFI_SUCCESS           The requested number of bytes was allocated.
  @retval EFI_OUT_OF_RESOURCES  The pool requested could not be allocated.
  @retval EFI_INVALID_PARAMETER Buffer is NULL.
                                PoolType is in the range EfiMaxMemoryType..0x6FFFFFFF.
                                PoolType is EfiPersistentMemory.

**/
typedef
EFI_STATUS
(__cdecl *EFI_ALLOCATE_POOL)(
    EFI_MEMORY_TYPE              PoolType,
    UINTN                        Size,
   void                         **Buffer
  );

/**
  Returns pool memory to the system.

  @param[in]  Buffer            The pointer to the buffer to free.

  @retval EFI_SUCCESS           The memory was returned to the system.
  @retval EFI_INVALID_PARAMETER Buffer was invalid.

**/
typedef
EFI_STATUS
(__cdecl *EFI_FREE_POOL)(
    void                         *Buffer
  );

/**
  Changes the runtime addressing mode of EFI firmware from physical to virtual.

  @param[in]  MemoryMapSize     The size in bytes of VirtualMap.
  @param[in]  DescriptorSize    The size in bytes of an entry in the VirtualMap.
  @param[in]  DescriptorVersion The version of the structure entries in VirtualMap.
  @param[in]  VirtualMap        An array of memory descriptors which contain new virtual
                                address mapping information for all runtime ranges.

  @retval EFI_SUCCESS           The virtual address map has been applied.
  @retval EFI_UNSUPPORTED       EFI firmware is not at runtime, or the EFI firmware is already in
                                virtual address mapped mode.
  @retval EFI_INVALID_PARAMETER DescriptorSize or DescriptorVersion is invalid.
  @retval EFI_NO_MAPPING        A virtual address was not supplied for a range in the memory
                                map that requires a mapping.
  @retval EFI_NOT_FOUND         A virtual address was supplied for an address that is not found
                                in the memory map.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_VIRTUAL_ADDRESS_MAP)(
    UINTN                        MemoryMapSize,
    UINTN                        DescriptorSize,
    UINT32                       DescriptorVersion,
    EFI_MEMORY_DESCRIPTOR        *VirtualMap
  );

/**
  Connects one or more drivers to a controller.

  @param[in]  ControllerHandle      The handle of the controller to which driver(s) are to be connected.
  @param[in]  DriverImageHandle     A pointer to an ordered list handles that support the
                                    EFI_DRIVER_BINDING_PROTOCOL.
  @param[in]  RemainingDevicePath   A pointer to the device path that specifies a child of the
                                    controller specified by ControllerHandle.
  @param[in]  Recursive             If TRUE, then ConnectController() is called recursively
                                    until the entire tree of controllers below the controller specified
                                    by ControllerHandle have been created. If FALSE, then
                                    the tree of controllers is only expanded one level.

  @retval EFI_SUCCESS           1) One or more drivers were connected to ControllerHandle.
                                2) No drivers were connected to ControllerHandle, but
                                RemainingDevicePath is not NULL, and it is an End Device
                                Path Node.
  @retval EFI_INVALID_PARAMETER ControllerHandle is NULL.
  @retval EFI_NOT_FOUND         1) There are no EFI_DRIVER_BINDING_PROTOCOL instances
                                present in the system.
                                2) No drivers were connected to ControllerHandle.
  @retval EFI_SECURITY_VIOLATION
                                The user has no permission to start UEFI device drivers on the device path
                                associated with the ControllerHandle or specified by the RemainingDevicePath.
**/
typedef
EFI_STATUS
(__cdecl *EFI_CONNECT_CONTROLLER)(
    EFI_HANDLE                    ControllerHandle,
    EFI_HANDLE                    *DriverImageHandle    ,
    EFI_DEVICE_PATH_PROTOCOL      *RemainingDevicePath  ,
    BOOLEAN                       Recursive
  );

/**
  Disconnects one or more drivers from a controller.

  @param[in]  ControllerHandle      The handle of the controller from which driver(s) are to be disconnected.
  @param[in]  DriverImageHandle     The driver to disconnect from ControllerHandle.
                                    If DriverImageHandle is NULL, then all the drivers currently managing
                                    ControllerHandle are disconnected from ControllerHandle.
  @param[in]  ChildHandle           The handle of the child to destroy.
                                    If ChildHandle is NULL, then all the children of ControllerHandle are
                                    destroyed before the drivers are disconnected from ControllerHandle.

  @retval EFI_SUCCESS           1) One or more drivers were disconnected from the controller.
                                2) On entry, no drivers are managing ControllerHandle.
                                3) DriverImageHandle is not NULL, and on entry
                                   DriverImageHandle is not managing ControllerHandle.
  @retval EFI_INVALID_PARAMETER 1) ControllerHandle is NULL.
                                2) DriverImageHandle is not NULL, and it is not a valid EFI_HANDLE.
                                3) ChildHandle is not NULL, and it is not a valid EFI_HANDLE.
                                4) DriverImageHandle does not support the EFI_DRIVER_BINDING_PROTOCOL.
  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to disconnect any drivers from
                                ControllerHandle.
  @retval EFI_DEVICE_ERROR      The controller could not be disconnected because of a device error.

**/
typedef
EFI_STATUS
(__cdecl *EFI_DISCONNECT_CONTROLLER)(
    EFI_HANDLE                     ControllerHandle,
    EFI_HANDLE                     DriverImageHandle  ,
    EFI_HANDLE                     ChildHandle        
  );

//
// ConvertPointer DebugDisposition type.
//


/**
  Determines the new virtual address that is to be used on subsequent memory accesses.

  @param[in]       DebugDisposition  Supplies type information for the pointer being converted.
  @param[in, out]  Address           A pointer to a pointer that is to be fixed to be the value needed
                                     for the new virtual address mappings being applied.

  @retval EFI_SUCCESS           The pointer pointed to by Address was modified.
  @retval EFI_NOT_FOUND         The pointer pointed to by Address was not found to be part
                                of the current memory map. This is normally fatal.
  @retval EFI_INVALID_PARAMETER Address is NULL.
  @retval EFI_INVALID_PARAMETER *Address is NULL and DebugDisposition does
                                not have the EFI_OPTIONAL_PTR bit set.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CONVERT_POINTER)(
       UINTN                      DebugDisposition,
    void                       **Address
  );

//
// These types can be ORed together as needed - for example,
// EVT_TIMER might be Ored with EVT_NOTIFY_WAIT or
// EVT_NOTIFY_SIGNAL.
//








//
// The event's NotifyContext pointer points to a runtime memory
// address.
// The event is deprecated in UEFI2.0 and later specifications.
//


/**
  Invoke a notification event

  @param[in]  Event                 Event whose notification function is being invoked.
  @param[in]  Context               The pointer to the notification function's context,
                                    which is implementation-dependent.

**/
typedef
void
(__cdecl *EFI_EVENT_NOTIFY)(
    EFI_EVENT                Event,
    void                     *Context
  );

/**
  Creates an event.

  @param[in]   Type             The type of event to create and its mode and attributes.
  @param[in]   NotifyTpl        The task priority level of event notifications, if needed.
  @param[in]   NotifyFunction   The pointer to the event's notification function, if any.
  @param[in]   NotifyContext    The pointer to the notification function's context; corresponds to parameter
                                Context in the notification function.
  @param[out]  Event            The pointer to the newly created event if the call succeeds; undefined
                                otherwise.

  @retval EFI_SUCCESS           The event structure was created.
  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CREATE_EVENT)(
    UINT32                       Type,
    EFI_TPL                      NotifyTpl,
    EFI_EVENT_NOTIFY             NotifyFunction ,
    void                         *NotifyContext ,
   EFI_EVENT                    *Event
  );

/**
  Creates an event in a group.

  @param[in]   Type             The type of event to create and its mode and attributes.
  @param[in]   NotifyTpl        The task priority level of event notifications,if needed.
  @param[in]   NotifyFunction   The pointer to the event's notification function, if any.
  @param[in]   NotifyContext    The pointer to the notification function's context; corresponds to parameter
                                Context in the notification function.
  @param[in]   EventGroup       The pointer to the unique identifier of the group to which this event belongs.
                                If this is NULL, then the function behaves as if the parameters were passed
                                to CreateEvent.
  @param[out]  Event            The pointer to the newly created event if the call succeeds; undefined
                                otherwise.

  @retval EFI_SUCCESS           The event structure was created.
  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CREATE_EVENT_EX)(
         UINT32                 Type,
         EFI_TPL                NotifyTpl,
         EFI_EVENT_NOTIFY       NotifyFunction ,
   const void                   *NotifyContext ,
   const EFI_GUID               *EventGroup    ,
        EFI_EVENT              *Event
  );

///
/// Timer delay types
///
typedef enum {
  ///
  /// An event's timer settings is to be cancelled and not trigger time is to be set/
  ///
  TimerCancel,
  ///
  /// An event is to be signaled periodically at a specified interval from the current time.
  ///
  TimerPeriodic,
  ///
  /// An event is to be signaled once at a specified interval from the current time.
  ///
  TimerRelative
} EFI_TIMER_DELAY;

/**
  Sets the type of timer and the trigger time for a timer event.

  @param[in]  Event             The timer event that is to be signaled at the specified time.
  @param[in]  Type              The type of time that is specified in TriggerTime.
  @param[in]  TriggerTime       The number of 100ns units until the timer expires.
                                A TriggerTime of 0 is legal.
                                If Type is TimerRelative and TriggerTime is 0, then the timer
                                event will be signaled on the next timer tick.
                                If Type is TimerPeriodic and TriggerTime is 0, then the timer
                                event will be signaled on every timer tick.

  @retval EFI_SUCCESS           The event has been set to be signaled at the requested time.
  @retval EFI_INVALID_PARAMETER Event or Type is not valid.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_TIMER)(
    EFI_EVENT                Event,
    EFI_TIMER_DELAY          Type,
    UINT64                   TriggerTime
  );

/**
  Signals an event.

  @param[in]  Event             The event to signal.

  @retval EFI_SUCCESS           The event has been signaled.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SIGNAL_EVENT)(
    EFI_EVENT                Event
  );

/**
  Stops execution until an event is signaled.

  @param[in]   NumberOfEvents   The number of events in the Event array.
  @param[in]   Event            An array of EFI_EVENT.
  @param[out]  Index            The pointer to the index of the event which satisfied the wait condition.

  @retval EFI_SUCCESS           The event indicated by Index was signaled.
  @retval EFI_INVALID_PARAMETER 1) NumberOfEvents is 0.
                                2) The event indicated by Index is of type
                                   EVT_NOTIFY_SIGNAL.
  @retval EFI_UNSUPPORTED       The current TPL is not TPL_APPLICATION.

**/
typedef
EFI_STATUS
(__cdecl *EFI_WAIT_FOR_EVENT)(
    UINTN                    NumberOfEvents,
    EFI_EVENT                *Event,
   UINTN                    *Index
  );

/**
  Closes an event.

  @param[in]  Event             The event to close.

  @retval EFI_SUCCESS           The event has been closed.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CLOSE_EVENT)(
   EFI_EVENT                Event
  );

/**
  Checks whether an event is in the signaled state.

  @param[in]  Event             The event to check.

  @retval EFI_SUCCESS           The event is in the signaled state.
  @retval EFI_NOT_READY         The event is not in the signaled state.
  @retval EFI_INVALID_PARAMETER Event is of type EVT_NOTIFY_SIGNAL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CHECK_EVENT)(
   EFI_EVENT                Event
  );

//
// Task priority level
//





/**
  Raises a task's priority level and returns its previous level.

  @param[in]  NewTpl          The new task priority level.

  @return Previous task priority level

**/
typedef
EFI_TPL
(__cdecl *EFI_RAISE_TPL)(
   EFI_TPL      NewTpl
  );

/**
  Restores a task's priority level to its previous value.

  @param[in]  OldTpl          The previous task priority level to restore.

**/
typedef
void
(__cdecl *EFI_RESTORE_TPL)(
   EFI_TPL      OldTpl
  );

/**
  Returns the value of a variable.

  @param[in]       VariableName  A Null-terminated string that is the name of the vendor's
                                 variable.
  @param[in]       VendorGuid    A unique identifier for the vendor.
  @param[out]      Attributes    If not NULL, a pointer to the memory location to return the
                                 attributes bitmask for the variable.
  @param[in, out]  DataSize      On input, the size in bytes of the return Data buffer.
                                 On output the size of data returned in Data.
  @param[out]      Data          The buffer to return the contents of the variable. May be NULL
                                 with a zero DataSize in order to determine the size buffer needed.

  @retval EFI_SUCCESS            The function completed successfully.
  @retval EFI_NOT_FOUND          The variable was not found.
  @retval EFI_BUFFER_TOO_SMALL   The DataSize is too small for the result.
  @retval EFI_INVALID_PARAMETER  VariableName is NULL.
  @retval EFI_INVALID_PARAMETER  VendorGuid is NULL.
  @retval EFI_INVALID_PARAMETER  DataSize is NULL.
  @retval EFI_INVALID_PARAMETER  The DataSize is not too small and Data is NULL.
  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
  @retval EFI_SECURITY_VIOLATION The variable could not be retrieved due to an authentication failure.
  @retval EFI_UNSUPPORTED        After ExitBootServices() has been called, this return code may be returned
                                 if no variable storage is supported. The platform should describe this
                                 runtime service as unsupported at runtime via an EFI_RT_PROPERTIES_TABLE
                                 configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_VARIABLE)(
       CHAR16                      *VariableName,
       EFI_GUID                    *VendorGuid,
      UINT32                      *Attributes     ,
    UINTN                       *DataSize,
      void                        *Data           
  );

/**
  Enumerates the current variable names.

  @param[in, out]  VariableNameSize The size of the VariableName buffer. The size must be large
                                    enough to fit input string supplied in VariableName buffer.
  @param[in, out]  VariableName     On input, supplies the last VariableName that was returned
                                    by GetNextVariableName(). On output, returns the Nullterminated
                                    string of the current variable.
  @param[in, out]  VendorGuid       On input, supplies the last VendorGuid that was returned by
                                    GetNextVariableName(). On output, returns the
                                    VendorGuid of the current variable.

  @retval EFI_SUCCESS           The function completed successfully.
  @retval EFI_NOT_FOUND         The next variable was not found.
  @retval EFI_BUFFER_TOO_SMALL  The VariableNameSize is too small for the result.
                                VariableNameSize has been updated with the size needed to complete the request.
  @retval EFI_INVALID_PARAMETER VariableNameSize is NULL.
  @retval EFI_INVALID_PARAMETER VariableName is NULL.
  @retval EFI_INVALID_PARAMETER VendorGuid is NULL.
  @retval EFI_INVALID_PARAMETER The input values of VariableName and VendorGuid are not a name and
                                GUID of an existing variable.
  @retval EFI_INVALID_PARAMETER Null-terminator is not found in the first VariableNameSize bytes of
                                the input VariableName buffer.
  @retval EFI_DEVICE_ERROR      The variable could not be retrieved due to a hardware error.
  @retval EFI_UNSUPPORTED       After ExitBootServices() has been called, this return code may be returned
                                if no variable storage is supported. The platform should describe this
                                runtime service as unsupported at runtime via an EFI_RT_PROPERTIES_TABLE
                                configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_NEXT_VARIABLE_NAME)(
    UINTN                    *VariableNameSize,
    CHAR16                   *VariableName,
    EFI_GUID                 *VendorGuid
  );

/**
  Sets the value of a variable.

  @param[in]  VariableName       A Null-terminated string that is the name of the vendor's variable.
                                 Each VariableName is unique for each VendorGuid. VariableName must
                                 contain 1 or more characters. If VariableName is an empty string,
                                 then EFI_INVALID_PARAMETER is returned.
  @param[in]  VendorGuid         A unique identifier for the vendor.
  @param[in]  Attributes         Attributes bitmask to set for the variable.
  @param[in]  DataSize           The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE or
                                 EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero
                                 causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is
                                 set, then a SetVariable() call with a DataSize of zero will not cause any change to
                                 the variable value (the timestamp associated with the variable may be updated however
                                 even if no new data value is provided,see the description of the
                                 EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not
                                 be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).
  @param[in]  Data               The contents for the variable.

  @retval EFI_SUCCESS            The firmware has successfully stored the variable and its data as
                                 defined by the Attributes.
  @retval EFI_INVALID_PARAMETER  An invalid combination of attribute bits, name, and GUID was supplied, or the
                                 DataSize exceeds the maximum allowed.
  @retval EFI_INVALID_PARAMETER  VariableName is an empty string.
  @retval EFI_OUT_OF_RESOURCES   Not enough storage is available to hold the variable and its data.
  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
  @retval EFI_WRITE_PROTECTED    The variable in question is read-only.
  @retval EFI_WRITE_PROTECTED    The variable in question cannot be deleted.
  @retval EFI_SECURITY_VIOLATION The variable could not be written due to EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACESS being set,
                                 but the AuthInfo does NOT pass the validation check carried out by the firmware.

  @retval EFI_NOT_FOUND          The variable trying to be updated or deleted was not found.
  @retval EFI_UNSUPPORTED        This call is not supported by this platform at the time the call is made.
                                 The platform should describe this runtime service as unsupported at runtime
                                 via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_VARIABLE)(
    CHAR16                       *VariableName,
    EFI_GUID                     *VendorGuid,
    UINT32                       Attributes,
    UINTN                        DataSize,
    void                         *Data
  );

///
/// This provides the capabilities of the
/// real time clock device as exposed through the EFI interfaces.
///
typedef struct {
  ///
  /// Provides the reporting resolution of the real-time clock device in
  /// counts per second. For a normal PC-AT CMOS RTC device, this
  /// value would be 1 Hz, or 1, to indicate that the device only reports
  /// the time to the resolution of 1 second.
  ///
  UINT32     Resolution;
  ///
  /// Provides the timekeeping accuracy of the real-time clock in an
  /// error rate of 1E-6 parts per million. For a clock with an accuracy
  /// of 50 parts per million, the value in this field would be
  /// 50,000,000.
  ///
  UINT32     Accuracy;
  ///
  /// A TRUE indicates that a time set operation clears the device's
  /// time below the Resolution reporting level. A FALSE
  /// indicates that the state below the Resolution level of the
  /// device is not cleared when the time is set. Normal PC-AT CMOS
  /// RTC devices set this value to FALSE.
  ///
  BOOLEAN    SetsToZero;
} EFI_TIME_CAPABILITIES;

/**
  Returns the current time and date information, and the time-keeping capabilities
  of the hardware platform.

  @param[out]  Time             A pointer to storage to receive a snapshot of the current time.
  @param[out]  Capabilities     An optional pointer to a buffer to receive the real time clock
                                device's capabilities.

  @retval EFI_SUCCESS           The operation completed successfully.
  @retval EFI_INVALID_PARAMETER Time is NULL.
  @retval EFI_DEVICE_ERROR      The time could not be retrieved due to hardware error.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_TIME)(
    EFI_TIME                    *Time,
    EFI_TIME_CAPABILITIES       *Capabilities 
  );

/**
  Sets the current local time and date information.

  @param[in]  Time              A pointer to the current time.

  @retval EFI_SUCCESS           The operation completed successfully.
  @retval EFI_INVALID_PARAMETER A time field is out of range.
  @retval EFI_DEVICE_ERROR      The time could not be set due due to hardware error.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_TIME)(
    EFI_TIME                     *Time
  );

/**
  Returns the current wakeup alarm clock setting.

  @param[out]  Enabled          Indicates if the alarm is currently enabled or disabled.
  @param[out]  Pending          Indicates if the alarm signal is pending and requires acknowledgement.
  @param[out]  Time             The current alarm setting.

  @retval EFI_SUCCESS           The alarm settings were returned.
  @retval EFI_INVALID_PARAMETER Enabled is NULL.
  @retval EFI_INVALID_PARAMETER Pending is NULL.
  @retval EFI_INVALID_PARAMETER Time is NULL.
  @retval EFI_DEVICE_ERROR      The wakeup time could not be retrieved due to a hardware error.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_WAKEUP_TIME)(
   BOOLEAN                     *Enabled,
   BOOLEAN                     *Pending,
   EFI_TIME                    *Time
  );

/**
  Sets the system wakeup alarm clock time.

  @param[in]  Enable            Enable or disable the wakeup alarm.
  @param[in]  Time              If Enable is TRUE, the time to set the wakeup alarm for.
                                If Enable is FALSE, then this parameter is optional, and may be NULL.

  @retval EFI_SUCCESS           If Enable is TRUE, then the wakeup alarm was enabled. If
                                Enable is FALSE, then the wakeup alarm was disabled.
  @retval EFI_INVALID_PARAMETER A time field is out of range.
  @retval EFI_DEVICE_ERROR      The wakeup time could not be set due to a hardware error.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_WAKEUP_TIME)(
    BOOLEAN                      Enable,
    EFI_TIME                     *Time   
  );

/**
  Loads an EFI image into memory.

  @param[in]   BootPolicy        If TRUE, indicates that the request originates from the boot
                                 manager, and that the boot manager is attempting to load
                                 FilePath as a boot selection. Ignored if SourceBuffer is
                                 not NULL.
  @param[in]   ParentImageHandle The caller's image handle.
  @param[in]   DevicePath        The DeviceHandle specific file path from which the image is
                                 loaded.
  @param[in]   SourceBuffer      If not NULL, a pointer to the memory location containing a copy
                                 of the image to be loaded.
  @param[in]   SourceSize        The size in bytes of SourceBuffer. Ignored if SourceBuffer is NULL.
  @param[out]  ImageHandle       The pointer to the returned image handle that is created when the
                                 image is successfully loaded.

  @retval EFI_SUCCESS            Image was loaded into memory correctly.
  @retval EFI_NOT_FOUND          Both SourceBuffer and DevicePath are NULL.
  @retval EFI_INVALID_PARAMETER  One or more parametes are invalid.
  @retval EFI_UNSUPPORTED        The image type is not supported.
  @retval EFI_OUT_OF_RESOURCES   Image was not loaded due to insufficient resources.
  @retval EFI_LOAD_ERROR         Image was not loaded because the image format was corrupt or not
                                 understood.
  @retval EFI_DEVICE_ERROR       Image was not loaded because the device returned a read error.
  @retval EFI_ACCESS_DENIED      Image was not loaded because the platform policy prohibits the
                                 image from being loaded. NULL is returned in *ImageHandle.
  @retval EFI_SECURITY_VIOLATION Image was loaded and an ImageHandle was created with a
                                 valid EFI_LOADED_IMAGE_PROTOCOL. However, the current
                                 platform policy specifies that the image should not be started.
**/
typedef
EFI_STATUS
(__cdecl *EFI_IMAGE_LOAD)(
    BOOLEAN                      BootPolicy,
    EFI_HANDLE                   ParentImageHandle,
    EFI_DEVICE_PATH_PROTOCOL     *DevicePath   ,
    void                         *SourceBuffer ,
    UINTN                        SourceSize,
   EFI_HANDLE                   *ImageHandle
  );

/**
  Transfers control to a loaded image's entry point.

  @param[in]   ImageHandle       Handle of image to be started.
  @param[out]  ExitDataSize      The pointer to the size, in bytes, of ExitData.
  @param[out]  ExitData          The pointer to a pointer to a data buffer that includes a Null-terminated
                                 string, optionally followed by additional binary data.

  @retval EFI_INVALID_PARAMETER  ImageHandle is either an invalid image handle or the image
                                 has already been initialized with StartImage.
  @retval EFI_SECURITY_VIOLATION The current platform policy specifies that the image should not be started.
  @return Exit code from image

**/
typedef
EFI_STATUS
(__cdecl *EFI_IMAGE_START)(
    EFI_HANDLE                  ImageHandle,
   UINTN                       *ExitDataSize,
   CHAR16                      **ExitData    
  );

/**
  Terminates a loaded EFI image and returns control to boot services.

  @param[in]  ImageHandle       Handle that identifies the image. This parameter is passed to the
                                image on entry.
  @param[in]  ExitStatus        The image's exit code.
  @param[in]  ExitDataSize      The size, in bytes, of ExitData. Ignored if ExitStatus is EFI_SUCCESS.
  @param[in]  ExitData          The pointer to a data buffer that includes a Null-terminated string,
                                optionally followed by additional binary data. The string is a
                                description that the caller may use to further indicate the reason
                                for the image's exit. ExitData is only valid if ExitStatus
                                is something other than EFI_SUCCESS. The ExitData buffer
                                must be allocated by calling AllocatePool().

  @retval EFI_SUCCESS           The image specified by ImageHandle was unloaded.
  @retval EFI_INVALID_PARAMETER The image specified by ImageHandle has been loaded and
                                started with LoadImage() and StartImage(), but the
                                image is not the currently executing image.

**/
typedef
EFI_STATUS
(__cdecl *EFI_EXIT)(
    EFI_HANDLE                   ImageHandle,
    EFI_STATUS                   ExitStatus,
    UINTN                        ExitDataSize,
    CHAR16                       *ExitData     
  );

/**
  Unloads an image.

  @param[in]  ImageHandle       Handle that identifies the image to be unloaded.

  @retval EFI_SUCCESS           The image has been unloaded.
  @retval EFI_INVALID_PARAMETER ImageHandle is not a valid image handle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_IMAGE_UNLOAD)(
    EFI_HANDLE                   ImageHandle
  );

/**
  Terminates all boot services.

  @param[in]  ImageHandle       Handle that identifies the exiting image.
  @param[in]  MapKey            Key to the latest memory map.

  @retval EFI_SUCCESS           Boot services have been terminated.
  @retval EFI_INVALID_PARAMETER MapKey is incorrect.

**/
typedef
EFI_STATUS
(__cdecl *EFI_EXIT_BOOT_SERVICES)(
    EFI_HANDLE                   ImageHandle,
    UINTN                        MapKey
  );

/**
  Induces a fine-grained stall.

  @param[in]  Microseconds      The number of microseconds to stall execution.

  @retval EFI_SUCCESS           Execution was stalled at least the requested number of
                                Microseconds.

**/
typedef
EFI_STATUS
(__cdecl *EFI_STALL)(
    UINTN                    Microseconds
  );

/**
  Sets the system's watchdog timer.

  @param[in]  Timeout           The number of seconds to set the watchdog timer to.
  @param[in]  WatchdogCode      The numeric code to log on a watchdog timer timeout event.
  @param[in]  DataSize          The size, in bytes, of WatchdogData.
  @param[in]  WatchdogData      A data buffer that includes a Null-terminated string, optionally
                                followed by additional binary data.

  @retval EFI_SUCCESS           The timeout has been set.
  @retval EFI_INVALID_PARAMETER The supplied WatchdogCode is invalid.
  @retval EFI_UNSUPPORTED       The system does not have a watchdog timer.
  @retval EFI_DEVICE_ERROR      The watchdog timer could not be programmed due to a hardware
                                error.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_WATCHDOG_TIMER)(
   UINTN                    Timeout,
   UINT64                   WatchdogCode,
   UINTN                    DataSize,
   CHAR16                   *WatchdogData 
  );

/**
  Resets the entire platform.

  @param[in]  ResetType         The type of reset to perform.
  @param[in]  ResetStatus       The status code for the reset.
  @param[in]  DataSize          The size, in bytes, of ResetData.
  @param[in]  ResetData         For a ResetType of EfiResetCold, EfiResetWarm, or
                                EfiResetShutdown the data buffer starts with a Null-terminated
                                string, optionally followed by additional binary data.
                                The string is a description that the caller may use to further
                                indicate the reason for the system reset.
                                For a ResetType of EfiResetPlatformSpecific the data buffer
                                also starts with a Null-terminated string that is followed
                                by an EFI_GUID that describes the specific type of reset to perform.
**/
typedef
void
(__cdecl *EFI_RESET_SYSTEM)(
   EFI_RESET_TYPE           ResetType,
   EFI_STATUS               ResetStatus,
   UINTN                    DataSize,
   void                     *ResetData 
  );

/**
  Returns a monotonically increasing count for the platform.

  @param[out]  Count            The pointer to returned value.

  @retval EFI_SUCCESS           The next monotonic count was returned.
  @retval EFI_INVALID_PARAMETER Count is NULL.
  @retval EFI_DEVICE_ERROR      The device is not functioning properly.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_NEXT_MONOTONIC_COUNT)(
   UINT64                  *Count
  );

/**
  Returns the next high 32 bits of the platform's monotonic counter.

  @param[out]  HighCount        The pointer to returned value.

  @retval EFI_SUCCESS           The next high monotonic count was returned.
  @retval EFI_INVALID_PARAMETER HighCount is NULL.
  @retval EFI_DEVICE_ERROR      The device is not functioning properly.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_NEXT_HIGH_MONO_COUNT)(
   UINT32                  *HighCount
  );

/**
  Computes and returns a 32-bit CRC for a data buffer.

  @param[in]   Data             A pointer to the buffer on which the 32-bit CRC is to be computed.
  @param[in]   DataSize         The number of bytes in the buffer Data.
  @param[out]  Crc32            The 32-bit CRC that was computed for the data buffer specified by Data
                                and DataSize.

  @retval EFI_SUCCESS           The 32-bit CRC was computed for the data buffer and returned in
                                Crc32.
  @retval EFI_INVALID_PARAMETER Data is NULL.
  @retval EFI_INVALID_PARAMETER Crc32 is NULL.
  @retval EFI_INVALID_PARAMETER DataSize is 0.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CALCULATE_CRC32)(
    void                              *Data,
    UINTN                             DataSize,
   UINT32                            *Crc32
  );

/**
  Copies the contents of one buffer to another buffer.

  @param[in]  Destination       The pointer to the destination buffer of the memory copy.
  @param[in]  Source            The pointer to the source buffer of the memory copy.
  @param[in]  Length            Number of bytes to copy from Source to Destination.

**/
typedef
void
(__cdecl *EFI_COPY_MEM)(
   void     *Destination,
   void     *Source,
   UINTN    Length
  );

/**
  The SetMem() function fills a buffer with a specified value.

  @param[in]  Buffer            The pointer to the buffer to fill.
  @param[in]  Size              Number of bytes in Buffer to fill.
  @param[in]  Value             Value to fill Buffer with.

**/
typedef
void
(__cdecl *EFI_SET_MEM)(
   void     *Buffer,
   UINTN    Size,
   UINT8    Value
  );

///
/// Enumeration of EFI Interface Types
///
typedef enum {
  ///
  /// Indicates that the supplied protocol interface is supplied in native form.
  ///
  EFI_NATIVE_INTERFACE
} EFI_INTERFACE_TYPE;

/**
  Installs a protocol interface on a device handle. If the handle does not exist, it is created and added
  to the list of handles in the system. InstallMultipleProtocolInterfaces() performs
  more error checking than InstallProtocolInterface(), so it is recommended that
  InstallMultipleProtocolInterfaces() be used in place of
  InstallProtocolInterface()

  @param[in, out]  Handle         A pointer to the EFI_HANDLE on which the interface is to be installed.
  @param[in]       Protocol       The numeric ID of the protocol interface.
  @param[in]       InterfaceType  Indicates whether Interface is supplied in native form.
  @param[in]       Interface      A pointer to the protocol interface.

  @retval EFI_SUCCESS           The protocol interface was installed.
  @retval EFI_OUT_OF_RESOURCES  Space for a new handle could not be allocated.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.
  @retval EFI_INVALID_PARAMETER InterfaceType is not EFI_NATIVE_INTERFACE.
  @retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INSTALL_PROTOCOL_INTERFACE)(
    EFI_HANDLE               *Handle,
       EFI_GUID                 *Protocol,
       EFI_INTERFACE_TYPE       InterfaceType,
       void                     *Interface
  );

/**
  Installs one or more protocol interfaces into the boot services environment.

  @param[in, out]  Handle       The pointer to a handle to install the new protocol interfaces on,
                                or a pointer to NULL if a new handle is to be allocated.
  @param  ...                   A variable argument list containing pairs of protocol GUIDs and protocol
                                interfaces.

  @retval EFI_SUCCESS           All the protocol interface was installed.
  @retval EFI_OUT_OF_RESOURCES  There was not enough memory in pool to install all the protocols.
  @retval EFI_ALREADY_STARTED   A Device Path Protocol instance was passed in that is already present in
                                the handle database.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES)(
    EFI_HANDLE           *Handle,
  ...
  );

/**
  Reinstalls a protocol interface on a device handle.

  @param[in]  Handle            Handle on which the interface is to be reinstalled.
  @param[in]  Protocol          The numeric ID of the interface.
  @param[in]  OldInterface      A pointer to the old interface. NULL can be used if a structure is not
                                associated with Protocol.
  @param[in]  NewInterface      A pointer to the new interface.

  @retval EFI_SUCCESS           The protocol interface was reinstalled.
  @retval EFI_NOT_FOUND         The OldInterface on the handle was not found.
  @retval EFI_ACCESS_DENIED     The protocol interface could not be reinstalled,
                                because OldInterface is still being used by a
                                driver that will not release it.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REINSTALL_PROTOCOL_INTERFACE)(
   EFI_HANDLE               Handle,
   EFI_GUID                 *Protocol,
   void                     *OldInterface,
   void                     *NewInterface
  );

/**
  Removes a protocol interface from a device handle. It is recommended that
  UninstallMultipleProtocolInterfaces() be used in place of
  UninstallProtocolInterface().

  @param[in]  Handle            The handle on which the interface was installed.
  @param[in]  Protocol          The numeric ID of the interface.
  @param[in]  Interface         A pointer to the interface.

  @retval EFI_SUCCESS           The interface was removed.
  @retval EFI_NOT_FOUND         The interface was not found.
  @retval EFI_ACCESS_DENIED     The interface was not removed because the interface
                                is still being used by a driver.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_UNINSTALL_PROTOCOL_INTERFACE)(
   EFI_HANDLE               Handle,
   EFI_GUID                 *Protocol,
   void                     *Interface
  );

/**
  Removes one or more protocol interfaces into the boot services environment.

  @param[in]  Handle            The handle to remove the protocol interfaces from.
  @param  ...                   A variable argument list containing pairs of protocol GUIDs and
                                protocol interfaces.

  @retval EFI_SUCCESS           All the protocol interfaces were removed.
  @retval EFI_INVALID_PARAMETER One of the protocol interfaces was not previously installed on Handle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES)(
   EFI_HANDLE           Handle,
  ...
  );

/**
  Queries a handle to determine if it supports a specified protocol.

  @param[in]   Handle           The handle being queried.
  @param[in]   Protocol         The published unique identifier of the protocol.
  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol
                                Interface is returned.

  @retval EFI_SUCCESS           The interface information for the specified protocol was returned.
  @retval EFI_UNSUPPORTED       The device does not support the specified protocol.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.
  @retval EFI_INVALID_PARAMETER Interface is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_HANDLE_PROTOCOL)(
    EFI_HANDLE               Handle,
    EFI_GUID                 *Protocol,
   void                     **Interface
  );








/**
  Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the
  handle, it opens the protocol on behalf of the calling agent.

  @param[in]   Handle           The handle for the protocol interface that is being opened.
  @param[in]   Protocol         The published unique identifier of the protocol.
  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol
                                Interface is returned.
  @param[in]   AgentHandle      The handle of the agent that is opening the protocol interface
                                specified by Protocol and Interface.
  @param[in]   ControllerHandle If the agent that is opening a protocol is a driver that follows the
                                UEFI Driver Model, then this parameter is the controller handle
                                that requires the protocol interface. If the agent does not follow
                                the UEFI Driver Model, then this parameter is optional and may
                                be NULL.
  @param[in]   Attributes       The open mode of the protocol interface specified by Handle
                                and Protocol.

  @retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the
                                protocol interface was returned in Interface.
  @retval EFI_UNSUPPORTED       Handle does not support Protocol.
  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
  @retval EFI_ACCESS_DENIED     Required attributes can't be supported in current environment.
  @retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent
                                handle is the same as AgentHandle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_OPEN_PROTOCOL)(
    EFI_HANDLE                Handle,
    EFI_GUID                  *Protocol,
   void                      **Interface  ,
    EFI_HANDLE                AgentHandle,
    EFI_HANDLE                ControllerHandle,
    UINT32                    Attributes
  );

/**
  Closes a protocol on a handle that was opened using OpenProtocol().

  @param[in]  Handle            The handle for the protocol interface that was previously opened
                                with OpenProtocol(), and is now being closed.
  @param[in]  Protocol          The published unique identifier of the protocol.
  @param[in]  AgentHandle       The handle of the agent that is closing the protocol interface.
  @param[in]  ControllerHandle  If the agent that opened a protocol is a driver that follows the
                                UEFI Driver Model, then this parameter is the controller handle
                                that required the protocol interface.

  @retval EFI_SUCCESS           The protocol instance was closed.
  @retval EFI_INVALID_PARAMETER 1) Handle is NULL.
                                2) AgentHandle is NULL.
                                3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.
                                4) Protocol is NULL.
  @retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.
                                2) The protocol interface specified by Handle and Protocol is not
                                   currently open by AgentHandle and ControllerHandle.

**/
typedef
EFI_STATUS
(__cdecl *EFI_CLOSE_PROTOCOL)(
   EFI_HANDLE               Handle,
   EFI_GUID                 *Protocol,
   EFI_HANDLE               AgentHandle,
   EFI_HANDLE               ControllerHandle
  );

///
/// EFI Oprn Protocol Information Entry
///
typedef struct {
  EFI_HANDLE    AgentHandle;
  EFI_HANDLE    ControllerHandle;
  UINT32        Attributes;
  UINT32        OpenCount;
} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;

/**
  Retrieves the list of agents that currently have a protocol interface opened.

  @param[in]   Handle           The handle for the protocol interface that is being queried.
  @param[in]   Protocol         The published unique identifier of the protocol.
  @param[out]  EntryBuffer      A pointer to a buffer of open protocol information in the form of
                                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.
  @param[out]  EntryCount       A pointer to the number of entries in EntryBuffer.

  @retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the
                                number of entries was returned EntryCount.
  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.
  @retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.

**/
typedef
EFI_STATUS
(__cdecl *EFI_OPEN_PROTOCOL_INFORMATION)(
    EFI_HANDLE                          Handle,
    EFI_GUID                            *Protocol,
   EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
   UINTN                               *EntryCount
  );

/**
  Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated
  from pool.

  @param[in]   Handle              The handle from which to retrieve the list of protocol interface
                                   GUIDs.
  @param[out]  ProtocolBuffer      A pointer to the list of protocol interface GUID pointers that are
                                   installed on Handle.
  @param[out]  ProtocolBufferCount A pointer to the number of GUID pointers present in
                                   ProtocolBuffer.

  @retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in
                                ProtocolBuffer. The number of protocol interface GUIDs was
                                returned in ProtocolBufferCount.
  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.
  @retval EFI_INVALID_PARAMETER Handle is NULL.
  @retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.
  @retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.
  @retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_PROTOCOLS_PER_HANDLE)(
    EFI_HANDLE      Handle,
   EFI_GUID        ***ProtocolBuffer,
   UINTN           *ProtocolBufferCount
  );

/**
  Creates an event that is to be signaled whenever an interface is installed for a specified protocol.

  @param[in]   Protocol         The numeric ID of the protocol for which the event is to be registered.
  @param[in]   Event            Event that is to be signaled whenever a protocol interface is registered
                                for Protocol.
  @param[out]  Registration     A pointer to a memory location to receive the registration value.

  @retval EFI_SUCCESS           The notification event has been registered.
  @retval EFI_OUT_OF_RESOURCES  Space for the notification event could not be allocated.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.
  @retval EFI_INVALID_PARAMETER Event is NULL.
  @retval EFI_INVALID_PARAMETER Registration is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REGISTER_PROTOCOL_NOTIFY)(
    EFI_GUID                 *Protocol,
    EFI_EVENT                Event,
   void                     **Registration
  );

///
/// Enumeration of EFI Locate Search Types
///
typedef enum {
  ///
  /// Retrieve all the handles in the handle database.
  ///
  AllHandles,
  ///
  /// Retrieve the next handle fron a RegisterProtocolNotify() event.
  ///
  ByRegisterNotify,
  ///
  /// Retrieve the set of handles from the handle database that support a
  /// specified protocol.
  ///
  ByProtocol
} EFI_LOCATE_SEARCH_TYPE;

/**
  Returns an array of handles that support a specified protocol.

  @param[in]       SearchType   Specifies which handle(s) are to be returned.
  @param[in]       Protocol     Specifies the protocol to search by.
  @param[in]       SearchKey    Specifies the search key.
  @param[in, out]  BufferSize   On input, the size in bytes of Buffer. On output, the size in bytes of
                                the array returned in Buffer (if the buffer was large enough) or the
                                size, in bytes, of the buffer needed to obtain the array (if the buffer was
                                not large enough).
  @param[out]      Buffer       The buffer in which the array is returned.

  @retval EFI_SUCCESS           The array of handles was returned.
  @retval EFI_NOT_FOUND         No handles match the search.
  @retval EFI_BUFFER_TOO_SMALL  The BufferSize is too small for the result.
  @retval EFI_INVALID_PARAMETER SearchType is not a member of EFI_LOCATE_SEARCH_TYPE.
  @retval EFI_INVALID_PARAMETER SearchType is ByRegisterNotify and SearchKey is NULL.
  @retval EFI_INVALID_PARAMETER SearchType is ByProtocol and Protocol is NULL.
  @retval EFI_INVALID_PARAMETER One or more matches are found and BufferSize is NULL.
  @retval EFI_INVALID_PARAMETER BufferSize is large enough for the result and Buffer is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_LOCATE_HANDLE)(
       EFI_LOCATE_SEARCH_TYPE   SearchType,
       EFI_GUID                 *Protocol     ,
       void                     *SearchKey    ,
    UINTN                    *BufferSize,
      EFI_HANDLE               *Buffer
  );

/**
  Locates the handle to a device on the device path that supports the specified protocol.

  @param[in]       Protocol     Specifies the protocol to search for.
  @param[in, out]  DevicePath   On input, a pointer to a pointer to the device path. On output, the device
                                path pointer is modified to point to the remaining part of the device
                                path.
  @param[out]      Device       A pointer to the returned device handle.

  @retval EFI_SUCCESS           The resulting handle was returned.
  @retval EFI_NOT_FOUND         No handles match the search.
  @retval EFI_INVALID_PARAMETER Protocol is NULL.
  @retval EFI_INVALID_PARAMETER DevicePath is NULL.
  @retval EFI_INVALID_PARAMETER A handle matched the search and Device is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_LOCATE_DEVICE_PATH)(
       EFI_GUID                         *Protocol,
    EFI_DEVICE_PATH_PROTOCOL         **DevicePath,
      EFI_HANDLE                       *Device
  );

/**
  Adds, updates, or removes a configuration table entry from the EFI System Table.

  @param[in]  Guid              A pointer to the GUID for the entry to add, update, or remove.
  @param[in]  Table             A pointer to the configuration table for the entry to add, update, or
                                remove. May be NULL.

  @retval EFI_SUCCESS           The (Guid, Table) pair was added, updated, or removed.
  @retval EFI_NOT_FOUND         An attempt was made to delete a nonexistent entry.
  @retval EFI_INVALID_PARAMETER Guid is NULL.
  @retval EFI_OUT_OF_RESOURCES  There is not enough memory available to complete the operation.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INSTALL_CONFIGURATION_TABLE)(
   EFI_GUID                 *Guid,
   void                     *Table
  );

/**
  Returns an array of handles that support the requested protocol in a buffer allocated from pool.

  @param[in]       SearchType   Specifies which handle(s) are to be returned.
  @param[in]       Protocol     Provides the protocol to search by.
                                This parameter is only valid for a SearchType of ByProtocol.
  @param[in]       SearchKey    Supplies the search key depending on the SearchType.
  @param[out]      NoHandles    The number of handles returned in Buffer.
  @param[out]      Buffer       A pointer to the buffer to return the requested array of handles that
                                support Protocol.

  @retval EFI_SUCCESS           The array of handles was returned in Buffer, and the number of
                                handles in Buffer was returned in NoHandles.
  @retval EFI_NOT_FOUND         No handles match the search.
  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the matching results.
  @retval EFI_INVALID_PARAMETER NoHandles is NULL.
  @retval EFI_INVALID_PARAMETER Buffer is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_LOCATE_HANDLE_BUFFER)(
       EFI_LOCATE_SEARCH_TYPE       SearchType,
       EFI_GUID                     *Protocol       ,
       void                         *SearchKey      ,
      UINTN                        *NoHandles,
      EFI_HANDLE                   **Buffer
  );

/**
  Returns the first protocol instance that matches the given protocol.

  @param[in]  Protocol          Provides the protocol to search for.
  @param[in]  Registration      Optional registration key returned from
                                RegisterProtocolNotify().
  @param[out]  Interface        On return, a pointer to the first interface that matches Protocol and
                                Registration.

  @retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in
                                Interface.
  @retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and
                                Registration.
  @retval EFI_INVALID_PARAMETER Interface is NULL.
                                Protocol is NULL.

**/
typedef
EFI_STATUS
(__cdecl *EFI_LOCATE_PROTOCOL)(
    EFI_GUID  *Protocol,
    void      *Registration  ,
   void      **Interface
  );

///
/// EFI Capsule Block Descriptor
///
typedef struct {
  ///
  /// Length in bytes of the data pointed to by DataBlock/ContinuationPointer.
  ///
  UINT64    Length;
  union {
    ///
    /// Physical address of the data block. This member of the union is
    /// used if Length is not equal to zero.
    ///
    EFI_PHYSICAL_ADDRESS    DataBlock;
    ///
    /// Physical address of another block of
    /// EFI_CAPSULE_BLOCK_DESCRIPTOR structures. This
    /// member of the union is used if Length is equal to zero. If
    /// ContinuationPointer is zero this entry represents the end of the list.
    ///
    EFI_PHYSICAL_ADDRESS    ContinuationPointer;
  } Union;
} EFI_CAPSULE_BLOCK_DESCRIPTOR;

///
/// EFI Capsule Header.
///
typedef struct {
  ///
  /// A GUID that defines the contents of a capsule.
  ///
  EFI_GUID    CapsuleGuid;
  ///
  /// The size of the capsule header. This may be larger than the size of
  /// the EFI_CAPSULE_HEADER since CapsuleGuid may imply
  /// extended header entries
  ///
  UINT32      HeaderSize;
  ///
  /// Bit-mapped list describing the capsule attributes. The Flag values
  /// of 0x0000 - 0xFFFF are defined by CapsuleGuid. Flag values
  /// of 0x10000 - 0xFFFFFFFF are defined by this specification
  ///
  UINT32      Flags;
  ///
  /// Size in bytes of the capsule (including capsule header).
  ///
  UINT32      CapsuleImageSize;
} EFI_CAPSULE_HEADER;

///
/// The EFI System Table entry must point to an array of capsules
/// that contain the same CapsuleGuid value. The array must be
/// prefixed by a UINT32 that represents the size of the array of capsules.
///
typedef struct {
  ///
  /// the size of the array of capsules.
  ///
  UINT32    CapsuleArrayNumber;
  ///
  /// Point to an array of capsules that contain the same CapsuleGuid value.
  ///
  void      *CapsulePtr[1];
} EFI_CAPSULE_TABLE;





/**
  Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended
  consumption, the firmware may process the capsule immediately. If the payload should persist
  across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must
  be passed into ResetSystem() and will cause the capsule to be processed by the firmware as
  part of the reset process.

  @param[in]  CapsuleHeaderArray Virtual pointer to an array of virtual pointers to the capsules
                                 being passed into update capsule.
  @param[in]  CapsuleCount       Number of pointers to EFI_CAPSULE_HEADER in
                                 CaspuleHeaderArray.
  @param[in]  ScatterGatherList  Physical pointer to a set of
                                 EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the
                                 location in physical memory of a set of capsules.

  @retval EFI_SUCCESS           Valid capsule was passed. If
                                CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the
                                capsule has been successfully processed by the firmware.
  @retval EFI_INVALID_PARAMETER CapsuleSize is NULL, or an incompatible set of flags were
                                set in the capsule header.
  @retval EFI_INVALID_PARAMETER CapsuleCount is 0.
  @retval EFI_DEVICE_ERROR      The capsule update was started, but failed due to a device error.
  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform.
  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
                                is compatible with this platform but is not capable of being submitted or processed
                                in runtime. The caller may resubmit the capsule prior to ExitBootServices().
  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
                                the capsule is compatible with this platform but there are insufficient resources to process.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_UPDATE_CAPSULE)(
   EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
   UINTN                  CapsuleCount,
   EFI_PHYSICAL_ADDRESS   ScatterGatherList   
  );

/**
  Returns if the capsule can be supported via UpdateCapsule().

  @param[in]   CapsuleHeaderArray  Virtual pointer to an array of virtual pointers to the capsules
                                   being passed into update capsule.
  @param[in]   CapsuleCount        Number of pointers to EFI_CAPSULE_HEADER in
                                   CaspuleHeaderArray.
  @param[out]  MaxiumCapsuleSize   On output the maximum size that UpdateCapsule() can
                                   support as an argument to UpdateCapsule() via
                                   CapsuleHeaderArray and ScatterGatherList.
  @param[out]  ResetType           Returns the type of reset required for the capsule update.

  @retval EFI_SUCCESS           Valid answer returned.
  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform, and
                                MaximumCapsuleSize and ResetType are undefined.
  @retval EFI_INVALID_PARAMETER MaximumCapsuleSize is NULL.
  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
                                is compatible with this platform but is not capable of being submitted or processed
                                in runtime. The caller may resubmit the capsule prior to ExitBootServices().
  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
                                the capsule is compatible with this platform but there are insufficient resources to process.
  @retval EFI_UNSUPPORTED       This call is not supported by this platform at the time the call is made.
                                The platform should describe this runtime service as unsupported at runtime
                                via an EFI_RT_PROPERTIES_TABLE configuration table.

**/
typedef
EFI_STATUS
(__cdecl *EFI_QUERY_CAPSULE_CAPABILITIES)(
    EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
    UINTN                  CapsuleCount,
   UINT64                 *MaximumCapsuleSize,
   EFI_RESET_TYPE         *ResetType
  );

/**
  Returns information about the EFI variables.

  @param[in]   Attributes                   Attributes bitmask to specify the type of variables on
                                            which to return information.
  @param[out]  MaximumVariableStorageSize   On output the maximum size of the storage space
                                            available for the EFI variables associated with the
                                            attributes specified.
  @param[out]  RemainingVariableStorageSize Returns the remaining size of the storage space
                                            available for the EFI variables associated with the
                                            attributes specified.
  @param[out]  MaximumVariableSize          Returns the maximum size of the individual EFI
                                            variables associated with the attributes specified.

  @retval EFI_SUCCESS                  Valid answer returned.
  @retval EFI_INVALID_PARAMETER        An invalid combination of attribute bits was supplied
  @retval EFI_UNSUPPORTED              The attribute is not supported on this platform, and the
                                       MaximumVariableStorageSize,
                                       RemainingVariableStorageSize, MaximumVariableSize
                                       are undefined.

**/
typedef
EFI_STATUS
(__cdecl *EFI_QUERY_VARIABLE_INFO)(
    UINT32            Attributes,
   UINT64            *MaximumVariableStorageSize,
   UINT64            *RemainingVariableStorageSize,
   UINT64            *MaximumVariableSize
  );

//
// Firmware should stop at a firmware user interface on next boot
//








//
// EFI Runtime Services Table
//



















///
/// EFI Runtime Services Table.
///
typedef struct {
  ///
  /// The table header for the EFI Runtime Services Table.
  ///
  EFI_TABLE_HEADER                  Hdr;

  //
  // Time Services
  //
  EFI_GET_TIME                      GetTime;
  EFI_SET_TIME                      SetTime;
  EFI_GET_WAKEUP_TIME               GetWakeupTime;
  EFI_SET_WAKEUP_TIME               SetWakeupTime;

  //
  // Virtual Memory Services
  //
  EFI_SET_VIRTUAL_ADDRESS_MAP       SetVirtualAddressMap;
  EFI_CONVERT_POINTER               ConvertPointer;

  //
  // Variable Services
  //
  EFI_GET_VARIABLE                  GetVariable;
  EFI_GET_NEXT_VARIABLE_NAME        GetNextVariableName;
  EFI_SET_VARIABLE                  SetVariable;

  //
  // Miscellaneous Services
  //
  EFI_GET_NEXT_HIGH_MONO_COUNT      GetNextHighMonotonicCount;
  EFI_RESET_SYSTEM                  ResetSystem;

  //
  // UEFI 2.0 Capsule Services
  //
  EFI_UPDATE_CAPSULE                UpdateCapsule;
  EFI_QUERY_CAPSULE_CAPABILITIES    QueryCapsuleCapabilities;

  //
  // Miscellaneous UEFI 2.0 Service
  //
  EFI_QUERY_VARIABLE_INFO           QueryVariableInfo;
} EFI_RUNTIME_SERVICES;




///
/// EFI Boot Services Table.
///
typedef struct {
  ///
  /// The table header for the EFI Boot Services Table.
  ///
  EFI_TABLE_HEADER                              Hdr;

  //
  // Task Priority Services
  //
  EFI_RAISE_TPL                                 RaiseTPL;
  EFI_RESTORE_TPL                               RestoreTPL;

  //
  // Memory Services
  //
  EFI_ALLOCATE_PAGES                            AllocatePages;
  EFI_FREE_PAGES                                FreePages;
  EFI_GET_MEMORY_MAP                            GetMemoryMap;
  EFI_ALLOCATE_POOL                             AllocatePool;
  EFI_FREE_POOL                                 FreePool;

  //
  // Event & Timer Services
  //
  EFI_CREATE_EVENT                              CreateEvent;
  EFI_SET_TIMER                                 SetTimer;
  EFI_WAIT_FOR_EVENT                            WaitForEvent;
  EFI_SIGNAL_EVENT                              SignalEvent;
  EFI_CLOSE_EVENT                               CloseEvent;
  EFI_CHECK_EVENT                               CheckEvent;

  //
  // Protocol Handler Services
  //
  EFI_INSTALL_PROTOCOL_INTERFACE                InstallProtocolInterface;
  EFI_REINSTALL_PROTOCOL_INTERFACE              ReinstallProtocolInterface;
  EFI_UNINSTALL_PROTOCOL_INTERFACE              UninstallProtocolInterface;
  EFI_HANDLE_PROTOCOL                           HandleProtocol;
  void                                          *Reserved;
  EFI_REGISTER_PROTOCOL_NOTIFY                  RegisterProtocolNotify;
  EFI_LOCATE_HANDLE                             LocateHandle;
  EFI_LOCATE_DEVICE_PATH                        LocateDevicePath;
  EFI_INSTALL_CONFIGURATION_TABLE               InstallConfigurationTable;

  //
  // Image Services
  //
  EFI_IMAGE_LOAD                                LoadImage;
  EFI_IMAGE_START                               StartImage;
  EFI_EXIT                                      Exit;
  EFI_IMAGE_UNLOAD                              UnloadImage;
  EFI_EXIT_BOOT_SERVICES                        ExitBootServices;

  //
  // Miscellaneous Services
  //
  EFI_GET_NEXT_MONOTONIC_COUNT                  GetNextMonotonicCount;
  EFI_STALL                                     Stall;
  EFI_SET_WATCHDOG_TIMER                        SetWatchdogTimer;

  //
  // DriverSupport Services
  //
  EFI_CONNECT_CONTROLLER                        ConnectController;
  EFI_DISCONNECT_CONTROLLER                     DisconnectController;

  //
  // Open and Close Protocol Services
  //
  EFI_OPEN_PROTOCOL                             OpenProtocol;
  EFI_CLOSE_PROTOCOL                            CloseProtocol;
  EFI_OPEN_PROTOCOL_INFORMATION                 OpenProtocolInformation;

  //
  // Library Services
  //
  EFI_PROTOCOLS_PER_HANDLE                      ProtocolsPerHandle;
  EFI_LOCATE_HANDLE_BUFFER                      LocateHandleBuffer;
  EFI_LOCATE_PROTOCOL                           LocateProtocol;
  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES      InstallMultipleProtocolInterfaces;
  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES    UninstallMultipleProtocolInterfaces;

  //
  // 32-bit CRC Services
  //
  EFI_CALCULATE_CRC32                           CalculateCrc32;

  //
  // Miscellaneous Services
  //
  EFI_COPY_MEM                                  CopyMem;
  EFI_SET_MEM                                   SetMem;
  EFI_CREATE_EVENT_EX                           CreateEventEx;
} EFI_BOOT_SERVICES;

///
/// Contains a set of GUID/pointer pairs comprised of the ConfigurationTable field in the
/// EFI System Table.
///
typedef struct {
  ///
  /// The 128-bit GUID value that uniquely identifies the system configuration table.
  ///
  EFI_GUID    VendorGuid;
  ///
  /// A pointer to the table associated with VendorGuid.
  ///
  void        *VendorTable;
} EFI_CONFIGURATION_TABLE;

///
/// EFI System Table
///
typedef struct {
  ///
  /// The table header for the EFI System Table.
  ///
  EFI_TABLE_HEADER                   Hdr;
  ///
  /// A pointer to a null terminated string that identifies the vendor
  /// that produces the system firmware for the platform.
  ///
  CHAR16                             *FirmwareVendor;
  ///
  /// A firmware vendor specific value that identifies the revision
  /// of the system firmware for the platform.
  ///
  UINT32                             FirmwareRevision;
  ///
  /// The handle for the active console input device. This handle must support
  /// EFI_SIMPLE_TEXT_INPUT_PROTOCOL and EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL. If
  /// there is no active console, these protocols must still be present.
  ///
  EFI_HANDLE                         ConsoleInHandle;
  ///
  /// A pointer to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL interface that is
  /// associated with ConsoleInHandle.
  ///
  EFI_SIMPLE_TEXT_INPUT_PROTOCOL     *ConIn;
  ///
  /// The handle for the active console output device. This handle must support the
  /// EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL. If there is no active console, these protocols
  /// must still be present.
  ///
  EFI_HANDLE                         ConsoleOutHandle;
  ///
  /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
  /// that is associated with ConsoleOutHandle.
  ///
  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL    *ConOut;
  ///
  /// The handle for the active standard error console device.
  /// This handle must support the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL. If there
  /// is no active console, this protocol must still be present.
  ///
  EFI_HANDLE                         StandardErrorHandle;
  ///
  /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
  /// that is associated with StandardErrorHandle.
  ///
  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL    *StdErr;
  ///
  /// A pointer to the EFI Runtime Services Table.
  ///
  EFI_RUNTIME_SERVICES               *RuntimeServices;
  ///
  /// A pointer to the EFI Boot Services Table.
  ///
  EFI_BOOT_SERVICES                  *BootServices;
  ///
  /// The number of system configuration tables in the buffer ConfigurationTable.
  ///
  UINTN                              NumberOfTableEntries;
  ///
  /// A pointer to the system configuration tables.
  /// The number of entries in the table is NumberOfTableEntries.
  ///
  EFI_CONFIGURATION_TABLE            *ConfigurationTable;
} EFI_SYSTEM_TABLE;

/**
  This is the declaration of an EFI image entry point. This entry point is
  the same for UEFI Applications, UEFI OS Loaders, and UEFI Drivers including
  both device drivers and bus drivers.

  @param[in]  ImageHandle       The firmware allocated handle for the UEFI image.
  @param[in]  SystemTable       A pointer to the EFI System Table.

  @retval EFI_SUCCESS           The operation completed successfully.
  @retval Others                An unexpected error occurred.
**/
typedef
EFI_STATUS
(__cdecl *EFI_IMAGE_ENTRY_POINT)(
    EFI_HANDLE                   ImageHandle,
    EFI_SYSTEM_TABLE             *SystemTable
  );

//
// EFI Load Option. This data structure describes format of UEFI boot option variables.
//
// NOTE: EFI Load Option is a byte packed buffer of variable length fields.
// The first two fields have fixed length. They are declared as members of the
// EFI_LOAD_OPTION structure. All the other fields are variable length fields.
// They are listed in the comment block below for reference purposes.
//
#pragma pack(1)
typedef struct _EFI_LOAD_OPTION {
  ///
  /// The attributes for this load option entry. All unused bits must be zero
  /// and are reserved by the UEFI specification for future growth.
  ///
  UINT32    Attributes;
  ///
  /// Length in bytes of the FilePathList. OptionalData starts at offset
  /// sizeof(UINT32) + sizeof(UINT16) + StrSize(Description) + FilePathListLength
  /// of the EFI_LOAD_OPTION descriptor.
  ///
  UINT16    FilePathListLength;
  ///
  /// The user readable description for the load option.
  /// This field ends with a Null character.
  ///
  // CHAR16                        Description[];
  ///
  /// A packed array of UEFI device paths. The first element of the array is a
  /// device path that describes the device and location of the Image for this
  /// load option. The FilePathList[0] is specific to the device type. Other
  /// device paths may optionally exist in the FilePathList, but their usage is
  /// OSV specific. Each element in the array is variable length, and ends at
  /// the device path end structure. Because the size of Description is
  /// arbitrary, this data structure is not guaranteed to be aligned on a
  /// natural boundary. This data structure may have to be copied to an aligned
  /// natural boundary before it is used.
  ///
  // EFI_DEVICE_PATH_PROTOCOL      FilePathList[];
  ///
  /// The remaining bytes in the load option descriptor are a binary data buffer
  /// that is passed to the loaded image. If the field is zero bytes long, a
  /// NULL pointer is passed to the loaded image. The number of bytes in
  /// OptionalData can be computed by subtracting the starting offset of
  /// OptionalData from total size in bytes of the EFI_LOAD_OPTION.
  ///
  // UINT8                         OptionalData[];
} EFI_LOAD_OPTION;
#pragma pack()

//
// EFI Load Options Attributes
//













///
/// EFI Boot Key Data
///
typedef union {
  struct {
    ///
    /// Indicates the revision of the EFI_KEY_OPTION structure. This revision level should be 0.
    ///
    UINT32    Revision       : 8;
    ///
    /// Either the left or right Shift keys must be pressed (1) or must not be pressed (0).
    ///
    UINT32    ShiftPressed   : 1;
    ///
    /// Either the left or right Control keys must be pressed (1) or must not be pressed (0).
    ///
    UINT32    ControlPressed : 1;
    ///
    /// Either the left or right Alt keys must be pressed (1) or must not be pressed (0).
    ///
    UINT32    AltPressed     : 1;
    ///
    /// Either the left or right Logo keys must be pressed (1) or must not be pressed (0).
    ///
    UINT32    LogoPressed    : 1;
    ///
    /// The Menu key must be pressed (1) or must not be pressed (0).
    ///
    UINT32    MenuPressed    : 1;
    ///
    /// The SysReq key must be pressed (1) or must not be pressed (0).
    ///
    UINT32    SysReqPressed  : 1;
    UINT32    Reserved       : 16;
    ///
    /// Specifies the actual number of entries in EFI_KEY_OPTION.Keys, from 0-3. If
    /// zero, then only the shift state is considered. If more than one, then the boot option will
    /// only be launched if all of the specified keys are pressed with the same shift state.
    ///
    UINT32    InputKeyCount  : 2;
  } Options;
  UINT32    PackedValue;
} EFI_BOOT_KEY_DATA;

///
/// EFI Key Option.
///
#pragma pack(1)
typedef struct {
  ///
  /// Specifies options about how the key will be processed.
  ///
  EFI_BOOT_KEY_DATA    KeyData;
  ///
  /// The CRC-32 which should match the CRC-32 of the entire EFI_LOAD_OPTION to
  /// which BootOption refers. If the CRC-32s do not match this value, then this key
  /// option is ignored.
  ///
  UINT32               BootOptionCrc;
  ///
  /// The Boot#### option which will be invoked if this key is pressed and the boot option
  /// is active (LOAD_OPTION_ACTIVE is set).
  ///
  UINT16               BootOption;
  ///
  /// The key codes to compare against those returned by the
  /// EFI_SIMPLE_TEXT_INPUT and EFI_SIMPLE_TEXT_INPUT_EX protocols.
  /// The number of key codes (0-3) is specified by the EFI_KEY_CODE_COUNT field in KeyOptions.
  ///
  // EFI_INPUT_KEY      Keys[];
} EFI_KEY_OPTION;
#pragma pack()

//
// EFI File location to boot from on removable media devices
//









  

#line 2266 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"

  










#line 2279 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 2280 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"

//
// The directory within the active EFI System Partition defined for delivery of capsule to firmware
//


#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiPxe.h"
/** @file
  This header file contains all of the PXE type definitions,
  structure prototypes, global variables and constants that
  are needed for porting PXE to EFI.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  32/64-bit PXE specification:
  alpha-4, 99-Dec-17.

**/




#pragma pack(1)







///
/// UNDI ROM ID and devive ID signature.
///


///
/// BUS ROM ID signatures.
///































typedef void    PXE_VOID;
typedef UINT8   PXE_UINT8;
typedef UINT16  PXE_UINT16;
typedef UINT32  PXE_UINT32;
typedef UINTN   PXE_UINTN;

///
/// Typedef unsigned long PXE_UINT64.
///
typedef UINT64 PXE_UINT64;

typedef PXE_UINT8 PXE_BOOL;



typedef PXE_UINT16 PXE_OPCODE;

///
/// Return UNDI operational state.
///


///
/// Change UNDI operational state from Stopped to Started.
///


///
/// Change UNDI operational state from Started to Stopped.
///


///
/// Get UNDI initialization information.
///


///
/// Get NIC configuration information.
///


///
/// Changed UNDI operational state from Started to Initialized.
///


///
/// Re-initialize the NIC H/W.
///


///
/// Change the UNDI operational state from Initialized to Started.
///


///
/// Read & change state of external interrupt enables.
///


///
/// Read & change state of packet receive filters.
///


///
/// Read & change station MAC address.
///


///
/// Read traffic statistics.
///


///
/// Convert multicast IP address to multicast MAC address.
///


///
/// Read or change non-volatile storage on the NIC.
///


///
/// Get & clear interrupt status.
///


///
/// Fill media header in packet for transmit.
///


///
/// Transmit packet(s).
///


///
/// Receive packet.
///


///
/// Last valid PXE UNDI OpCode number.
///


typedef PXE_UINT16 PXE_OPFLAGS;



//
// //////////////////////////////////////
// UNDI Get State
//
// No OpFlags

////////////////////////////////////////
// UNDI Start
//
// No OpFlags

////////////////////////////////////////
// UNDI Stop
//
// No OpFlags

////////////////////////////////////////
// UNDI Get Init Info
//
// No Opflags

////////////////////////////////////////
// UNDI Get Config Info
//
// No Opflags

///
/// UNDI Initialize
///




///
///
/// UNDI Reset
///



///
/// UNDI Shutdown.
///
/// No OpFlags.

///
/// UNDI Interrupt Enables.
///
///
/// Select whether to enable or disable external interrupt signals.
/// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
///





///
/// Enable receive interrupts.  An external interrupt will be generated
/// after a complete non-error packet has been received.
///


///
/// Enable transmit interrupts.  An external interrupt will be generated
/// after a complete non-error packet has been transmitted.
///


///
/// Enable command interrupts.  An external interrupt will be generated
/// when command execution stops.
///


///
/// Generate software interrupt.  Setting this bit generates an external
/// interrupt, if it is supported by the hardware.
///


///
/// UNDI Receive Filters.
///
///
/// Select whether to enable or disable receive filters.
/// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
///





///
/// To reset the contents of the multicast MAC address filter list,
/// set this OpFlag:
///


///
/// Enable unicast packet receiving.  Packets sent to the current station
/// MAC address will be received.
///


///
/// Enable broadcast packet receiving.  Packets sent to the broadcast
/// MAC address will be received.
///


///
/// Enable filtered multicast packet receiving.  Packets sent to any
/// of the multicast MAC addresses in the multicast MAC address filter
/// list will be received.  If the filter list is empty, no multicast
///


///
/// Enable promiscuous packet receiving.  All packets will be received.
///


///
/// Enable promiscuous multicast packet receiving.  All multicast
/// packets will be received.
///


///
/// UNDI Station Address.
///




///
/// UNDI Statistics.
///



///
/// UNDI MCast IP to MAC.
///
///
/// Identify the type of IP address in the CPB.
///




///
/// UNDI NvData.
///
///
/// Select the type of non-volatile data operation.
///




///
/// UNDI Get Status.
///
///
/// Return current interrupt status.  This will also clear any interrupts
/// that are currently set.  This can be used in a polling routine.  The
/// interrupt flags are still set and cleared even when the interrupts
/// are disabled.
///


///
/// Return list of transmitted buffers for recycling.  Transmit buffers
/// must not be changed or unallocated until they have recycled.  After
/// issuing a transmit command, wait for a transmit complete interrupt.
/// When a transmit complete interrupt is received, read the transmitted
/// buffers.  Do not plan on getting one buffer per interrupt.  Some
/// NICs and UNDIs may transmit multiple buffers per interrupt.
///


///
/// Return current media status.
///


///
/// UNDI Fill Header.
///




///
/// UNDI Transmit.
///
///
/// S/W UNDI only.  Return after the packet has been transmitted.  A
/// transmit complete interrupt will still be generated and the transmit
/// buffer will have to be recycled.
///








///
/// UNDI Receive.
///
/// No OpFlags.
///

///
/// PXE STATFLAGS.
///
typedef PXE_UINT16 PXE_STATFLAGS;



///
/// Common StatFlags that can be returned by all commands.
///
///
/// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
/// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
/// that support command queuing.
///





///
/// UNDI Get State.
///





///
/// UNDI Start.
///
/// No additional StatFlags.
///

///
/// UNDI Get Init Info.
///








///
/// UNDI Initialize.
///


///
/// UNDI Reset.
///


///
/// UNDI Shutdown.
///
/// No additional StatFlags.

///
/// UNDI Interrupt Enables.
///
///
/// If set, receive interrupts are enabled.
///


///
/// If set, transmit interrupts are enabled.
///


///
/// If set, command interrupts are enabled.
///


///
/// UNDI Receive Filters.
///

///
/// If set, unicast packets will be received.
///


///
/// If set, broadcast packets will be received.
///


///
/// If set, multicast packets that match up with the multicast address
/// filter list will be received.
///


///
/// If set, all packets will be received.
///


///
/// If set, all multicast packets will be received.
///


///
/// UNDI Station Address.
///
/// No additional StatFlags.
///

///
/// UNDI Statistics.
///
/// No additional StatFlags.
///

///
//// UNDI MCast IP to MAC.
////
//// No additional StatFlags.

///
/// UNDI NvData.
///
/// No additional StatFlags.
///

///
/// UNDI Get Status.
///

///
/// Use to determine if an interrupt has occurred.
///



///
/// If set, at least one receive interrupt occurred.
///


///
/// If set, at least one transmit interrupt occurred.
///


///
/// If set, at least one command interrupt occurred.
///


///
/// If set, at least one software interrupt occurred.
///


///
/// This flag is set if the transmitted buffer queue is empty.  This flag
/// will be set if all transmitted buffer addresses get written into the DB.
///


///
/// This flag is set if no transmitted buffer addresses were written
/// into the DB.  (This could be because DBsize was too small.)
///


///
/// This flag is set if there is no media detected.
///


///
/// UNDI Fill Header.
///
/// No additional StatFlags.
///

///
/// UNDI Transmit.
///
/// No additional StatFlags.

///
/// UNDI Receive
/// .

///
/// No additional StatFlags.
///
typedef PXE_UINT16 PXE_STATCODE;



///
/// Common StatCodes returned by all UNDI commands, UNDI protocol functions
/// and BC protocol functions.
///






















typedef PXE_UINT16 PXE_IFNUM;

///
/// This interface number must be passed to the S/W UNDI Start command.
///


///
/// This interface number is returned by the S/W UNDI Get State and
/// Start commands if information in the CDB, CPB or DB is invalid.
///


typedef PXE_UINT16 PXE_CONTROL;

///
/// Setting this flag directs the UNDI to queue this command for later
/// execution if the UNDI is busy and it supports command queuing.
/// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
/// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL
/// error is returned.
///


///
/// These two bit values are used to determine if there are more UNDI
/// CDB structures following this one.  If the link bit is set, there
/// must be a CDB structure following this one.  Execution will start
/// on the next CDB structure as soon as this one completes successfully.
/// If an error is generated by this command, execution will stop.
///



typedef PXE_UINT8 PXE_FRAME_TYPE;










typedef PXE_UINT32 PXE_IPV4;

typedef PXE_UINT32 PXE_IPV6[4];


typedef PXE_UINT8 PXE_MAC_ADDR[32];

typedef PXE_UINT8 PXE_IFTYPE;
typedef UINT16    PXE_MEDIA_PROTOCOL;

///
/// This information is from the ARP section of RFC 1700.
///
///     1 Ethernet (10Mb)                                    [JBP]
///     2 Experimental Ethernet (3Mb)                        [JBP]
///     3 Amateur Radio AX.25                                [PXK]
///     4 Proteon ProNET Token Ring                          [JBP]
///     5 Chaos                                              [GXP]
///     6 IEEE 802 Networks                                  [JBP]
///     7 ARCNET                                             [JBP]
///     8 Hyperchannel                                       [JBP]
///     9 Lanstar                                             [TU]
///    10 Autonet Short Address                             [MXB1]
///    11 LocalTalk                                         [JKR1]
///    12 LocalNet (IBM* PCNet or SYTEK* LocalNET)           [JXM]
///    13 Ultra link                                        [RXD2]
///    14 SMDS                                              [GXC1]
///    15 Frame Relay                                        [AGM]
///    16 Asynchronous Transmission Mode (ATM)              [JXB2]
///    17 HDLC                                               [JBP]
///    18 Fibre Channel                            [Yakov Rekhter]
///    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
///    20 Serial Line                                        [JBP]
///    21 Asynchronous Transmission Mode (ATM)              [MXB1]
///
/// * Other names and brands may be claimed as the property of others.
///




typedef struct s_pxe_hw_undi {
  PXE_UINT32    Signature;      ///< PXE_ROMID_SIGNATURE.
  PXE_UINT8     Len;            ///< sizeof(PXE_HW_UNDI).
  PXE_UINT8     Fudge;          ///< makes 8-bit cksum equal zero.
  PXE_UINT8     Rev;            ///< PXE_ROMID_REV.
  PXE_UINT8     IFcnt;          ///< physical connector count lower byte.
  PXE_UINT8     MajorVer;       ///< PXE_ROMID_MAJORVER.
  PXE_UINT8     MinorVer;       ///< PXE_ROMID_MINORVER.
  PXE_UINT8     IFcntExt;       ///< physical connector count upper byte.
  PXE_UINT8     reserved;       ///< zero, not used.
  PXE_UINT32    Implementation; ///< implementation flags.
  ///< reserved             ///< vendor use.
  ///< UINT32 Status;       ///< status port.
  ///< UINT32 Command;      ///< command port.
  ///< UINT64 CDBaddr;      ///< CDB address port.
  ///<
} PXE_HW_UNDI;

///
/// Status port bit definitions.
///

///
/// UNDI operation state.
///






///
/// If set, last command failed.
///


///
/// If set, identifies enabled receive filters.
///






///
/// If set, identifies enabled external interrupts.
///





///
/// If set, identifies pending interrupts.
///





///
/// Command port definitions.
///

///
/// If set, CDB identified in CDBaddr port is given to UNDI.
/// If not set, other bits in this word will be processed.
///



///
/// Use these to enable/disable receive filters.
///






///
/// Use these to enable/disable external interrupts.
///





///
/// Use these to clear pending external interrupts.
///





typedef struct s_pxe_sw_undi {
  PXE_UINT32    Signature;      ///< PXE_ROMID_SIGNATURE.
  PXE_UINT8     Len;            ///< sizeof(PXE_SW_UNDI).
  PXE_UINT8     Fudge;          ///< makes 8-bit cksum zero.
  PXE_UINT8     Rev;            ///< PXE_ROMID_REV.
  PXE_UINT8     IFcnt;          ///< physical connector count lower byte.
  PXE_UINT8     MajorVer;       ///< PXE_ROMID_MAJORVER.
  PXE_UINT8     MinorVer;       ///< PXE_ROMID_MINORVER.
  PXE_UINT8     IFcntExt;       ///< physical connector count upper byte.
  PXE_UINT8     reserved1;      ///< zero, not used.
  PXE_UINT32    Implementation; ///< Implementation flags.
  PXE_UINT64    EntryPoint;     ///< API entry point.
  PXE_UINT8     reserved2[3];   ///< zero, not used.
  PXE_UINT8     BusCnt;         ///< number of bustypes supported.
  PXE_UINT32    BusType[1];     ///< list of supported bustypes.
} PXE_SW_UNDI;

typedef union u_pxe_undi {
  PXE_HW_UNDI    hw;
  PXE_SW_UNDI    sw;
} PXE_UNDI;

///
/// Signature of !PXE structure.
///


///
/// !PXE structure format revision
/// .


///
/// UNDI command interface revision.  These are the values that get sent
/// in option 94 (Client Network Interface Identifier) in the DHCP Discover
/// and PXE Boot Server Request packets.
///



///
/// Implementation flags.
///























typedef struct s_pxe_cdb {
  PXE_OPCODE       OpCode;
  PXE_OPFLAGS      OpFlags;
  PXE_UINT16       CPBsize;
  PXE_UINT16       DBsize;
  PXE_UINT64       CPBaddr;
  PXE_UINT64       DBaddr;
  PXE_STATCODE     StatCode;
  PXE_STATFLAGS    StatFlags;
  PXE_UINT16       IFnum;
  PXE_CONTROL      Control;
} PXE_CDB;

typedef union u_pxe_ip_addr {
  PXE_IPV6    IPv6;
  PXE_IPV4    IPv4;
} PXE_IP_ADDR;

typedef union pxe_device {
  ///
  /// PCI and PC Card NICs are both identified using bus, device
  /// and function numbers.  For PC Card, this may require PC
  /// Card services to be loaded in the BIOS or preboot
  /// environment.
  ///
  struct {
    ///
    /// See S/W UNDI ROMID structure definition for PCI and
    /// PCC BusType definitions.
    ///
    PXE_UINT32    BusType;

    ///
    /// Bus, device & function numbers that locate this device.
    ///
    PXE_UINT16    Bus;
    PXE_UINT8     Device;
    PXE_UINT8     Function;
  } PCI, PCC;
} PXE_DEVICE;

///
/// cpb and db definitions
///





typedef struct s_pxe_cpb_start_30 {
  ///
  /// PXE_VOID Delay(UINTN microseconds);
  ///
  /// UNDI will never request a delay smaller than 10 microseconds
  /// and will always request delays in increments of 10 microseconds.
  /// The Delay() CallBack routine must delay between n and n + 10
  /// microseconds before returning control to the UNDI.
  ///
  /// This field cannot be set to zero.
  ///
  UINT64    Delay;

  ///
  /// PXE_VOID Block(UINT32 enable);
  ///
  /// UNDI may need to block multi-threaded/multi-processor access to
  /// critical code sections when programming or accessing the network
  /// device.  To this end, a blocking service is needed by the UNDI.
  /// When UNDI needs a block, it will call Block() passing a non-zero
  /// value.  When UNDI no longer needs a block, it will call Block()
  /// with a zero value.  When called, if the Block() is already enabled,
  /// do not return control to the UNDI until the previous Block() is
  /// disabled.
  ///
  /// This field cannot be set to zero.
  ///
  UINT64    Block;

  ///
  /// PXE_VOID Virt2Phys(UINT64 virtual, UINT64 physical_ptr);
  ///
  /// UNDI will pass the virtual address of a buffer and the virtual
  /// address of a 64-bit physical buffer.  Convert the virtual address
  /// to a physical address and write the result to the physical address
  /// buffer.  If virtual and physical addresses are the same, just
  /// copy the virtual address to the physical address buffer.
  ///
  /// This field can be set to zero if virtual and physical addresses
  /// are equal.
  ///
  UINT64    Virt2Phys;
  ///
  /// PXE_VOID Mem_IO(UINT8 read_write, UINT8 len, UINT64 port,
  ///              UINT64 buf_addr);
  ///
  /// UNDI will read or write the device io space using this call back
  /// function. It passes the number of bytes as the len parameter and it
  /// will be either 1,2,4 or 8.
  ///
  /// This field can not be set to zero.
  ///
  UINT64    Mem_IO;
} PXE_CPB_START_30;

typedef struct s_pxe_cpb_start_31 {
  ///
  /// PXE_VOID Delay(UINT64 UnqId, UINTN microseconds);
  ///
  /// UNDI will never request a delay smaller than 10 microseconds
  /// and will always request delays in increments of 10 microseconds.
  /// The Delay() CallBack routine must delay between n and n + 10
  /// microseconds before returning control to the UNDI.
  ///
  /// This field cannot be set to zero.
  ///
  UINT64    Delay;

  ///
  /// PXE_VOID Block(UINT64 unq_id, UINT32 enable);
  ///
  /// UNDI may need to block multi-threaded/multi-processor access to
  /// critical code sections when programming or accessing the network
  /// device.  To this end, a blocking service is needed by the UNDI.
  /// When UNDI needs a block, it will call Block() passing a non-zero
  /// value.  When UNDI no longer needs a block, it will call Block()
  /// with a zero value.  When called, if the Block() is already enabled,
  /// do not return control to the UNDI until the previous Block() is
  /// disabled.
  ///
  /// This field cannot be set to zero.
  ///
  UINT64    Block;

  ///
  /// PXE_VOID Virt2Phys(UINT64 UnqId, UINT64 virtual, UINT64 physical_ptr);
  ///
  /// UNDI will pass the virtual address of a buffer and the virtual
  /// address of a 64-bit physical buffer.  Convert the virtual address
  /// to a physical address and write the result to the physical address
  /// buffer.  If virtual and physical addresses are the same, just
  /// copy the virtual address to the physical address buffer.
  ///
  /// This field can be set to zero if virtual and physical addresses
  /// are equal.
  ///
  UINT64    Virt2Phys;
  ///
  /// PXE_VOID Mem_IO(UINT64 UnqId, UINT8 read_write, UINT8 len, UINT64 port,
  ///              UINT64 buf_addr);
  ///
  /// UNDI will read or write the device io space using this call back
  /// function. It passes the number of bytes as the len parameter and it
  /// will be either 1,2,4 or 8.
  ///
  /// This field can not be set to zero.
  ///
  UINT64    Mem_IO;
  ///
  /// PXE_VOID Map_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
  ///                 UINT32 Direction, UINT64 mapped_addr);
  ///
  /// UNDI will pass the virtual address of a buffer, direction of the data
  /// flow from/to the mapped buffer (the constants are defined below)
  /// and a place holder (pointer) for the mapped address.
  /// This call will Map the given address to a physical DMA address and write
  /// the result to the mapped_addr pointer.  If there is no need to
  /// map the given address to a lower address (i.e. the given address is
  /// associated with a physical address that is already compatible to be
  /// used with the DMA, it converts the given virtual address to it's
  /// physical address and write that in the mapped address pointer.
  ///
  /// This field can be set to zero if there is no mapping service available.
  ///
  UINT64    Map_Mem;

  ///
  /// PXE_VOID UnMap_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
  ///            UINT32 Direction, UINT64 mapped_addr);
  ///
  /// UNDI will pass the virtual and mapped addresses of a buffer.
  /// This call will un map the given address.
  ///
  /// This field can be set to zero if there is no unmapping service available.
  ///
  UINT64    UnMap_Mem;

  ///
  /// PXE_VOID Sync_Mem(UINT64 unq_id, UINT64 virtual,
  ///            UINT32 size, UINT32 Direction, UINT64 mapped_addr);
  ///
  /// UNDI will pass the virtual and mapped addresses of a buffer.
  /// This call will synchronize the contents of both the virtual and mapped.
  /// buffers for the given Direction.
  ///
  /// This field can be set to zero if there is no service available.
  ///
  UINT64    Sync_Mem;

  ///
  /// protocol driver can provide anything for this Unique_ID, UNDI remembers
  /// that as just a 64bit value associated to the interface specified by
  /// the ifnum and gives it back as a parameter to all the call-back routines
  /// when calling for that interface!
  ///
  UINT64    Unique_ID;
} PXE_CPB_START_31;












typedef struct s_pxe_db_get_init_info {
  ///
  /// Minimum length of locked memory buffer that must be given to
  /// the Initialize command. Giving UNDI more memory will generally
  /// give better performance.
  ///
  /// If MemoryRequired is zero, the UNDI does not need and will not
  /// use system memory to receive and transmit packets.
  ///
  PXE_UINT32    MemoryRequired;

  ///
  /// Maximum frame data length for Tx/Rx excluding the media header.
  ///
  PXE_UINT32    FrameDataLen;

  ///
  /// Supported link speeds are in units of mega bits.  Common ethernet
  /// values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
  /// filled.
  ///
  PXE_UINT32    LinkSpeeds[4];

  ///
  /// Number of non-volatile storage items.
  ///
  PXE_UINT32    NvCount;

  ///
  /// Width of non-volatile storage item in bytes.  0, 1, 2 or 4
  ///
  PXE_UINT16    NvWidth;

  ///
  /// Media header length.  This is the typical media header length for
  /// this UNDI.  This information is needed when allocating receive
  /// and transmit buffers.
  ///
  PXE_UINT16    MediaHeaderLen;

  ///
  /// Number of bytes in the NIC hardware (MAC) address.
  ///
  PXE_UINT16    HWaddrLen;

  ///
  /// Maximum number of multicast MAC addresses in the multicast
  /// MAC address filter list.
  ///
  PXE_UINT16    MCastFilterCnt;

  ///
  /// Default number and size of transmit and receive buffers that will
  /// be allocated by the UNDI.  If MemoryRequired is non-zero, this
  /// allocation will come out of the memory buffer given to the Initialize
  /// command.  If MemoryRequired is zero, this allocation will come out of
  /// memory on the NIC.
  ///
  PXE_UINT16    TxBufCnt;
  PXE_UINT16    TxBufSize;
  PXE_UINT16    RxBufCnt;
  PXE_UINT16    RxBufSize;

  ///
  /// Hardware interface types defined in the Assigned Numbers RFC
  /// and used in DHCP and ARP packets.
  /// See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
  ///
  PXE_UINT8     IFtype;

  ///
  /// Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
  ///
  PXE_UINT8     SupportedDuplexModes;

  ///
  /// Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
  ///
  PXE_UINT8     SupportedLoopBackModes;
} PXE_DB_GET_INIT_INFO;












typedef struct s_pxe_pci_config_info {
  ///
  /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
  /// For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
  ///
  UINT32    BusType;

  ///
  /// This identifies the PCI network device that this UNDI interface.
  /// is bound to.
  ///
  UINT16    Bus;
  UINT8     Device;
  UINT8     Function;

  ///
  /// This is a copy of the PCI configuration space for this
  /// network device.
  ///
  union {
    UINT8     Byte[256];
    UINT16    Word[128];
    UINT32    Dword[64];
  } Config;
} PXE_PCI_CONFIG_INFO;

typedef struct s_pxe_pcc_config_info {
  ///
  /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
  /// For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
  ///
  PXE_UINT32    BusType;

  ///
  /// This identifies the PCC network device that this UNDI interface
  /// is bound to.
  ///
  PXE_UINT16    Bus;
  PXE_UINT8     Device;
  PXE_UINT8     Function;

  ///
  /// This is a copy of the PCC configuration space for this
  /// network device.
  ///
  union {
    PXE_UINT8     Byte[256];
    PXE_UINT16    Word[128];
    PXE_UINT32    Dword[64];
  } Config;
} PXE_PCC_CONFIG_INFO;

typedef union u_pxe_db_get_config_info {
  PXE_PCI_CONFIG_INFO    pci;
  PXE_PCC_CONFIG_INFO    pcc;
} PXE_DB_GET_CONFIG_INFO;

typedef struct s_pxe_cpb_initialize {
  ///
  /// Address of first (lowest) byte of the memory buffer.  This buffer must
  /// be in contiguous physical memory and cannot be swapped out.  The UNDI
  /// will be using this for transmit and receive buffering.
  ///
  PXE_UINT64    MemoryAddr;

  ///
  /// MemoryLength must be greater than or equal to MemoryRequired
  /// returned by the Get Init Info command.
  ///
  PXE_UINT32    MemoryLength;

  ///
  /// Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
  /// and 1000.  Setting a value of zero will auto-detect and/or use the
  /// default link speed (operation depends on UNDI/NIC functionality).
  ///
  PXE_UINT32    LinkSpeed;

  ///
  /// Suggested number and size of receive and transmit buffers to
  /// allocate.  If MemoryAddr and MemoryLength are non-zero, this
  /// allocation comes out of the supplied memory buffer.  If MemoryAddr
  /// and MemoryLength are zero, this allocation comes out of memory
  /// on the NIC.
  ///
  /// If these fields are set to zero, the UNDI will allocate buffer
  /// counts and sizes as it sees fit.
  ///
  PXE_UINT16    TxBufCnt;
  PXE_UINT16    TxBufSize;
  PXE_UINT16    RxBufCnt;
  PXE_UINT16    RxBufSize;

  ///
  /// The following configuration parameters are optional and must be zero
  /// to use the default values.
  ///
  PXE_UINT8     DuplexMode;

  PXE_UINT8     LoopBackMode;
} PXE_CPB_INITIALIZE;











typedef struct s_pxe_db_initialize {
  ///
  /// Actual amount of memory used from the supplied memory buffer.  This
  /// may be less that the amount of memory suppllied and may be zero if
  /// the UNDI and network device do not use external memory buffers.
  ///
  /// Memory used by the UNDI and network device is allocated from the
  /// lowest memory buffer address.
  ///
  PXE_UINT32    MemoryUsed;

  ///
  /// Actual number and size of receive and transmit buffers that were
  /// allocated.
  ///
  PXE_UINT16    TxBufCnt;
  PXE_UINT16    TxBufSize;
  PXE_UINT16    RxBufCnt;
  PXE_UINT16    RxBufSize;
} PXE_DB_INITIALIZE;

typedef struct s_pxe_cpb_receive_filters {
  ///
  /// List of multicast MAC addresses.  This list, if present, will
  /// replace the existing multicast MAC address filter list.
  ///
  PXE_MAC_ADDR    MCastList[8];
} PXE_CPB_RECEIVE_FILTERS;

typedef struct s_pxe_db_receive_filters {
  ///
  /// Filtered multicast MAC address list.
  ///
  PXE_MAC_ADDR    MCastList[8];
} PXE_DB_RECEIVE_FILTERS;

typedef struct s_pxe_cpb_station_address {
  ///
  /// If supplied and supported, the current station MAC address
  /// will be changed.
  ///
  PXE_MAC_ADDR    StationAddr;
} PXE_CPB_STATION_ADDRESS;

typedef struct s_pxe_dpb_station_address {
  ///
  /// Current station MAC address.
  ///
  PXE_MAC_ADDR    StationAddr;

  ///
  /// Station broadcast MAC address.
  ///
  PXE_MAC_ADDR    BroadcastAddr;

  ///
  /// Permanent station MAC address.
  ///
  PXE_MAC_ADDR    PermanentAddr;
} PXE_DB_STATION_ADDRESS;

typedef struct s_pxe_db_statistics {
  ///
  /// Bit field identifying what statistic data is collected by the
  /// UNDI/NIC.
  /// If bit 0x00 is set, Data[0x00] is collected.
  /// If bit 0x01 is set, Data[0x01] is collected.
  /// If bit 0x20 is set, Data[0x20] is collected.
  /// If bit 0x21 is set, Data[0x21] is collected.
  /// Etc.
  ///
  PXE_UINT64    Supported;

  ///
  /// Statistic data.
  ///
  PXE_UINT64    Data[64];
} PXE_DB_STATISTICS;

///
/// Total number of frames received.  Includes frames with errors and
/// dropped frames.
///


///
/// Number of valid frames received and copied into receive buffers.
///


///
/// Number of frames below the minimum length for the media.
/// This would be <64 for ethernet.
///


///
/// Number of frames longer than the maxminum length for the
/// media.  This would be >1500 for ethernet.
///


///
/// Valid frames that were dropped because receive buffers were full.
///


///
/// Number of valid unicast frames received and not dropped.
///


///
/// Number of valid broadcast frames received and not dropped.
///


///
/// Number of valid mutlicast frames received and not dropped.
///


///
/// Number of frames w/ CRC or alignment errors.
///


///
/// Total number of bytes received.  Includes frames with errors
/// and dropped frames.
///


///
/// Transmit statistics.
///











///
/// Number of collisions detection on this subnet.
///


///
/// Number of frames destined for unsupported protocol.
///


///
/// Number of valid frames received that were duplicated.
///


///
/// Number of encrypted frames received that failed to decrypt.
///


///
/// Number of frames that failed to transmit after exceeding the retry limit.
///


///
/// Number of frames transmitted successfully after more than one attempt.
///


typedef struct s_pxe_cpb_mcast_ip_to_mac {
  ///
  /// Multicast IP address to be converted to multicast MAC address.
  ///
  PXE_IP_ADDR    IP;
} PXE_CPB_MCAST_IP_TO_MAC;

typedef struct s_pxe_db_mcast_ip_to_mac {
  ///
  /// Multicast MAC address.
  ///
  PXE_MAC_ADDR    MAC;
} PXE_DB_MCAST_IP_TO_MAC;

typedef struct s_pxe_cpb_nvdata_sparse {
  ///
  /// NvData item list.  Only items in this list will be updated.
  ///
  struct {
    ///
    ///  Non-volatile storage address to be changed.
    ///
    PXE_UINT32    Addr;

    ///
    /// Data item to write into above storage address.
    ///
    union {
      PXE_UINT8     Byte;
      PXE_UINT16    Word;
      PXE_UINT32    Dword;
    } Data;
  } Item[128];
} PXE_CPB_NVDATA_SPARSE;

///
/// When using bulk update, the size of the CPB structure must be
/// the same size as the non-volatile NIC storage.
///
typedef union u_pxe_cpb_nvdata_bulk {
  ///
  /// Array of byte-wide data items.
  ///
  PXE_UINT8     Byte[128 << 2];

  ///
  /// Array of word-wide data items.
  ///
  PXE_UINT16    Word[128 << 1];

  ///
  /// Array of dword-wide data items.
  ///
  PXE_UINT32    Dword[128];
} PXE_CPB_NVDATA_BULK;

typedef struct s_pxe_db_nvdata {
  ///
  /// Arrays of data items from non-volatile storage.
  ///
  union {
    ///
    /// Array of byte-wide data items.
    ///
    PXE_UINT8     Byte[128 << 2];

    ///
    /// Array of word-wide data items.
    ///
    PXE_UINT16    Word[128 << 1];

    ///
    /// Array of dword-wide data items.
    ///
    PXE_UINT32    Dword[128];
  } Data;
} PXE_DB_NVDATA;

typedef struct s_pxe_db_get_status {
  ///
  /// Length of next receive frame (header + data).  If this is zero,
  /// there is no next receive frame available.
  ///
  PXE_UINT32    RxFrameLen;

  ///
  /// Reserved, set to zero.
  ///
  PXE_UINT32    reserved;

  ///
  ///  Addresses of transmitted buffers that need to be recycled.
  ///
  PXE_UINT64    TxBuffer[32];
} PXE_DB_GET_STATUS;

typedef struct s_pxe_cpb_fill_header {
  ///
  /// Source and destination MAC addresses.  These will be copied into
  /// the media header without doing byte swapping.
  ///
  PXE_MAC_ADDR    SrcAddr;
  PXE_MAC_ADDR    DestAddr;

  ///
  /// Address of first byte of media header.  The first byte of packet data
  /// follows the last byte of the media header.
  ///
  PXE_UINT64      MediaHeader;

  ///
  /// Length of packet data in bytes (not including the media header).
  ///
  PXE_UINT32      PacketLen;

  ///
  /// Protocol type.  This will be copied into the media header without
  /// doing byte swapping.  Protocol type numbers can be obtained from
  /// the Assigned Numbers RFC 1700.
  ///
  PXE_UINT16      Protocol;

  ///
  /// Length of the media header in bytes.
  ///
  PXE_UINT16      MediaHeaderLen;
} PXE_CPB_FILL_HEADER;





typedef struct s_pxe_cpb_fill_header_fragmented {
  ///
  /// Source and destination MAC addresses.  These will be copied into
  /// the media header without doing byte swapping.
  ///
  PXE_MAC_ADDR          SrcAddr;
  PXE_MAC_ADDR          DestAddr;

  ///
  /// Length of packet data in bytes (not including the media header).
  ///
  PXE_UINT32            PacketLen;

  ///
  /// Protocol type.  This will be copied into the media header without
  /// doing byte swapping.  Protocol type numbers can be obtained from
  /// the Assigned Numbers RFC 1700.
  ///
  PXE_MEDIA_PROTOCOL    Protocol;

  ///
  /// Length of the media header in bytes.
  ///
  PXE_UINT16            MediaHeaderLen;

  ///
  /// Number of packet fragment descriptors.
  ///
  PXE_UINT16            FragCnt;

  ///
  /// Reserved, must be set to zero.
  ///
  PXE_UINT16            reserved;

  ///
  /// Array of packet fragment descriptors.  The first byte of the media
  /// header is the first byte of the first fragment.
  ///
  struct {
    ///
    /// Address of this packet fragment.
    ///
    PXE_UINT64    FragAddr;

    ///
    /// Length of this packet fragment.
    ///
    PXE_UINT32    FragLen;

    ///
    /// Reserved, must be set to zero.
    ///
    PXE_UINT32    reserved;
  } FragDesc[16];
} PXE_CPB_FILL_HEADER_FRAGMENTED;

typedef struct s_pxe_cpb_transmit {
  ///
  /// Address of first byte of frame buffer.  This is also the first byte
  /// of the media header.
  ///
  PXE_UINT64    FrameAddr;

  ///
  /// Length of the data portion of the frame buffer in bytes.  Do not
  /// include the length of the media header.
  ///
  PXE_UINT32    DataLen;

  ///
  /// Length of the media header in bytes.
  ///
  PXE_UINT16    MediaheaderLen;

  ///
  /// Reserved, must be zero.
  ///
  PXE_UINT16    reserved;
} PXE_CPB_TRANSMIT;

typedef struct s_pxe_cpb_transmit_fragments {
  ///
  /// Length of packet data in bytes (not including the media header).
  ///
  PXE_UINT32    FrameLen;

  ///
  /// Length of the media header in bytes.
  ///
  PXE_UINT16    MediaheaderLen;

  ///
  /// Number of packet fragment descriptors.
  ///
  PXE_UINT16    FragCnt;

  ///
  /// Array of frame fragment descriptors.  The first byte of the first
  /// fragment is also the first byte of the media header.
  ///
  struct {
    ///
    /// Address of this frame fragment.
    ///
    PXE_UINT64    FragAddr;

    ///
    /// Length of this frame fragment.
    ///
    PXE_UINT32    FragLen;

    ///
    /// Reserved, must be set to zero.
    ///
    PXE_UINT32    reserved;
  } FragDesc[16];
} PXE_CPB_TRANSMIT_FRAGMENTS;

typedef struct s_pxe_cpb_receive {
  ///
  /// Address of first byte of receive buffer.  This is also the first byte
  /// of the frame header.
  ///
  PXE_UINT64    BufferAddr;

  ///
  /// Length of receive buffer.  This must be large enough to hold the
  /// received frame (media header + data).  If the length of smaller than
  /// the received frame, data will be lost.
  ///
  PXE_UINT32    BufferLen;

  ///
  /// Reserved, must be set to zero.
  ///
  PXE_UINT32    reserved;
} PXE_CPB_RECEIVE;

typedef struct s_pxe_db_receive {
  ///
  /// Source and destination MAC addresses from media header.
  ///
  PXE_MAC_ADDR          SrcAddr;
  PXE_MAC_ADDR          DestAddr;

  ///
  /// Length of received frame.  May be larger than receive buffer size.
  /// The receive buffer will not be overwritten.  This is how to tell
  /// if data was lost because the receive buffer was too small.
  ///
  PXE_UINT32            FrameLen;

  ///
  /// Protocol type from media header.
  ///
  PXE_MEDIA_PROTOCOL    Protocol;

  ///
  /// Length of media header in received frame.
  ///
  PXE_UINT16            MediaHeaderLen;

  ///
  /// Type of receive frame.
  ///
  PXE_FRAME_TYPE        Type;

  ///
  /// Reserved, must be zero.
  ///
  PXE_UINT8             reserved[7];
} PXE_DB_RECEIVE;

#pragma pack()

#line 1781 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiPxe.h"
#line 2287 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiGpt.h"
/** @file
  EFI Guid Partition Table Format Definition.

Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




///
/// The primary GUID Partition Table Header must be
/// located in LBA 1 (i.e., the second logical block).
///

///
/// EFI Partition Table Signature: "EFI PART".
///

///
/// Minimum bytes reserve for EFI entry array buffer.
///


#pragma pack(1)

///
/// GPT Partition Table Header.
///
typedef struct {
  ///
  /// The table header for the GPT partition Table.
  /// This header contains EFI_PTAB_HEADER_ID.
  ///
  EFI_TABLE_HEADER    Header;
  ///
  /// The LBA that contains this data structure.
  ///
  EFI_LBA             MyLBA;
  ///
  /// LBA address of the alternate GUID Partition Table Header.
  ///
  EFI_LBA             AlternateLBA;
  ///
  /// The first usable logical block that may be used
  /// by a partition described by a GUID Partition Entry.
  ///
  EFI_LBA             FirstUsableLBA;
  ///
  /// The last usable logical block that may be used
  /// by a partition described by a GUID Partition Entry.
  ///
  EFI_LBA             LastUsableLBA;
  ///
  /// GUID that can be used to uniquely identify the disk.
  ///
  EFI_GUID            DiskGUID;
  ///
  /// The starting LBA of the GUID Partition Entry array.
  ///
  EFI_LBA             PartitionEntryLBA;
  ///
  /// The number of Partition Entries in the GUID Partition Entry array.
  ///
  UINT32              NumberOfPartitionEntries;
  ///
  /// The size, in bytes, of each the GUID Partition
  /// Entry structures in the GUID Partition Entry
  /// array. This field shall be set to a value of 128 x 2^n where n is
  /// an integer greater than or equal to zero (e.g., 128, 256, 512, etc.).
  ///
  UINT32              SizeOfPartitionEntry;
  ///
  /// The CRC32 of the GUID Partition Entry array.
  /// Starts at PartitionEntryLBA and is
  /// computed over a byte length of
  /// NumberOfPartitionEntries * SizeOfPartitionEntry.
  ///
  UINT32              PartitionEntryArrayCRC32;
} EFI_PARTITION_TABLE_HEADER;

///
/// GPT Partition Entry.
///
typedef struct {
  ///
  /// Unique ID that defines the purpose and type of this Partition. A value of
  /// zero defines that this partition entry is not being used.
  ///
  EFI_GUID    PartitionTypeGUID;
  ///
  /// GUID that is unique for every partition entry. Every partition ever
  /// created will have a unique GUID.
  /// This GUID must be assigned when the GUID Partition Entry is created.
  ///
  EFI_GUID    UniquePartitionGUID;
  ///
  /// Starting LBA of the partition defined by this entry
  ///
  EFI_LBA     StartingLBA;
  ///
  /// Ending LBA of the partition defined by this entry.
  ///
  EFI_LBA     EndingLBA;
  ///
  /// Attribute bits, all bits reserved by UEFI
  /// Bit 0:      If this bit is set, the partition is required for the platform to function. The owner/creator of the
  ///             partition indicates that deletion or modification of the contents can result in loss of platform
  ///             features or failure for the platform to boot or operate. The system cannot function normally if
  ///             this partition is removed, and it should be considered part of the hardware of the system.
  ///             Actions such as running diagnostics, system recovery, or even OS install or boot, could
  ///             potentially stop working if this partition is removed. Unless OS software or firmware
  ///             recognizes this partition, it should never be removed or modified as the UEFI firmware or
  ///             platform hardware may become non-functional.
  /// Bit 1:      If this bit is set, then firmware must not produce an EFI_BLOCK_IO_PROTOCOL device for
  ///             this partition. By not producing an EFI_BLOCK_IO_PROTOCOL partition, file system
  ///             mappings will not be created for this partition in UEFI.
  /// Bit 2:      This bit is set aside to let systems with traditional PC-AT BIOS firmware implementations
  ///             inform certain limited, special-purpose software running on these systems that a GPT
  ///             partition may be bootable. The UEFI boot manager must ignore this bit when selecting
  ///             a UEFI-compliant application, e.g., an OS loader.
  /// Bits 3-47:  Undefined and must be zero. Reserved for expansion by future versions of the UEFI
  ///             specification.
  /// Bits 48-63: Reserved for GUID specific use. The use of these bits will vary depending on the
  ///             PartitionTypeGUID. Only the owner of the PartitionTypeGUID is allowed
  ///             to modify these bits. They must be preserved if Bits 0-47 are modified..
  ///
  UINT64    Attributes;
  ///
  /// Null-terminated name of the partition.
  ///
  CHAR16    PartitionName[36];
} EFI_PARTITION_ENTRY;

#pragma pack()
#line 138 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiGpt.h"
#line 2288 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiInternalFormRepresentation.h"
/** @file
  This file defines the encoding for the VFR (Visual Form Representation) language.
  IFR is primarily consumed by the EFI presentation engine, and produced by EFI
  internal application and drivers as well as all add-in card option-ROM drivers

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
(C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  These definitions are from UEFI 2.1 and 2.2.

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/HiiFormMapMethodGuid.h"
/** @file
  Guid used to identify HII FormMap configuration method.

  Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  GUID defined in UEFI 2.2 spec.
**/







extern EFI_GUID  gEfiHiiStandardFormGuid;

#line 20 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Guid/HiiFormMapMethodGuid.h"
#line 19 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiInternalFormRepresentation.h"

///
/// The following types are currently defined:
///
typedef void    *EFI_HII_HANDLE;
typedef CHAR16  *EFI_STRING;
typedef UINT16  EFI_IMAGE_ID;
typedef UINT16  EFI_QUESTION_ID;
typedef UINT16  EFI_STRING_ID;
typedef UINT16  EFI_FORM_ID;
typedef UINT16  EFI_VARSTORE_ID;
typedef UINT16  EFI_ANIMATION_ID;

typedef UINT16 EFI_DEFAULT_ID;

typedef UINT32 EFI_HII_FONT_STYLE;

#pragma pack(1)

//
// Definitions for Package Lists and Package Headers
// Section 27.3.1
//

///
/// The header found at the start of each package list.
///
typedef struct {
  EFI_GUID    PackageListGuid;
  UINT32      PackageLength;
} EFI_HII_PACKAGE_LIST_HEADER;

///
/// The header found at the start of each package.
///
typedef struct {
  UINT32    Length : 24;
  UINT32    Type   : 8;
  // UINT8  Data[...];
} EFI_HII_PACKAGE_HEADER;

//
// Value of HII package type
//














//
// Definitions for Simplified Font Package
//

///
/// Contents of EFI_NARROW_GLYPH.Attributes.
///@{




///@}

///
/// The EFI_NARROW_GLYPH has a preferred dimension (w x h) of 8 x 19 pixels.
///
typedef struct {
  ///
  /// The Unicode representation of the glyph. The term weight is the
  /// technical term for a character code.
  ///
  CHAR16    UnicodeWeight;
  ///
  /// The data element containing the glyph definitions.
  ///
  UINT8     Attributes;
  ///
  /// The column major glyph representation of the character. Bits
  /// with values of one indicate that the corresponding pixel is to be
  /// on when normally displayed; those with zero are off.
  ///
  UINT8     GlyphCol1[19];
} EFI_NARROW_GLYPH;

///
/// The EFI_WIDE_GLYPH has a preferred dimension (w x h) of 16 x 19 pixels, which is large enough
/// to accommodate logographic characters.
///
typedef struct {
  ///
  /// The Unicode representation of the glyph. The term weight is the
  /// technical term for a character code.
  ///
  CHAR16    UnicodeWeight;
  ///
  /// The data element containing the glyph definitions.
  ///
  UINT8     Attributes;
  ///
  /// The column major glyph representation of the character. Bits
  /// with values of one indicate that the corresponding pixel is to be
  /// on when normally displayed; those with zero are off.
  ///
  UINT8     GlyphCol1[19];
  ///
  /// The column major glyph representation of the character. Bits
  /// with values of one indicate that the corresponding pixel is to be
  /// on when normally displayed; those with zero are off.
  ///
  UINT8     GlyphCol2[19];
  ///
  /// Ensures that sizeof (EFI_WIDE_GLYPH) is twice the
  /// sizeof (EFI_NARROW_GLYPH). The contents of Pad must
  /// be zero.
  ///
  UINT8     Pad[3];
} EFI_WIDE_GLYPH;

///
/// A simplified font package consists of a font header
/// followed by a series of glyph structures.
///
typedef struct _EFI_HII_SIMPLE_FONT_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  UINT16                    NumberOfNarrowGlyphs;
  UINT16                    NumberOfWideGlyphs;
  // EFI_NARROW_GLYPH       NarrowGlyphs[];
  // EFI_WIDE_GLYPH         WideGlyphs[];
} EFI_HII_SIMPLE_FONT_PACKAGE_HDR;

//
// Definitions for Font Package
// Section 27.3.3
//

//
// Value for font style
//









typedef struct _EFI_HII_GLYPH_INFO {
  UINT16    Width;
  UINT16    Height;
  INT16     OffsetX;
  INT16     OffsetY;
  INT16     AdvanceX;
} EFI_HII_GLYPH_INFO;

///
/// The fixed header consists of a standard record header,
/// then the character values in this section, the flags
/// (including the encoding method) and the offsets of the glyph
/// information, the glyph bitmaps and the character map.
///
typedef struct _EFI_HII_FONT_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  UINT32                    HdrSize;
  UINT32                    GlyphBlockOffset;
  EFI_HII_GLYPH_INFO        Cell;
  EFI_HII_FONT_STYLE        FontStyle;
  CHAR16                    FontFamily[1];
} EFI_HII_FONT_PACKAGE_HDR;

//
// Value of different glyph info block types
//














typedef struct _EFI_HII_GLYPH_BLOCK {
  UINT8    BlockType;
} EFI_HII_GLYPH_BLOCK;

//
// Definition of different glyph info block types
//

typedef struct _EFI_HII_GIBT_DEFAULTS_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  EFI_HII_GLYPH_INFO     Cell;
} EFI_HII_GIBT_DEFAULTS_BLOCK;

typedef struct _EFI_HII_GIBT_DUPLICATE_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  CHAR16                 CharValue;
} EFI_HII_GIBT_DUPLICATE_BLOCK;

typedef struct _EFI_GLYPH_GIBT_END_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
} EFI_GLYPH_GIBT_END_BLOCK;

typedef struct _EFI_HII_GIBT_EXT1_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT8                  BlockType2;
  UINT8                  Length;
} EFI_HII_GIBT_EXT1_BLOCK;

typedef struct _EFI_HII_GIBT_EXT2_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT8                  BlockType2;
  UINT16                 Length;
} EFI_HII_GIBT_EXT2_BLOCK;

typedef struct _EFI_HII_GIBT_EXT4_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT8                  BlockType2;
  UINT32                 Length;
} EFI_HII_GIBT_EXT4_BLOCK;

typedef struct _EFI_HII_GIBT_GLYPH_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  EFI_HII_GLYPH_INFO     Cell;
  UINT8                  BitmapData[1];
} EFI_HII_GIBT_GLYPH_BLOCK;

typedef struct _EFI_HII_GIBT_GLYPHS_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  EFI_HII_GLYPH_INFO     Cell;
  UINT16                 Count;
  UINT8                  BitmapData[1];
} EFI_HII_GIBT_GLYPHS_BLOCK;

typedef struct _EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT8                  BitmapData[1];
} EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK;

typedef struct _EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT16                 Count;
  UINT8                  BitmapData[1];
} EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK;

typedef struct _EFI_HII_GIBT_VARIABILITY_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  EFI_HII_GLYPH_INFO     Cell;
  UINT8                  GlyphPackInBits;
  UINT8                  BitmapData[1];
} EFI_HII_GIBT_VARIABILITY_BLOCK;

typedef struct _EFI_HII_GIBT_SKIP1_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT8                  SkipCount;
} EFI_HII_GIBT_SKIP1_BLOCK;

typedef struct _EFI_HII_GIBT_SKIP2_BLOCK {
  EFI_HII_GLYPH_BLOCK    Header;
  UINT16                 SkipCount;
} EFI_HII_GIBT_SKIP2_BLOCK;

//
// Definitions for Device Path Package
// Section 27.3.4
//

///
/// The device path package is used to carry a device path
/// associated with the package list.
///
typedef struct _EFI_HII_DEVICE_PATH_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  // EFI_DEVICE_PATH_PROTOCOL DevicePath[];
} EFI_HII_DEVICE_PATH_PACKAGE_HDR;

//
// Definitions for GUID Package
// Section 27.3.5
//

///
/// The GUID package is used to carry data where the format is defined by a GUID.
///
typedef struct _EFI_HII_GUID_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  EFI_GUID                  Guid;
  // Data per GUID definition may follow
} EFI_HII_GUID_PACKAGE_HDR;

//
// Definitions for String Package
// Section 27.3.6
//




///
/// The fixed header consists of a standard record header and then the string identifiers
/// contained in this section and the offsets of the string and language information.
///
typedef struct _EFI_HII_STRING_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  UINT32                    HdrSize;
  UINT32                    StringInfoOffset;
  CHAR16                    LanguageWindow[16];
  EFI_STRING_ID             LanguageName;
  CHAR8                     Language[1];
} EFI_HII_STRING_PACKAGE_HDR;

typedef struct {
  UINT8    BlockType;
} EFI_HII_STRING_BLOCK;

//
// Value of different string information block types
//

















//
// Definition of different string information block types
//

typedef struct _EFI_HII_SIBT_DUPLICATE_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  EFI_STRING_ID           StringId;
} EFI_HII_SIBT_DUPLICATE_BLOCK;

typedef struct _EFI_HII_SIBT_END_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
} EFI_HII_SIBT_END_BLOCK;

typedef struct _EFI_HII_SIBT_EXT1_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   BlockType2;
  UINT8                   Length;
} EFI_HII_SIBT_EXT1_BLOCK;

typedef struct _EFI_HII_SIBT_EXT2_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   BlockType2;
  UINT16                  Length;
} EFI_HII_SIBT_EXT2_BLOCK;

typedef struct _EFI_HII_SIBT_EXT4_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   BlockType2;
  UINT32                  Length;
} EFI_HII_SIBT_EXT4_BLOCK;

typedef struct _EFI_HII_SIBT_FONT_BLOCK {
  EFI_HII_SIBT_EXT2_BLOCK    Header;
  UINT8                      FontId;
  UINT16                     FontSize;
  EFI_HII_FONT_STYLE         FontStyle;
  CHAR16                     FontName[1];
} EFI_HII_SIBT_FONT_BLOCK;

typedef struct _EFI_HII_SIBT_SKIP1_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   SkipCount;
} EFI_HII_SIBT_SKIP1_BLOCK;

typedef struct _EFI_HII_SIBT_SKIP2_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT16                  SkipCount;
} EFI_HII_SIBT_SKIP2_BLOCK;

typedef struct _EFI_HII_SIBT_STRING_SCSU_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   StringText[1];
} EFI_HII_SIBT_STRING_SCSU_BLOCK;

typedef struct _EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   FontIdentifier;
  UINT8                   StringText[1];
} EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK;

typedef struct _EFI_HII_SIBT_STRINGS_SCSU_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT16                  StringCount;
  UINT8                   StringText[1];
} EFI_HII_SIBT_STRINGS_SCSU_BLOCK;

typedef struct _EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   FontIdentifier;
  UINT16                  StringCount;
  UINT8                   StringText[1];
} EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK;

typedef struct _EFI_HII_SIBT_STRING_UCS2_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  CHAR16                  StringText[1];
} EFI_HII_SIBT_STRING_UCS2_BLOCK;

typedef struct _EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   FontIdentifier;
  CHAR16                  StringText[1];
} EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK;

typedef struct _EFI_HII_SIBT_STRINGS_UCS2_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT16                  StringCount;
  CHAR16                  StringText[1];
} EFI_HII_SIBT_STRINGS_UCS2_BLOCK;

typedef struct _EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK {
  EFI_HII_STRING_BLOCK    Header;
  UINT8                   FontIdentifier;
  UINT16                  StringCount;
  CHAR16                  StringText[1];
} EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK;

//
// Definitions for Image Package
// Section 27.3.7
//

typedef struct _EFI_HII_IMAGE_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  UINT32                    ImageInfoOffset;
  UINT32                    PaletteInfoOffset;
} EFI_HII_IMAGE_PACKAGE_HDR;

typedef struct _EFI_HII_IMAGE_BLOCK {
  UINT8    BlockType;
} EFI_HII_IMAGE_BLOCK;

//
// Value of different image information block types
//


















//
// Definition of different image information block types
//

typedef struct _EFI_HII_IIBT_END_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
} EFI_HII_IIBT_END_BLOCK;

typedef struct _EFI_HII_IIBT_EXT1_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT8                  BlockType2;
  UINT8                  Length;
} EFI_HII_IIBT_EXT1_BLOCK;

typedef struct _EFI_HII_IIBT_EXT2_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT8                  BlockType2;
  UINT16                 Length;
} EFI_HII_IIBT_EXT2_BLOCK;

typedef struct _EFI_HII_IIBT_EXT4_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT8                  BlockType2;
  UINT32                 Length;
} EFI_HII_IIBT_EXT4_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_1BIT_BASE {
  UINT16    Width;
  UINT16    Height;
  UINT8     Data[1];
} EFI_HII_IIBT_IMAGE_1BIT_BASE;

typedef struct _EFI_HII_IIBT_IMAGE_1BIT_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_1BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_1BIT_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_1BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK;

typedef struct _EFI_HII_RGB_PIXEL {
  UINT8    b;
  UINT8    g;
  UINT8    r;
} EFI_HII_RGB_PIXEL;

typedef struct _EFI_HII_IIBT_IMAGE_24BIT_BASE {
  UINT16               Width;
  UINT16               Height;
  EFI_HII_RGB_PIXEL    Bitmap[1];
} EFI_HII_IIBT_IMAGE_24BIT_BASE;

typedef struct _EFI_HII_IIBT_IMAGE_24BIT_BLOCK {
  EFI_HII_IMAGE_BLOCK              Header;
  EFI_HII_IIBT_IMAGE_24BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_24BIT_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK {
  EFI_HII_IMAGE_BLOCK              Header;
  EFI_HII_IIBT_IMAGE_24BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_4BIT_BASE {
  UINT16    Width;
  UINT16    Height;
  UINT8     Data[1];
} EFI_HII_IIBT_IMAGE_4BIT_BASE;

typedef struct _EFI_HII_IIBT_IMAGE_4BIT_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_4BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_4BIT_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_4BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_8BIT_BASE {
  UINT16    Width;
  UINT16    Height;
  UINT8     Data[1];
} EFI_HII_IIBT_IMAGE_8BIT_BASE;

typedef struct _EFI_HII_IIBT_IMAGE_8BIT_PALETTE_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_8BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_8BIT_BLOCK;

typedef struct _EFI_HII_IIBT_IMAGE_8BIT_TRANS_BLOCK {
  EFI_HII_IMAGE_BLOCK             Header;
  UINT8                           PaletteIndex;
  EFI_HII_IIBT_IMAGE_8BIT_BASE    Bitmap;
} EFI_HII_IIBT_IMAGE_8BIT_TRAN_BLOCK;

typedef struct _EFI_HII_IIBT_DUPLICATE_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  EFI_IMAGE_ID           ImageId;
} EFI_HII_IIBT_DUPLICATE_BLOCK;

typedef struct _EFI_HII_IIBT_JPEG_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT32                 Size;
  UINT8                  Data[1];
} EFI_HII_IIBT_JPEG_BLOCK;

typedef struct _EFI_HII_IIBT_PNG_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT32                 Size;
  UINT8                  Data[1];
} EFI_HII_IIBT_PNG_BLOCK;

typedef struct _EFI_HII_IIBT_SKIP1_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT8                  SkipCount;
} EFI_HII_IIBT_SKIP1_BLOCK;

typedef struct _EFI_HII_IIBT_SKIP2_BLOCK {
  EFI_HII_IMAGE_BLOCK    Header;
  UINT16                 SkipCount;
} EFI_HII_IIBT_SKIP2_BLOCK;

//
// Definitions for Palette Information
//

typedef struct _EFI_HII_IMAGE_PALETTE_INFO_HEADER {
  UINT16    PaletteCount;
} EFI_HII_IMAGE_PALETTE_INFO_HEADER;

typedef struct _EFI_HII_IMAGE_PALETTE_INFO {
  UINT16               PaletteSize;
  EFI_HII_RGB_PIXEL    PaletteValue[1];
} EFI_HII_IMAGE_PALETTE_INFO;

//
// Definitions for Forms Package
// Section 27.3.8
//

///
/// The Form package is used to carry form-based encoding data.
///
typedef struct _EFI_HII_FORM_PACKAGE_HDR {
  EFI_HII_PACKAGE_HEADER    Header;
  // EFI_IFR_OP_HEADER         OpCodeHeader;
  // More op-codes follow
} EFI_HII_FORM_PACKAGE_HDR;

typedef struct {
  UINT8    Hour;
  UINT8    Minute;
  UINT8    Second;
} EFI_HII_TIME;

typedef struct {
  UINT16    Year;
  UINT8     Month;
  UINT8     Day;
} EFI_HII_DATE;

typedef struct {
  EFI_QUESTION_ID    QuestionId;
  EFI_FORM_ID        FormId;
  EFI_GUID           FormSetGuid;
  EFI_STRING_ID      DevicePath;
} EFI_HII_REF;

typedef union {
  UINT8            u8;
  UINT16           u16;
  UINT32           u32;
  UINT64           u64;
  BOOLEAN          b;
  EFI_HII_TIME     time;
  EFI_HII_DATE     date;
  EFI_STRING_ID    string; ///< EFI_IFR_TYPE_STRING, EFI_IFR_TYPE_ACTION
  EFI_HII_REF      ref;    ///< EFI_IFR_TYPE_REF
  // UINT8 buffer[];      ///< EFI_IFR_TYPE_BUFFER
} EFI_IFR_TYPE_VALUE;

//
// IFR Opcodes
//





































































































//
// Definitions of IFR Standard Headers
// Section 27.3.8.2
//

typedef struct _EFI_IFR_OP_HEADER {
  UINT8    OpCode;
  UINT8    Length : 7;
  UINT8    Scope  : 1;
} EFI_IFR_OP_HEADER;

typedef struct _EFI_IFR_STATEMENT_HEADER {
  EFI_STRING_ID    Prompt;
  EFI_STRING_ID    Help;
} EFI_IFR_STATEMENT_HEADER;

typedef struct _EFI_IFR_QUESTION_HEADER {
  EFI_IFR_STATEMENT_HEADER    Header;
  EFI_QUESTION_ID             QuestionId;
  EFI_VARSTORE_ID             VarStoreId;
  union {
    EFI_STRING_ID    VarName;
    UINT16           VarOffset;
  }                        VarStoreInfo;
  UINT8                       Flags;
} EFI_IFR_QUESTION_HEADER;

//
// Flag values of EFI_IFR_QUESTION_HEADER
//







//
// Definition for Opcode Reference
// Section 27.3.8.3
//
typedef struct _EFI_IFR_DEFAULTSTORE {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        DefaultName;
  UINT16               DefaultId;
} EFI_IFR_DEFAULTSTORE;

//
// Default Identifier of default store
//










typedef struct _EFI_IFR_VARSTORE {
  EFI_IFR_OP_HEADER    Header;
  EFI_GUID             Guid;
  EFI_VARSTORE_ID      VarStoreId;
  UINT16               Size;
  UINT8                Name[1];
} EFI_IFR_VARSTORE;

typedef struct _EFI_IFR_VARSTORE_EFI {
  EFI_IFR_OP_HEADER    Header;
  EFI_VARSTORE_ID      VarStoreId;
  EFI_GUID             Guid;
  UINT32               Attributes;
  UINT16               Size;
  UINT8                Name[1];
} EFI_IFR_VARSTORE_EFI;

typedef struct _EFI_IFR_VARSTORE_NAME_VALUE {
  EFI_IFR_OP_HEADER    Header;
  EFI_VARSTORE_ID      VarStoreId;
  EFI_GUID             Guid;
} EFI_IFR_VARSTORE_NAME_VALUE;

typedef struct _EFI_IFR_FORM_SET {
  EFI_IFR_OP_HEADER    Header;
  EFI_GUID             Guid;
  EFI_STRING_ID        FormSetTitle;
  EFI_STRING_ID        Help;
  UINT8                Flags;
  // EFI_GUID              ClassGuid[];
} EFI_IFR_FORM_SET;

typedef struct _EFI_IFR_END {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_END;

typedef struct _EFI_IFR_FORM {
  EFI_IFR_OP_HEADER    Header;
  UINT16               FormId;
  EFI_STRING_ID        FormTitle;
} EFI_IFR_FORM;

typedef struct _EFI_IFR_IMAGE {
  EFI_IFR_OP_HEADER    Header;
  EFI_IMAGE_ID         Id;
} EFI_IFR_IMAGE;

typedef struct _EFI_IFR_MODAL_TAG {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MODAL_TAG;

typedef struct _EFI_IFR_LOCKED {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_LOCKED;

typedef struct _EFI_IFR_RULE {
  EFI_IFR_OP_HEADER    Header;
  UINT8                RuleId;
} EFI_IFR_RULE;

typedef struct _EFI_IFR_DEFAULT {
  EFI_IFR_OP_HEADER     Header;
  UINT16                DefaultId;
  UINT8                 Type;
  EFI_IFR_TYPE_VALUE    Value;
} EFI_IFR_DEFAULT;

typedef struct _EFI_IFR_DEFAULT_2 {
  EFI_IFR_OP_HEADER    Header;
  UINT16               DefaultId;
  UINT8                Type;
} EFI_IFR_DEFAULT_2;

typedef struct _EFI_IFR_VALUE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_VALUE;

typedef struct _EFI_IFR_SUBTITLE {
  EFI_IFR_OP_HEADER           Header;
  EFI_IFR_STATEMENT_HEADER    Statement;
  UINT8                       Flags;
} EFI_IFR_SUBTITLE;



typedef struct _EFI_IFR_CHECKBOX {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      Flags;
} EFI_IFR_CHECKBOX;




typedef struct _EFI_IFR_TEXT {
  EFI_IFR_OP_HEADER           Header;
  EFI_IFR_STATEMENT_HEADER    Statement;
  EFI_STRING_ID               TextTwo;
} EFI_IFR_TEXT;

typedef struct _EFI_IFR_REF {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  EFI_FORM_ID                FormId;
} EFI_IFR_REF;

typedef struct _EFI_IFR_REF2 {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  EFI_FORM_ID                FormId;
  EFI_QUESTION_ID            QuestionId;
} EFI_IFR_REF2;

typedef struct _EFI_IFR_REF3 {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  EFI_FORM_ID                FormId;
  EFI_QUESTION_ID            QuestionId;
  EFI_GUID                   FormSetId;
} EFI_IFR_REF3;

typedef struct _EFI_IFR_REF4 {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  EFI_FORM_ID                FormId;
  EFI_QUESTION_ID            QuestionId;
  EFI_GUID                   FormSetId;
  EFI_STRING_ID              DevicePath;
} EFI_IFR_REF4;

typedef struct _EFI_IFR_REF5 {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
} EFI_IFR_REF5;

typedef struct _EFI_IFR_RESET_BUTTON {
  EFI_IFR_OP_HEADER           Header;
  EFI_IFR_STATEMENT_HEADER    Statement;
  EFI_DEFAULT_ID              DefaultId;
} EFI_IFR_RESET_BUTTON;

typedef struct _EFI_IFR_ACTION {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  EFI_STRING_ID              QuestionConfig;
} EFI_IFR_ACTION;

typedef struct _EFI_IFR_ACTION_1 {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
} EFI_IFR_ACTION_1;

typedef struct _EFI_IFR_DATE {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      Flags;
} EFI_IFR_DATE;

//
// Flags that describe the behavior of the question.
//









typedef union {
  struct {
    UINT8    MinValue;
    UINT8    MaxValue;
    UINT8    Step;
  } u8;
  struct {
    UINT16    MinValue;
    UINT16    MaxValue;
    UINT16    Step;
  } u16;
  struct {
    UINT32    MinValue;
    UINT32    MaxValue;
    UINT32    Step;
  } u32;
  struct {
    UINT64    MinValue;
    UINT64    MaxValue;
    UINT64    Step;
  } u64;
} MINMAXSTEP_DATA;

typedef struct _EFI_IFR_NUMERIC {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      Flags;
  MINMAXSTEP_DATA            data;
} EFI_IFR_NUMERIC;

//
// Flags related to the numeric question
//











typedef struct _EFI_IFR_ONE_OF {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      Flags;
  MINMAXSTEP_DATA            data;
} EFI_IFR_ONE_OF;

typedef struct _EFI_IFR_STRING {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      MinSize;
  UINT8                      MaxSize;
  UINT8                      Flags;
} EFI_IFR_STRING;



typedef struct _EFI_IFR_PASSWORD {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT16                     MinSize;
  UINT16                     MaxSize;
} EFI_IFR_PASSWORD;

typedef struct _EFI_IFR_ORDERED_LIST {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      MaxContainers;
  UINT8                      Flags;
} EFI_IFR_ORDERED_LIST;




typedef struct _EFI_IFR_TIME {
  EFI_IFR_OP_HEADER          Header;
  EFI_IFR_QUESTION_HEADER    Question;
  UINT8                      Flags;
} EFI_IFR_TIME;

//
// A bit-mask that determines which unique settings are active for this opcode.
//









typedef struct _EFI_IFR_DISABLE_IF {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_DISABLE_IF;

typedef struct _EFI_IFR_SUPPRESS_IF {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_SUPPRESS_IF;

typedef struct _EFI_IFR_GRAY_OUT_IF {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_GRAY_OUT_IF;

typedef struct _EFI_IFR_INCONSISTENT_IF {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        Error;
} EFI_IFR_INCONSISTENT_IF;

typedef struct _EFI_IFR_NO_SUBMIT_IF {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        Error;
} EFI_IFR_NO_SUBMIT_IF;

typedef struct _EFI_IFR_WARNING_IF {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        Warning;
  UINT8                TimeOut;
} EFI_IFR_WARNING_IF;

typedef struct _EFI_IFR_REFRESH {
  EFI_IFR_OP_HEADER    Header;
  UINT8                RefreshInterval;
} EFI_IFR_REFRESH;

typedef struct _EFI_IFR_VARSTORE_DEVICE {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        DevicePath;
} EFI_IFR_VARSTORE_DEVICE;

typedef struct _EFI_IFR_ONE_OF_OPTION {
  EFI_IFR_OP_HEADER     Header;
  EFI_STRING_ID         Option;
  UINT8                 Flags;
  UINT8                 Type;
  EFI_IFR_TYPE_VALUE    Value;
} EFI_IFR_ONE_OF_OPTION;

//
// Types of the option's value.
//

















typedef struct _EFI_IFR_GUID {
  EFI_IFR_OP_HEADER    Header;
  EFI_GUID             Guid;
  // Optional Data Follows
} EFI_IFR_GUID;

typedef struct _EFI_IFR_REFRESH_ID {
  EFI_IFR_OP_HEADER    Header;
  EFI_GUID             RefreshEventGroupId;
} EFI_IFR_REFRESH_ID;

typedef struct _EFI_IFR_DUP {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_DUP;

typedef struct _EFI_IFR_EQ_ID_ID {
  EFI_IFR_OP_HEADER    Header;
  EFI_QUESTION_ID      QuestionId1;
  EFI_QUESTION_ID      QuestionId2;
} EFI_IFR_EQ_ID_ID;

typedef struct _EFI_IFR_EQ_ID_VAL {
  EFI_IFR_OP_HEADER    Header;
  EFI_QUESTION_ID      QuestionId;
  UINT16               Value;
} EFI_IFR_EQ_ID_VAL;

typedef struct _EFI_IFR_EQ_ID_VAL_LIST {
  EFI_IFR_OP_HEADER    Header;
  EFI_QUESTION_ID      QuestionId;
  UINT16               ListLength;
  UINT16               ValueList[1];
} EFI_IFR_EQ_ID_VAL_LIST;

typedef struct _EFI_IFR_UINT8 {
  EFI_IFR_OP_HEADER    Header;
  UINT8                Value;
} EFI_IFR_UINT8;

typedef struct _EFI_IFR_UINT16 {
  EFI_IFR_OP_HEADER    Header;
  UINT16               Value;
} EFI_IFR_UINT16;

typedef struct _EFI_IFR_UINT32 {
  EFI_IFR_OP_HEADER    Header;
  UINT32               Value;
} EFI_IFR_UINT32;

typedef struct _EFI_IFR_UINT64 {
  EFI_IFR_OP_HEADER    Header;
  UINT64               Value;
} EFI_IFR_UINT64;

typedef struct _EFI_IFR_QUESTION_REF1 {
  EFI_IFR_OP_HEADER    Header;
  EFI_QUESTION_ID      QuestionId;
} EFI_IFR_QUESTION_REF1;

typedef struct _EFI_IFR_QUESTION_REF2 {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_QUESTION_REF2;

typedef struct _EFI_IFR_QUESTION_REF3 {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_QUESTION_REF3;

typedef struct _EFI_IFR_QUESTION_REF3_2 {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        DevicePath;
} EFI_IFR_QUESTION_REF3_2;

typedef struct _EFI_IFR_QUESTION_REF3_3 {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        DevicePath;
  EFI_GUID             Guid;
} EFI_IFR_QUESTION_REF3_3;

typedef struct _EFI_IFR_RULE_REF {
  EFI_IFR_OP_HEADER    Header;
  UINT8                RuleId;
} EFI_IFR_RULE_REF;

typedef struct _EFI_IFR_STRING_REF1 {
  EFI_IFR_OP_HEADER    Header;
  EFI_STRING_ID        StringId;
} EFI_IFR_STRING_REF1;

typedef struct _EFI_IFR_STRING_REF2 {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_STRING_REF2;

typedef struct _EFI_IFR_THIS {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_THIS;

typedef struct _EFI_IFR_TRUE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TRUE;

typedef struct _EFI_IFR_FALSE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_FALSE;

typedef struct _EFI_IFR_ONE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_ONE;

typedef struct _EFI_IFR_ONES {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_ONES;

typedef struct _EFI_IFR_ZERO {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_ZERO;

typedef struct _EFI_IFR_UNDEFINED {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_UNDEFINED;

typedef struct _EFI_IFR_VERSION {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_VERSION;

typedef struct _EFI_IFR_LENGTH {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_LENGTH;

typedef struct _EFI_IFR_NOT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_NOT;

typedef struct _EFI_IFR_BITWISE_NOT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_BITWISE_NOT;

typedef struct _EFI_IFR_TO_BOOLEAN {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TO_BOOLEAN;

///
/// For EFI_IFR_TO_STRING, when converting from
/// unsigned integers, these flags control the format:
/// 0 = unsigned decimal.
/// 1 = signed decimal.
/// 2 = hexadecimal (lower-case alpha).
/// 3 = hexadecimal (upper-case alpha).
///@{




///@}

///
/// When converting from a buffer, these flags control the format:
/// 0 = ASCII.
/// 8 = Unicode.
///@{


///@}

typedef struct _EFI_IFR_TO_STRING {
  EFI_IFR_OP_HEADER    Header;
  UINT8                Format;
} EFI_IFR_TO_STRING;

typedef struct _EFI_IFR_TO_UINT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TO_UINT;

typedef struct _EFI_IFR_TO_UPPER {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TO_UPPER;

typedef struct _EFI_IFR_TO_LOWER {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TO_LOWER;

typedef struct _EFI_IFR_ADD {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_ADD;

typedef struct _EFI_IFR_AND {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_AND;

typedef struct _EFI_IFR_BITWISE_AND {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_BITWISE_AND;

typedef struct _EFI_IFR_BITWISE_OR {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_BITWISE_OR;

typedef struct _EFI_IFR_CATENATE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_CATENATE;

typedef struct _EFI_IFR_DIVIDE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_DIVIDE;

typedef struct _EFI_IFR_EQUAL {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_EQUAL;

typedef struct _EFI_IFR_GREATER_EQUAL {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_GREATER_EQUAL;

typedef struct _EFI_IFR_GREATER_THAN {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_GREATER_THAN;

typedef struct _EFI_IFR_LESS_EQUAL {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_LESS_EQUAL;

typedef struct _EFI_IFR_LESS_THAN {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_LESS_THAN;

typedef struct _EFI_IFR_MATCH {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MATCH;

typedef struct _EFI_IFR_MATCH2 {
  EFI_IFR_OP_HEADER    Header;
  EFI_GUID             SyntaxType;
} EFI_IFR_MATCH2;

typedef struct _EFI_IFR_MULTIPLY {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MULTIPLY;

typedef struct _EFI_IFR_MODULO {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MODULO;

typedef struct _EFI_IFR_NOT_EQUAL {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_NOT_EQUAL;

typedef struct _EFI_IFR_OR {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_OR;

typedef struct _EFI_IFR_SHIFT_LEFT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_SHIFT_LEFT;

typedef struct _EFI_IFR_SHIFT_RIGHT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_SHIFT_RIGHT;

typedef struct _EFI_IFR_SUBTRACT {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_SUBTRACT;

typedef struct _EFI_IFR_CONDITIONAL {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_CONDITIONAL;

//
// Flags governing the matching criteria of EFI_IFR_FIND
//



typedef struct _EFI_IFR_FIND {
  EFI_IFR_OP_HEADER    Header;
  UINT8                Format;
} EFI_IFR_FIND;

typedef struct _EFI_IFR_MID {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MID;

typedef struct _EFI_IFR_TOKEN {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_TOKEN;

//
// Flags specifying whether to find the first matching string
// or the first non-matching string.
//



typedef struct _EFI_IFR_SPAN {
  EFI_IFR_OP_HEADER    Header;
  UINT8                Flags;
} EFI_IFR_SPAN;

typedef struct _EFI_IFR_SECURITY {
  ///
  /// Standard opcode header, where Header.Op = EFI_IFR_SECURITY_OP.
  ///
  EFI_IFR_OP_HEADER    Header;
  ///
  /// Security permission level.
  ///
  EFI_GUID             Permissions;
} EFI_IFR_SECURITY;

typedef struct _EFI_IFR_FORM_MAP_METHOD {
  ///
  /// The string identifier which provides the human-readable name of
  /// the configuration method for this standards map form.
  ///
  EFI_STRING_ID    MethodTitle;
  ///
  /// Identifier which uniquely specifies the configuration methods
  /// associated with this standards map form.
  ///
  EFI_GUID         MethodIdentifier;
} EFI_IFR_FORM_MAP_METHOD;

typedef struct _EFI_IFR_FORM_MAP {
  ///
  /// The sequence that defines the type of opcode as well as the length
  /// of the opcode being defined. Header.OpCode = EFI_IFR_FORM_MAP_OP.
  ///
  EFI_IFR_OP_HEADER    Header;
  ///
  /// The unique identifier for this particular form.
  ///
  EFI_FORM_ID          FormId;
  ///
  /// One or more configuration method's name and unique identifier.
  ///
  // EFI_IFR_FORM_MAP_METHOD  Methods[];
} EFI_IFR_FORM_MAP;

typedef struct _EFI_IFR_SET {
  ///
  /// The sequence that defines the type of opcode as well as the length
  /// of the opcode being defined. Header.OpCode = EFI_IFR_SET_OP.
  ///
  EFI_IFR_OP_HEADER    Header;
  ///
  /// Specifies the identifier of a previously declared variable store to
  /// use when storing the question's value.
  ///
  EFI_VARSTORE_ID      VarStoreId;
  union {
    ///
    /// A 16-bit Buffer Storage offset.
    ///
    EFI_STRING_ID    VarName;
    ///
    /// A Name Value or EFI Variable name (VarName).
    ///
    UINT16           VarOffset;
  }                  VarStoreInfo;
  ///
  /// Specifies the type used for storage.
  ///
  UINT8    VarStoreType;
} EFI_IFR_SET;

typedef struct _EFI_IFR_GET {
  ///
  /// The sequence that defines the type of opcode as well as the length
  /// of the opcode being defined. Header.OpCode = EFI_IFR_GET_OP.
  ///
  EFI_IFR_OP_HEADER    Header;
  ///
  /// Specifies the identifier of a previously declared variable store to
  /// use when retrieving the value.
  ///
  EFI_VARSTORE_ID      VarStoreId;
  union {
    ///
    /// A 16-bit Buffer Storage offset.
    ///
    EFI_STRING_ID    VarName;
    ///
    /// A Name Value or EFI Variable name (VarName).
    ///
    UINT16           VarOffset;
  }                  VarStoreInfo;
  ///
  /// Specifies the type used for storage.
  ///
  UINT8    VarStoreType;
} EFI_IFR_GET;

typedef struct _EFI_IFR_READ {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_READ;

typedef struct _EFI_IFR_WRITE {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_WRITE;

typedef struct _EFI_IFR_MAP {
  EFI_IFR_OP_HEADER    Header;
} EFI_IFR_MAP;
//
// Definitions for Keyboard Package
// Releated definitions are in Section of EFI_HII_DATABASE_PROTOCOL
//

///
/// Each enumeration values maps a physical key on a keyboard.
///
typedef enum {
  EfiKeyLCtrl,
  EfiKeyA0,
  EfiKeyLAlt,
  EfiKeySpaceBar,
  EfiKeyA2,
  EfiKeyA3,
  EfiKeyA4,
  EfiKeyRCtrl,
  EfiKeyLeftArrow,
  EfiKeyDownArrow,
  EfiKeyRightArrow,
  EfiKeyZero,
  EfiKeyPeriod,
  EfiKeyEnter,
  EfiKeyLShift,
  EfiKeyB0,
  EfiKeyB1,
  EfiKeyB2,
  EfiKeyB3,
  EfiKeyB4,
  EfiKeyB5,
  EfiKeyB6,
  EfiKeyB7,
  EfiKeyB8,
  EfiKeyB9,
  EfiKeyB10,
  EfiKeyRShift,
  EfiKeyUpArrow,
  EfiKeyOne,
  EfiKeyTwo,
  EfiKeyThree,
  EfiKeyCapsLock,
  EfiKeyC1,
  EfiKeyC2,
  EfiKeyC3,
  EfiKeyC4,
  EfiKeyC5,
  EfiKeyC6,
  EfiKeyC7,
  EfiKeyC8,
  EfiKeyC9,
  EfiKeyC10,
  EfiKeyC11,
  EfiKeyC12,
  EfiKeyFour,
  EfiKeyFive,
  EfiKeySix,
  EfiKeyPlus,
  EfiKeyTab,
  EfiKeyD1,
  EfiKeyD2,
  EfiKeyD3,
  EfiKeyD4,
  EfiKeyD5,
  EfiKeyD6,
  EfiKeyD7,
  EfiKeyD8,
  EfiKeyD9,
  EfiKeyD10,
  EfiKeyD11,
  EfiKeyD12,
  EfiKeyD13,
  EfiKeyDel,
  EfiKeyEnd,
  EfiKeyPgDn,
  EfiKeySeven,
  EfiKeyEight,
  EfiKeyNine,
  EfiKeyE0,
  EfiKeyE1,
  EfiKeyE2,
  EfiKeyE3,
  EfiKeyE4,
  EfiKeyE5,
  EfiKeyE6,
  EfiKeyE7,
  EfiKeyE8,
  EfiKeyE9,
  EfiKeyE10,
  EfiKeyE11,
  EfiKeyE12,
  EfiKeyBackSpace,
  EfiKeyIns,
  EfiKeyHome,
  EfiKeyPgUp,
  EfiKeyNLck,
  EfiKeySlash,
  EfiKeyAsterisk,
  EfiKeyMinus,
  EfiKeyEsc,
  EfiKeyF1,
  EfiKeyF2,
  EfiKeyF3,
  EfiKeyF4,
  EfiKeyF5,
  EfiKeyF6,
  EfiKeyF7,
  EfiKeyF8,
  EfiKeyF9,
  EfiKeyF10,
  EfiKeyF11,
  EfiKeyF12,
  EfiKeyPrint,
  EfiKeySLck,
  EfiKeyPause,
  EfiKeyIntl0,
  EfiKeyIntl1,
  EfiKeyIntl2,
  EfiKeyIntl3,
  EfiKeyIntl4,
  EfiKeyIntl5,
  EfiKeyIntl6,
  EfiKeyIntl7,
  EfiKeyIntl8,
  EfiKeyIntl9
} EFI_KEY;

typedef struct {
  ///
  /// Used to describe a physical key on a keyboard.
  ///
  EFI_KEY    Key;
  ///
  /// Unicode character code for the Key.
  ///
  CHAR16     Unicode;
  ///
  /// Unicode character code for the key with the shift key being held down.
  ///
  CHAR16     ShiftedUnicode;
  ///
  /// Unicode character code for the key with the Alt-GR being held down.
  ///
  CHAR16     AltGrUnicode;
  ///
  /// Unicode character code for the key with the Alt-GR and shift keys being held down.
  ///
  CHAR16     ShiftedAltGrUnicode;
  ///
  /// Modifier keys are defined to allow for special functionality that is not necessarily
  /// accomplished by a printable character. Many of these modifier keys are flags to toggle
  /// certain state bits on and off inside of a keyboard driver.
  ///
  UINT16     Modifier;
  UINT16     AffectedAttribute;
} EFI_KEY_DESCRIPTOR;

///
/// A key which is affected by all the standard shift modifiers.
/// Most keys would be expected to have this bit active.
///


///
/// This key is affected by the caps lock so that if a keyboard driver
/// would need to disambiguate between a key which had a "1" defined
/// versus an "a" character.  Having this bit turned on would tell
/// the keyboard driver to use the appropriate shifted state or not.
///


///
/// Similar to the case of CAPS lock, if this bit is active, the key
/// is affected by the num lock being turned on.
///


typedef struct {
  UINT16      LayoutLength;
  EFI_GUID    Guid;
  UINT32      LayoutDescriptorStringOffset;
  UINT8       DescriptorCount;
  // EFI_KEY_DESCRIPTOR    Descriptors[];
} EFI_HII_KEYBOARD_LAYOUT;

typedef struct {
  EFI_HII_PACKAGE_HEADER    Header;
  UINT16                    LayoutCount;
  // EFI_HII_KEYBOARD_LAYOUT Layout[];
} EFI_HII_KEYBOARD_PACKAGE_HDR;

//
// Modifier values
//



































//
// Keys that have multiple control functions based on modifier
// settings are handled in the keyboard driver implementation.
// For instance, PRINT_KEY might have a modifier held down and
// is still a nonprinting character, but might have an alternate
// control function like SYSREQUEST
//










///
/// Animation IFR opcode
///
typedef struct _EFI_IFR_ANIMATION {
  ///
  /// Standard opcode header, where Header.OpCode is
  /// EFI_IFR_ANIMATION_OP.
  ///
  EFI_IFR_OP_HEADER    Header;
  ///
  /// Animation identifier in the HII database.
  ///
  EFI_ANIMATION_ID     Id;
} EFI_IFR_ANIMATION;

///
/// HII animation package header.
///
typedef struct _EFI_HII_ANIMATION_PACKAGE_HDR {
  ///
  /// Standard package header, where Header.Type = EFI_HII_PACKAGE_ANIMATIONS.
  ///
  EFI_HII_PACKAGE_HEADER    Header;
  ///
  /// Offset, relative to this header, of the animation information. If
  /// this is zero, then there are no animation sequences in the package.
  ///
  UINT32                    AnimationInfoOffset;
} EFI_HII_ANIMATION_PACKAGE_HDR;

///
/// Animation information is encoded as a series of blocks,
/// with each block prefixed by a single byte header EFI_HII_ANIMATION_BLOCK.
///
typedef struct _EFI_HII_ANIMATION_BLOCK {
  UINT8    BlockType;
  // UINT8  BlockBody[];
} EFI_HII_ANIMATION_BLOCK;

///
/// Animation block types.
///














///
/// Extended block headers used for variable sized animation records
/// which need an explicit length.
///

typedef struct _EFI_HII_AIBT_EXT1_BLOCK  {
  ///
  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT1.
  ///
  EFI_HII_ANIMATION_BLOCK    Header;
  ///
  /// The block type.
  ///
  UINT8                      BlockType2;
  ///
  /// Size of the animation block, in bytes, including the animation block header.
  ///
  UINT8                      Length;
} EFI_HII_AIBT_EXT1_BLOCK;

typedef struct _EFI_HII_AIBT_EXT2_BLOCK {
  ///
  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT2.
  ///
  EFI_HII_ANIMATION_BLOCK    Header;
  ///
  /// The block type
  ///
  UINT8                      BlockType2;
  ///
  /// Size of the animation block, in bytes, including the animation block header.
  ///
  UINT16                     Length;
} EFI_HII_AIBT_EXT2_BLOCK;

typedef struct _EFI_HII_AIBT_EXT4_BLOCK {
  ///
  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT4.
  ///
  EFI_HII_ANIMATION_BLOCK    Header;
  ///
  /// The block type
  ///
  UINT8                      BlockType2;
  ///
  /// Size of the animation block, in bytes, including the animation block header.
  ///
  UINT32                     Length;
} EFI_HII_AIBT_EXT4_BLOCK;

typedef struct _EFI_HII_ANIMATION_CELL {
  ///
  /// The X offset from the upper left hand corner of the logical
  /// window to position the indexed image.
  ///
  UINT16          OffsetX;
  ///
  /// The Y offset from the upper left hand corner of the logical
  /// window to position the indexed image.
  ///
  UINT16          OffsetY;
  ///
  /// The image to display at the specified offset from the upper left
  /// hand corner of the logical window.
  ///
  EFI_IMAGE_ID    ImageId;
  ///
  /// The number of milliseconds to delay after displaying the indexed
  /// image and before continuing on to the next linked image.  If value
  /// is zero, no delay.
  ///
  UINT16          Delay;
} EFI_HII_ANIMATION_CELL;

///
/// An animation block to describe an animation sequence that does not cycle, and
/// where one image is simply displayed over the previous image.
///
typedef struct _EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK {
  ///
  /// This is image that is to be reference by the image protocols, if the
  /// animation function is not supported or disabled. This image can
  /// be one particular image from the animation sequence (if any one
  /// of the animation frames has a complete image) or an alternate
  /// image that can be displayed alone. If the value is zero, no image
  /// is displayed.
  ///
  EFI_IMAGE_ID              DftImageId;
  ///
  /// The overall width of the set of images (logical window width).
  ///
  UINT16                    Width;
  ///
  /// The overall height of the set of images (logical window height).
  ///
  UINT16                    Height;
  ///
  /// The number of EFI_HII_ANIMATION_CELL contained in the
  /// animation sequence.
  ///
  UINT16                    CellCount;
  ///
  /// An array of CellCount animation cells.
  ///
  EFI_HII_ANIMATION_CELL    AnimationCell[1];
} EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the logical window is cleared to the specified color before
/// the next image is displayed.
///
typedef struct _EFI_HII_AIBT_CLEAR_IMAGES_BLOCK {
  ///
  /// This is image that is to be reference by the image protocols, if the
  /// animation function is not supported or disabled. This image can
  /// be one particular image from the animation sequence (if any one
  /// of the animation frames has a complete image) or an alternate
  /// image that can be displayed alone. If the value is zero, no image
  /// is displayed.
  ///
  EFI_IMAGE_ID              DftImageId;
  ///
  /// The overall width of the set of images (logical window width).
  ///
  UINT16                    Width;
  ///
  /// The overall height of the set of images (logical window height).
  ///
  UINT16                    Height;
  ///
  /// The number of EFI_HII_ANIMATION_CELL contained in the
  /// animation sequence.
  ///
  UINT16                    CellCount;
  ///
  /// The color to clear the logical window to before displaying the
  /// indexed image.
  ///
  EFI_HII_RGB_PIXEL         BackgndColor;
  ///
  /// An array of CellCount animation cells.
  ///
  EFI_HII_ANIMATION_CELL    AnimationCell[1];
} EFI_HII_AIBT_CLEAR_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the screen is restored to the original state before the next
/// image is displayed.
///
typedef struct _EFI_HII_AIBT_RESTORE_SCRN_BLOCK {
  ///
  /// This is image that is to be reference by the image protocols, if the
  /// animation function is not supported or disabled. This image can
  /// be one particular image from the animation sequence (if any one
  /// of the animation frames has a complete image) or an alternate
  /// image that can be displayed alone. If the value is zero, no image
  /// is displayed.
  ///
  EFI_IMAGE_ID              DftImageId;
  ///
  /// The overall width of the set of images (logical window width).
  ///
  UINT16                    Width;
  ///
  /// The overall height of the set of images (logical window height).
  ///
  UINT16                    Height;
  ///
  /// The number of EFI_HII_ANIMATION_CELL contained in the
  /// animation sequence.
  ///
  UINT16                    CellCount;
  ///
  /// An array of CellCount animation cells.
  ///
  EFI_HII_ANIMATION_CELL    AnimationCell[1];
} EFI_HII_AIBT_RESTORE_SCRN_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where one image is simply displayed over the previous image.
///
typedef EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK EFI_HII_AIBT_OVERLAY_IMAGES_LOOP_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where the logical window is cleared to the specified color before
/// the next image is displayed.
///
typedef EFI_HII_AIBT_CLEAR_IMAGES_BLOCK EFI_HII_AIBT_CLEAR_IMAGES_LOOP_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where the screen is restored to the original state before
/// the next image is displayed.
///
typedef EFI_HII_AIBT_RESTORE_SCRN_BLOCK EFI_HII_AIBT_RESTORE_SCRN_LOOP_BLOCK;

///
/// Assigns a new character value to a previously defined animation sequence.
///
typedef struct _EFI_HII_AIBT_DUPLICATE_BLOCK {
  ///
  /// The previously defined animation ID with the exact same
  /// animation information.
  ///
  EFI_ANIMATION_ID    AnimationId;
} EFI_HII_AIBT_DUPLICATE_BLOCK;

///
/// Skips animation IDs.
///
typedef struct _EFI_HII_AIBT_SKIP1_BLOCK {
  ///
  /// The unsigned 8-bit value to add to AnimationIdCurrent.
  ///
  UINT8    SkipCount;
} EFI_HII_AIBT_SKIP1_BLOCK;

///
/// Skips animation IDs.
///
typedef struct _EFI_HII_AIBT_SKIP2_BLOCK {
  ///
  /// The unsigned 16-bit value to add to AnimationIdCurrent.
  ///
  UINT16    SkipCount;
} EFI_HII_AIBT_SKIP2_BLOCK;

#pragma pack()

///
/// References to string tokens must use this macro to enable scanning for
/// token usages.
///
///
/// STRING_TOKEN is not defined in UEFI specification. But it is placed
/// here for the easy access by C files and VFR source files.
///


///
/// IMAGE_TOKEN is not defined in UEFI specification. But it is placed
/// here for the easy access by C files and VFR source files.
///


#line 2137 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiInternalFormRepresentation.h"
#line 2289 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"

#line 2291 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Uefi/UefiSpec.h"
#line 15 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\PiDxe.h"

#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiDxeCis.h"
/** @file
  Include file matches things in PI.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.7

**/





#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
/** @file
  Include file matches things in PI for multiple module types.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  These elements are defined in UEFI Platform Initialization Specification 1.2.

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiFirmwareVolume.h"
/** @file
  The firmware volume related definitions in PI.

  Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.6

**/




///
/// EFI_FV_FILE_ATTRIBUTES
///
typedef UINT32 EFI_FV_FILE_ATTRIBUTES;

//
// Value of EFI_FV_FILE_ATTRIBUTES.
//




///
/// type of EFI FVB attribute
///
typedef UINT32 EFI_FVB_ATTRIBUTES_2;

//
// Attributes bit definitions
//


















































typedef struct {
  ///
  /// The number of sequential blocks which are of the same size.
  ///
  UINT32    NumBlocks;
  ///
  /// The size of the blocks.
  ///
  UINT32    Length;
} EFI_FV_BLOCK_MAP_ENTRY;

///
/// Describes the features and layout of the firmware volume.
///
typedef struct {
  ///
  /// The first 16 bytes are reserved to allow for the reset vector of
  /// processors whose reset vector is at address 0.
  ///
  UINT8                     ZeroVector[16];
  ///
  /// Declares the file system with which the firmware volume is formatted.
  ///
  EFI_GUID                  FileSystemGuid;
  ///
  /// Length in bytes of the complete firmware volume, including the header.
  ///
  UINT64                    FvLength;
  ///
  /// Set to EFI_FVH_SIGNATURE
  ///
  UINT32                    Signature;
  ///
  /// Declares capabilities and power-on defaults for the firmware volume.
  ///
  EFI_FVB_ATTRIBUTES_2      Attributes;
  ///
  /// Length in bytes of the complete firmware volume header.
  ///
  UINT16                    HeaderLength;
  ///
  /// A 16-bit checksum of the firmware volume header. A valid header sums to zero.
  ///
  UINT16                    Checksum;
  ///
  /// Offset, relative to the start of the header, of the extended header
  /// (EFI_FIRMWARE_VOLUME_EXT_HEADER) or zero if there is no extended header.
  ///
  UINT16                    ExtHeaderOffset;
  ///
  /// This field must always be set to zero.
  ///
  UINT8                     Reserved[1];
  ///
  /// Set to 2. Future versions of this specification may define new header fields and will
  /// increment the Revision field accordingly.
  ///
  UINT8                     Revision;
  ///
  /// An array of run-length encoded FvBlockMapEntry structures. The array is
  /// terminated with an entry of {0,0}.
  ///
  EFI_FV_BLOCK_MAP_ENTRY    BlockMap[1];
} EFI_FIRMWARE_VOLUME_HEADER;



///
/// Firmware Volume Header Revision definition
///


///
/// Extension header pointed by ExtHeaderOffset of volume header.
///
typedef struct {
  ///
  /// Firmware volume name.
  ///
  EFI_GUID    FvName;
  ///
  /// Size of the rest of the extension header, including this structure.
  ///
  UINT32      ExtHeaderSize;
} EFI_FIRMWARE_VOLUME_EXT_HEADER;

///
/// Entry struture for describing FV extension header
///
typedef struct {
  ///
  /// Size of this header extension.
  ///
  UINT16    ExtEntrySize;
  ///
  /// Type of the header.
  ///
  UINT16    ExtEntryType;
} EFI_FIRMWARE_VOLUME_EXT_ENTRY;


///
/// This extension header provides a mapping between a GUID and an OEM file type.
///
typedef struct {
  ///
  /// Standard extension entry, with the type EFI_FV_EXT_TYPE_OEM_TYPE.
  ///
  EFI_FIRMWARE_VOLUME_EXT_ENTRY    Hdr;
  ///
  /// A bit mask, one bit for each file type between 0xC0 (bit 0) and 0xDF (bit 31). If a bit
  /// is '1', then the GUID entry exists in Types. If a bit is '0' then no GUID entry exists in Types.
  ///
  UINT32                           TypeMask;
  ///
  /// An array of GUIDs, each GUID representing an OEM file type.
  ///
  /// EFI_GUID  Types[1];
  ///
} EFI_FIRMWARE_VOLUME_EXT_ENTRY_OEM_TYPE;



///
/// This extension header EFI_FIRMWARE_VOLUME_EXT_ENTRY_GUID_TYPE provides a vendor specific
/// GUID FormatType type which includes a length and a successive series of data bytes.
///
typedef struct {
  ///
  /// Standard extension entry, with the type EFI_FV_EXT_TYPE_OEM_TYPE.
  ///
  EFI_FIRMWARE_VOLUME_EXT_ENTRY    Hdr;
  ///
  /// Vendor-specific GUID.
  ///
  EFI_GUID                         FormatType;
  ///
  /// An arry of bytes of length Length.
  ///
  /// UINT8                             Data[1];
  ///
} EFI_FIRMWARE_VOLUME_EXT_ENTRY_GUID_TYPE;



///
/// The EFI_FIRMWARE_VOLUME_EXT_ENTRY_USED_SIZE_TYPE can be used to find
/// out how many EFI_FVB2_ERASE_POLARITY bytes are at the end of the FV.
///
typedef struct {
  ///
  /// Standard extension entry, with the type EFI_FV_EXT_TYPE_USED_SIZE_TYPE.
  ///
  EFI_FIRMWARE_VOLUME_EXT_ENTRY    Hdr;
  ///
  /// The number of bytes of the FV that are in uses. The remaining
  /// EFI_FIRMWARE_VOLUME_HEADER FvLength minus UsedSize bytes in
  /// the FV must contain the value implied by EFI_FVB2_ERASE_POLARITY.
  ///
  UINT32                           UsedSize;
} EFI_FIRMWARE_VOLUME_EXT_ENTRY_USED_SIZE_TYPE;

#line 248 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiFirmwareVolume.h"
#line 16 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiFirmwareFile.h"
/** @file
  The firmware file related definitions in PI.

Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.6.

**/




#pragma pack(1)
///
/// Used to verify the integrity of the file.
///
typedef union {
  struct {
    ///
    /// The IntegrityCheck.Checksum.Header field is an 8-bit checksum of the file
    /// header. The State and IntegrityCheck.Checksum.File fields are assumed
    /// to be zero and the checksum is calculated such that the entire header sums to zero.
    ///
    UINT8    Header;
    ///
    /// If the FFS_ATTRIB_CHECKSUM (see definition below) bit of the Attributes
    /// field is set to one, the IntegrityCheck.Checksum.File field is an 8-bit
    /// checksum of the file data.
    /// If the FFS_ATTRIB_CHECKSUM bit of the Attributes field is cleared to zero,
    /// the IntegrityCheck.Checksum.File field must be initialized with a value of
    /// 0xAA. The IntegrityCheck.Checksum.File field is valid any time the
    /// EFI_FILE_DATA_VALID bit is set in the State field.
    ///
    UINT8    File;
  } Checksum;
  ///
  /// This is the full 16 bits of the IntegrityCheck field.
  ///
  UINT16    Checksum16;
} EFI_FFS_INTEGRITY_CHECK;

///
/// FFS_FIXED_CHECKSUM is the checksum value used when the
/// FFS_ATTRIB_CHECKSUM attribute bit is clear.
///


typedef UINT8  EFI_FV_FILETYPE;
typedef UINT8  EFI_FFS_FILE_ATTRIBUTES;
typedef UINT8  EFI_FFS_FILE_STATE;

///
/// File Types Definitions
///


























///
/// FFS File Attributes.
///






///
/// FFS File State Bits.
///







///
/// Each file begins with the header that describe the
/// contents and state of the files.
///
typedef struct {
  ///
  /// This GUID is the file name. It is used to uniquely identify the file.
  ///
  EFI_GUID                   Name;
  ///
  /// Used to verify the integrity of the file.
  ///
  EFI_FFS_INTEGRITY_CHECK    IntegrityCheck;
  ///
  /// Identifies the type of file.
  ///
  EFI_FV_FILETYPE            Type;
  ///
  /// Declares various file attribute bits.
  ///
  EFI_FFS_FILE_ATTRIBUTES    Attributes;
  ///
  /// The length of the file in bytes, including the FFS header.
  ///
  UINT8                      Size[3];
  ///
  /// Used to track the state of the file throughout the life of the file from creation to deletion.
  ///
  EFI_FFS_FILE_STATE         State;
} EFI_FFS_FILE_HEADER;

typedef struct {
  ///
  /// This GUID is the file name. It is used to uniquely identify the file. There may be only
  /// one instance of a file with the file name GUID of Name in any given firmware
  /// volume, except if the file type is EFI_FV_FILETYPE_FFS_PAD.
  ///
  EFI_GUID                   Name;

  ///
  /// Used to verify the integrity of the file.
  ///
  EFI_FFS_INTEGRITY_CHECK    IntegrityCheck;

  ///
  /// Identifies the type of file.
  ///
  EFI_FV_FILETYPE            Type;

  ///
  /// Declares various file attribute bits.
  ///
  EFI_FFS_FILE_ATTRIBUTES    Attributes;

  ///
  /// The length of the file in bytes, including the FFS header.
  /// The length of the file data is either (Size - sizeof(EFI_FFS_FILE_HEADER)). This calculation means a
  /// zero-length file has a Size of 24 bytes, which is sizeof(EFI_FFS_FILE_HEADER).
  /// Size is not required to be a multiple of 8 bytes. Given a file F, the next file header is
  /// located at the next 8-byte aligned firmware volume offset following the last byte of the file F.
  ///
  UINT8                 Size[3];

  ///
  /// Used to track the state of the file throughout the life of the file from creation to deletion.
  ///
  EFI_FFS_FILE_STATE    State;

  ///
  /// If FFS_ATTRIB_LARGE_FILE is set in Attributes, then ExtendedSize exists and Size must be set to zero.
  /// If FFS_ATTRIB_LARGE_FILE is not set then EFI_FFS_FILE_HEADER is used.
  ///
  UINT64                ExtendedSize;
} EFI_FFS_FILE_HEADER2;




///
/// The argument passed as the FfsFileHeaderPtr parameter to the
/// FFS_FILE_SIZE() function-like macro below must not have side effects:
/// FfsFileHeaderPtr is evaluated multiple times.
///








typedef UINT8 EFI_SECTION_TYPE;

///
/// Pseudo type. It is used as a wild card when retrieving sections.
///  The section type EFI_SECTION_ALL matches all section types.
///


///
/// Encapsulation section Type values.
///






///
/// Leaf section Type values.
///














///
/// Common section header.
///
typedef struct {
  ///
  /// A 24-bit unsigned integer that contains the total size of the section in bytes,
  /// including the EFI_COMMON_SECTION_HEADER.
  ///
  UINT8               Size[3];
  EFI_SECTION_TYPE    Type;
  ///
  /// Declares the section type.
  ///
} EFI_COMMON_SECTION_HEADER;

typedef struct {
  ///
  /// A 24-bit unsigned integer that contains the total size of the section in bytes,
  /// including the EFI_COMMON_SECTION_HEADER.
  ///
  UINT8               Size[3];

  EFI_SECTION_TYPE    Type;

  ///
  /// If Size is 0xFFFFFF, then ExtendedSize contains the size of the section. If
  /// Size is not equal to 0xFFFFFF, then this field does not exist.
  ///
  UINT32              ExtendedSize;
} EFI_COMMON_SECTION_HEADER2;

///
/// Leaf section type that contains an
/// IA-32 16-bit executable image.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_COMPATIBILITY16_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_COMPATIBILITY16_SECTION2;

///
/// CompressionType of EFI_COMPRESSION_SECTION.
///


///
/// An encapsulation section type in which the
/// section data is compressed.
///
typedef struct {
  ///
  /// Usual common section header. CommonHeader.Type = EFI_SECTION_COMPRESSION.
  ///
  EFI_COMMON_SECTION_HEADER    CommonHeader;
  ///
  /// The UINT32 that indicates the size of the section data after decompression.
  ///
  UINT32                       UncompressedLength;
  ///
  /// Indicates which compression algorithm is used.
  ///
  UINT8                        CompressionType;
} EFI_COMPRESSION_SECTION;

typedef struct {
  ///
  /// Usual common section header. CommonHeader.Type = EFI_SECTION_COMPRESSION.
  ///
  EFI_COMMON_SECTION_HEADER2    CommonHeader;
  ///
  /// UINT32 that indicates the size of the section data after decompression.
  ///
  UINT32                        UncompressedLength;
  ///
  /// Indicates which compression algorithm is used.
  ///
  UINT8                         CompressionType;
} EFI_COMPRESSION_SECTION2;

///
/// An encapsulation section type in which the section data is disposable.
/// A disposable section is an encapsulation section in which the section data may be disposed of during
/// the process of creating or updating a firmware image without significant impact on the usefulness of
/// the file. The Type field in the section header is set to EFI_SECTION_DISPOSABLE. This
/// allows optional or descriptive data to be included with the firmware file which can be removed in
/// order to conserve space. The contents of this section are implementation specific, but might contain
/// debug data or detailed integration instructions.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_DISPOSABLE_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_DISPOSABLE_SECTION2;

///
/// The leaf section which could be used to determine the dispatch order of DXEs.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_DXE_DEPEX_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_DXE_DEPEX_SECTION2;

///
/// The leaf section which contains a PI FV.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_FIRMWARE_VOLUME_IMAGE_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_FIRMWARE_VOLUME_IMAGE_SECTION2;

///
/// The leaf section which contains a single GUID.
///
typedef struct {
  ///
  /// Common section header. CommonHeader.Type = EFI_SECTION_FREEFORM_SUBTYPE_GUID.
  ///
  EFI_COMMON_SECTION_HEADER    CommonHeader;
  ///
  /// This GUID is defined by the creator of the file. It is a vendor-defined file type.
  ///
  EFI_GUID                     SubTypeGuid;
} EFI_FREEFORM_SUBTYPE_GUID_SECTION;

typedef struct {
  ///
  /// The common section header. CommonHeader.Type = EFI_SECTION_FREEFORM_SUBTYPE_GUID.
  ///
  EFI_COMMON_SECTION_HEADER2    CommonHeader;
  ///
  /// This GUID is defined by the creator of the file. It is a vendor-defined file type.
  ///
  EFI_GUID                      SubTypeGuid;
} EFI_FREEFORM_SUBTYPE_GUID_SECTION2;

///
/// Attributes of EFI_GUID_DEFINED_SECTION.
///


///
/// The leaf section which is encapsulation defined by specific GUID.
///
typedef struct {
  ///
  /// The common section header. CommonHeader.Type = EFI_SECTION_GUID_DEFINED.
  ///
  EFI_COMMON_SECTION_HEADER    CommonHeader;
  ///
  /// The GUID that defines the format of the data that follows. It is a vendor-defined section type.
  ///
  EFI_GUID                     SectionDefinitionGuid;
  ///
  /// Contains the offset in bytes from the beginning of the common header to the first byte of the data.
  ///
  UINT16                       DataOffset;
  ///
  /// The bit field that declares some specific characteristics of the section contents.
  ///
  UINT16                       Attributes;
} EFI_GUID_DEFINED_SECTION;

typedef struct {
  ///
  /// The common section header. CommonHeader.Type = EFI_SECTION_GUID_DEFINED.
  ///
  EFI_COMMON_SECTION_HEADER2    CommonHeader;
  ///
  /// The GUID that defines the format of the data that follows. It is a vendor-defined section type.
  ///
  EFI_GUID                      SectionDefinitionGuid;
  ///
  /// Contains the offset in bytes from the beginning of the common header to the first byte of the data.
  ///
  UINT16                        DataOffset;
  ///
  /// The bit field that declares some specific characteristics of the section contents.
  ///
  UINT16                        Attributes;
} EFI_GUID_DEFINED_SECTION2;

///
/// The leaf section which contains PE32+ image.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_PE32_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_PE32_SECTION2;

///
/// The leaf section used to determine the dispatch order of PEIMs.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_PEI_DEPEX_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_PEI_DEPEX_SECTION2;

///
/// A leaf section type that contains a position-independent-code (PIC) image.
/// A PIC image section is a leaf section that contains a position-independent-code (PIC) image.
/// In addition to normal PE32+ images that contain relocation information, PEIM executables may be
/// PIC and are referred to as PIC images. A PIC image is the same as a PE32+ image except that all
/// relocation information has been stripped from the image and the image can be moved and will
/// execute correctly without performing any relocation or other fix-ups. EFI_PIC_SECTION2 must
/// be used if the section is 16MB or larger.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_PIC_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_PIC_SECTION2;

///
/// The leaf section which constains the position-independent-code image.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_TE_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_TE_SECTION2;

///
/// The leaf section which contains an array of zero or more bytes.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_RAW_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_RAW_SECTION2;

///
/// The SMM dependency expression section is a leaf section that contains a dependency expression that
/// is used to determine the dispatch order for SMM drivers. Before the SMRAM invocation of the
/// SMM driver's entry point, this dependency expression must evaluate to TRUE. See the Platform
/// Initialization Specification, Volume 2, for details regarding the format of the dependency expression.
/// The dependency expression may refer to protocols installed in either the UEFI or the SMM protocol
/// database. EFI_SMM_DEPEX_SECTION2 must be used if the section is 16MB or larger.
///
typedef EFI_COMMON_SECTION_HEADER  EFI_SMM_DEPEX_SECTION;
typedef EFI_COMMON_SECTION_HEADER2 EFI_SMM_DEPEX_SECTION2;

///
/// The leaf section which contains a unicode string that
/// is human readable file name.
///
typedef struct {
  EFI_COMMON_SECTION_HEADER    CommonHeader;

  ///
  /// Array of unicode string.
  ///
  CHAR16                       FileNameString[1];
} EFI_USER_INTERFACE_SECTION;

typedef struct {
  EFI_COMMON_SECTION_HEADER2    CommonHeader;
  CHAR16                        FileNameString[1];
} EFI_USER_INTERFACE_SECTION2;

///
/// The leaf section which contains a numeric build number and
/// an optional unicode string that represents the file revision.
///
typedef struct {
  EFI_COMMON_SECTION_HEADER    CommonHeader;
  UINT16                       BuildNumber;

  ///
  /// Array of unicode string.
  ///
  CHAR16                       VersionString[1];
} EFI_VERSION_SECTION;

typedef struct {
  EFI_COMMON_SECTION_HEADER2    CommonHeader;
  ///
  /// A UINT16 that represents a particular build. Subsequent builds have monotonically
  /// increasing build numbers relative to earlier builds.
  ///
  UINT16                        BuildNumber;
  CHAR16                        VersionString[1];
} EFI_VERSION_SECTION2;

///
/// The argument passed as the SectionHeaderPtr parameter to the SECTION_SIZE()
/// and IS_SECTION2() function-like macros below must not have side effects:
/// SectionHeaderPtr is evaluated multiple times.
///











#pragma pack()

#line 507 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiFirmwareFile.h"
#line 17 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiBootMode.h"
/** @file
  Present the boot mode values in PI.

  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.2.1A

**/




///
/// EFI boot mode
///
typedef UINT32 EFI_BOOT_MODE;

//
// 0x21 - 0xf..f are reserved.
//













#line 37 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiBootMode.h"
#line 18 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiHob.h"
/** @file
  HOB related definitions in PI.

Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.6

**/




//
// HobType of EFI_HOB_GENERIC_HEADER.
//














///
/// Describes the format and size of the data inside the HOB.
/// All HOBs must contain this generic HOB header.
///
typedef struct {
  ///
  /// Identifies the HOB data structure type.
  ///
  UINT16    HobType;
  ///
  /// The length in bytes of the HOB.
  ///
  UINT16    HobLength;
  ///
  /// This field must always be set to zero.
  ///
  UINT32    Reserved;
} EFI_HOB_GENERIC_HEADER;

///
/// Value of version  in EFI_HOB_HANDOFF_INFO_TABLE.
///


///
/// Contains general state information used by the HOB producer phase.
/// This HOB must be the first one in the HOB list.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_HANDOFF.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// The version number pertaining to the PHIT HOB definition.
  /// This value is four bytes in length to provide an 8-byte aligned entry
  /// when it is combined with the 4-byte BootMode.
  ///
  UINT32                    Version;
  ///
  /// The system boot mode as determined during the HOB producer phase.
  ///
  EFI_BOOT_MODE             BootMode;
  ///
  /// The highest address location of memory that is allocated for use by the HOB producer
  /// phase. This address must be 4-KB aligned to meet page restrictions of UEFI.
  ///
  EFI_PHYSICAL_ADDRESS      EfiMemoryTop;
  ///
  /// The lowest address location of memory that is allocated for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS      EfiMemoryBottom;
  ///
  /// The highest address location of free memory that is currently available
  /// for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS      EfiFreeMemoryTop;
  ///
  /// The lowest address location of free memory that is available for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS      EfiFreeMemoryBottom;
  ///
  /// The end of the HOB list.
  ///
  EFI_PHYSICAL_ADDRESS      EfiEndOfHobList;
} EFI_HOB_HANDOFF_INFO_TABLE;

///
/// EFI_HOB_MEMORY_ALLOCATION_HEADER describes the
/// various attributes of the logical memory allocation. The type field will be used for
/// subsequent inclusion in the UEFI memory map.
///
typedef struct {
  ///
  /// A GUID that defines the memory allocation region's type and purpose, as well as
  /// other fields within the memory allocation HOB. This GUID is used to define the
  /// additional data within the HOB that may be present for the memory allocation HOB.
  /// Type EFI_GUID is defined in InstallProtocolInterface() in the UEFI 2.0
  /// specification.
  ///
  EFI_GUID                Name;

  ///
  /// The base address of memory allocated by this HOB. Type
  /// EFI_PHYSICAL_ADDRESS is defined in AllocatePages() in the UEFI 2.0
  /// specification.
  ///
  EFI_PHYSICAL_ADDRESS    MemoryBaseAddress;

  ///
  /// The length in bytes of memory allocated by this HOB.
  ///
  UINT64                  MemoryLength;

  ///
  /// Defines the type of memory allocated by this HOB. The memory type definition
  /// follows the EFI_MEMORY_TYPE definition. Type EFI_MEMORY_TYPE is defined
  /// in AllocatePages() in the UEFI 2.0 specification.
  ///
  EFI_MEMORY_TYPE         MemoryType;

  ///
  /// Padding for Itanium processor family
  ///
  UINT8                   Reserved[4];
} EFI_HOB_MEMORY_ALLOCATION_HEADER;

///
/// Describes all memory ranges used during the HOB producer
/// phase that exist outside the HOB list. This HOB type
/// describes how memory is used, not the physical attributes of memory.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER              Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER    AllocDescriptor;
  //
  // Additional data pertaining to the "Name" Guid memory
  // may go here.
  //
} EFI_HOB_MEMORY_ALLOCATION;

///
/// Describes the memory stack that is produced by the HOB producer
/// phase and upon which all post-memory-installed executable
/// content in the HOB producer phase is executing.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER              Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER    AllocDescriptor;
} EFI_HOB_MEMORY_ALLOCATION_STACK;

///
/// Defines the location of the boot-strap
/// processor (BSP) BSPStore ("Backing Store Pointer Store").
/// This HOB is valid for the Itanium processor family only
/// register overflow store.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER              Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER    AllocDescriptor;
} EFI_HOB_MEMORY_ALLOCATION_BSP_STORE;

///
/// Defines the location and entry point of the HOB consumer phase.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER              Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER    MemoryAllocationHeader;
  ///
  /// The GUID specifying the values of the firmware file system name
  /// that contains the HOB consumer phase component.
  ///
  EFI_GUID                            ModuleName;
  ///
  /// The address of the memory-mapped firmware volume
  /// that contains the HOB consumer phase firmware file.
  ///
  EFI_PHYSICAL_ADDRESS                EntryPoint;
} EFI_HOB_MEMORY_ALLOCATION_MODULE;

///
/// The resource type.
///
typedef UINT32 EFI_RESOURCE_TYPE;

//
// Value of ResourceType in EFI_HOB_RESOURCE_DESCRIPTOR.
//










///
/// A type of recount attribute type.
///
typedef UINT32 EFI_RESOURCE_ATTRIBUTE_TYPE;

//
// These types can be ORed together as needed.
//
// The following attributes are used to describe settings
//




//
// This is typically used as memory cacheability attribute today.
// NOTE: Since PI spec 1.4, please use EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTED
// as Physical write protected attribute, and EFI_RESOURCE_ATTRIBUTE_WRITE_PROTECTED
// means Memory cacheability attribute: The memory supports being programmed with
// a writeprotected cacheable attribute.
//



//
// The rest of the attributes are used to describe capabilities
//













//
// This is typically used as memory cacheability attribute today.
// NOTE: Since PI spec 1.4, please use EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTABLE
// as Memory capability attribute: The memory supports being protected from processor
// writes, and EFI_RESOURCE_ATTRIBUTE_WRITE_PROTEC TABLE means Memory cacheability attribute:
// The memory supports being programmed with a writeprotected cacheable attribute.
//









//
// Physical memory relative reliability attribute. This
// memory provides higher reliability relative to other
// memory in the system. If all memory has the same
// reliability, then this bit is not used.
//


///
/// Describes the resource properties of all fixed,
/// nonrelocatable resource ranges found on the processor
/// host bus during the HOB producer phase.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_RESOURCE_DESCRIPTOR.
  ///
  EFI_HOB_GENERIC_HEADER         Header;
  ///
  /// A GUID representing the owner of the resource. This GUID is used by HOB
  /// consumer phase components to correlate device ownership of a resource.
  ///
  EFI_GUID                       Owner;
  ///
  /// The resource type enumeration as defined by EFI_RESOURCE_TYPE.
  ///
  EFI_RESOURCE_TYPE              ResourceType;
  ///
  /// Resource attributes as defined by EFI_RESOURCE_ATTRIBUTE_TYPE.
  ///
  EFI_RESOURCE_ATTRIBUTE_TYPE    ResourceAttribute;
  ///
  /// The physical start address of the resource region.
  ///
  EFI_PHYSICAL_ADDRESS           PhysicalStart;
  ///
  /// The number of bytes of the resource region.
  ///
  UINT64                         ResourceLength;
} EFI_HOB_RESOURCE_DESCRIPTOR;

///
/// Allows writers of executable content in the HOB producer phase to
/// maintain and manage HOBs with specific GUID.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_GUID_EXTENSION.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// A GUID that defines the contents of this HOB.
  ///
  EFI_GUID                  Name;
  //
  // Guid specific data goes here
  //
} EFI_HOB_GUID_TYPE;

///
/// Details the location of firmware volumes that contain firmware files.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS      BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                    Length;
} EFI_HOB_FIRMWARE_VOLUME;

///
/// Details the location of a firmware volume that was extracted
/// from a file within another firmware volume.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV2.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS      BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                    Length;
  ///
  /// The name of the firmware volume.
  ///
  EFI_GUID                  FvName;
  ///
  /// The name of the firmware file that contained this firmware volume.
  ///
  EFI_GUID                  FileName;
} EFI_HOB_FIRMWARE_VOLUME2;

///
/// Details the location of a firmware volume that was extracted
/// from a file within another firmware volume.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV3.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS      BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                    Length;
  ///
  /// The authentication status.
  ///
  UINT32                    AuthenticationStatus;
  ///
  /// TRUE if the FV was extracted as a file within another firmware volume.
  /// FALSE otherwise.
  ///
  BOOLEAN                   ExtractedFv;
  ///
  /// The name of the firmware volume.
  /// Valid only if IsExtractedFv is TRUE.
  ///
  EFI_GUID                  FvName;
  ///
  /// The name of the firmware file that contained this firmware volume.
  /// Valid only if IsExtractedFv is TRUE.
  ///
  EFI_GUID                  FileName;
} EFI_HOB_FIRMWARE_VOLUME3;

///
/// Describes processor information, such as address space and I/O space capabilities.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_CPU.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
  ///
  /// Identifies the maximum physical memory addressability of the processor.
  ///
  UINT8                     SizeOfMemorySpace;
  ///
  /// Identifies the maximum physical I/O addressability of the processor.
  ///
  UINT8                     SizeOfIoSpace;
  ///
  /// This field will always be set to zero.
  ///
  UINT8                     Reserved[6];
} EFI_HOB_CPU;

///
/// Describes pool memory allocations.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_POOL.
  ///
  EFI_HOB_GENERIC_HEADER    Header;
} EFI_HOB_MEMORY_POOL;

///
/// Each UEFI capsule HOB details the location of a UEFI capsule. It includes a base address and length
/// which is based upon memory blocks with a EFI_CAPSULE_HEADER and the associated
/// CapsuleImageSize-based payloads. These HOB's shall be created by the PEI PI firmware
/// sometime after the UEFI UpdateCapsule service invocation with the
/// CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE flag set in the EFI_CAPSULE_HEADER.
///
typedef struct {
  ///
  /// The HOB generic header where Header.HobType = EFI_HOB_TYPE_UEFI_CAPSULE.
  ///
  EFI_HOB_GENERIC_HEADER    Header;

  ///
  /// The physical memory-mapped base address of an UEFI capsule. This value is set to
  /// point to the base of the contiguous memory of the UEFI capsule.
  /// The length of the contiguous memory in bytes.
  ///
  EFI_PHYSICAL_ADDRESS      BaseAddress;
  UINT64                    Length;
} EFI_HOB_UEFI_CAPSULE;

///
/// Union of all the possible HOB Types.
///
typedef union {
  EFI_HOB_GENERIC_HEADER                 *Header;
  EFI_HOB_HANDOFF_INFO_TABLE             *HandoffInformationTable;
  EFI_HOB_MEMORY_ALLOCATION              *MemoryAllocation;
  EFI_HOB_MEMORY_ALLOCATION_BSP_STORE    *MemoryAllocationBspStore;
  EFI_HOB_MEMORY_ALLOCATION_STACK        *MemoryAllocationStack;
  EFI_HOB_MEMORY_ALLOCATION_MODULE       *MemoryAllocationModule;
  EFI_HOB_RESOURCE_DESCRIPTOR            *ResourceDescriptor;
  EFI_HOB_GUID_TYPE                      *Guid;
  EFI_HOB_FIRMWARE_VOLUME                *FirmwareVolume;
  EFI_HOB_FIRMWARE_VOLUME2               *FirmwareVolume2;
  EFI_HOB_FIRMWARE_VOLUME3               *FirmwareVolume3;
  EFI_HOB_CPU                            *Cpu;
  EFI_HOB_MEMORY_POOL                    *Pool;
  EFI_HOB_UEFI_CAPSULE                   *Capsule;
  UINT8                                  *Raw;
} EFI_PEI_HOB_POINTERS;

#line 512 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiHob.h"
#line 19 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiDependency.h"
/** @file
  Present the dependency expression values in PI.

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.0

**/




///
/// If present, this must be the first and only opcode,
/// EFI_DEP_BEFORE may be used by DXE and SMM drivers.
///


///
/// If present, this must be the first and only opcode,
/// EFI_DEP_AFTER may be used by DXE and SMM drivers.
///










///
/// If present, this must be the first opcode,
/// EFI_DEP_SOR is only used by DXE driver.
///


#line 42 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiDependency.h"
#line 20 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiStatusCode.h"
/** @file
  StatusCode related definitions in PI.

Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  These status codes are defined in UEFI Platform Initialization Specification 1.2,
  Volume 3: Shared Architectural Elements.

**/




//
// Required for IA32, X64, IPF, ARM and EBC defines for CPU exception types
//
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DebugSupport.h"
/** @file
  DebugSupport protocol and supporting definitions as defined in the UEFI2.4
  specification.

  The DebugSupport protocol is used by source level debuggers to abstract the
  processor and handle context save and restore operations.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2011 - 2013, ARM Ltd. All rights reserved.<BR>
Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>

SPDX-License-Identifier: BSD-2-Clause-Patent

**/




#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/PeImage.h"
/** @file
  EFI image format for PE32, PE32+ and TE. Please note some data structures are
  different for PE32 and PE32+. EFI_IMAGE_NT_HEADERS32 is for PE32 and
  EFI_IMAGE_NT_HEADERS64 is for PE32+.

  This file is coded to the Visual Studio, Microsoft Portable Executable and
  Common Object File Format Specification, Revision 9.3 - December 29, 2015.
  This file also includes some definitions in PI Specification, Revision 1.0.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
Portions Copyright (c) 2016 - 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
Portions Copyright (c) 2022, Loongson Technology Corporation Limited. All rights reserved.<BR>

SPDX-License-Identifier: BSD-2-Clause-Patent

**/




//
// PE32+ Subsystem type for EFI images
//





//
// PE32+ Machine type for EFI images
//












//
// EXE file formats
//





///
/// PE images can start with an optional DOS header, so if an image is run
/// under DOS it can print an error message.
///
typedef struct {
  UINT16    e_magic;    ///< Magic number.
  UINT16    e_cblp;     ///< Bytes on last page of file.
  UINT16    e_cp;       ///< Pages in file.
  UINT16    e_crlc;     ///< Relocations.
  UINT16    e_cparhdr;  ///< Size of header in paragraphs.
  UINT16    e_minalloc; ///< Minimum extra paragraphs needed.
  UINT16    e_maxalloc; ///< Maximum extra paragraphs needed.
  UINT16    e_ss;       ///< Initial (relative) SS value.
  UINT16    e_sp;       ///< Initial SP value.
  UINT16    e_csum;     ///< Checksum.
  UINT16    e_ip;       ///< Initial IP value.
  UINT16    e_cs;       ///< Initial (relative) CS value.
  UINT16    e_lfarlc;   ///< File address of relocation table.
  UINT16    e_ovno;     ///< Overlay number.
  UINT16    e_res[4];   ///< Reserved words.
  UINT16    e_oemid;    ///< OEM identifier (for e_oeminfo).
  UINT16    e_oeminfo;  ///< OEM information; e_oemid specific.
  UINT16    e_res2[10]; ///< Reserved words.
  UINT32    e_lfanew;   ///< File address of new exe header.
} EFI_IMAGE_DOS_HEADER;

///
/// COFF File Header (Object and Image).
///
typedef struct {
  UINT16    Machine;
  UINT16    NumberOfSections;
  UINT32    TimeDateStamp;
  UINT32    PointerToSymbolTable;
  UINT32    NumberOfSymbols;
  UINT16    SizeOfOptionalHeader;
  UINT16    Characteristics;
} EFI_IMAGE_FILE_HEADER;

///
/// Size of EFI_IMAGE_FILE_HEADER.
///


//
// Characteristics
//












///
/// Header Data Directories.
///
typedef struct {
  UINT32    VirtualAddress;
  UINT32    Size;
} EFI_IMAGE_DATA_DIRECTORY;

//
// Directory Entries
//














///
/// @attention
/// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and
/// EFI_IMAGE_OPTIONAL_HEADER32 must be used. The data structures only vary
/// after NT additional fields.
///


///
/// Optional Header Standard Fields for PE32.
///
typedef struct {
  ///
  /// Standard fields.
  ///
  UINT16                      Magic;
  UINT8                       MajorLinkerVersion;
  UINT8                       MinorLinkerVersion;
  UINT32                      SizeOfCode;
  UINT32                      SizeOfInitializedData;
  UINT32                      SizeOfUninitializedData;
  UINT32                      AddressOfEntryPoint;
  UINT32                      BaseOfCode;
  UINT32                      BaseOfData; ///< PE32 contains this additional field, which is absent in PE32+.
  ///
  /// Optional Header Windows-Specific Fields.
  ///
  UINT32                      ImageBase;
  UINT32                      SectionAlignment;
  UINT32                      FileAlignment;
  UINT16                      MajorOperatingSystemVersion;
  UINT16                      MinorOperatingSystemVersion;
  UINT16                      MajorImageVersion;
  UINT16                      MinorImageVersion;
  UINT16                      MajorSubsystemVersion;
  UINT16                      MinorSubsystemVersion;
  UINT32                      Win32VersionValue;
  UINT32                      SizeOfImage;
  UINT32                      SizeOfHeaders;
  UINT32                      CheckSum;
  UINT16                      Subsystem;
  UINT16                      DllCharacteristics;
  UINT32                      SizeOfStackReserve;
  UINT32                      SizeOfStackCommit;
  UINT32                      SizeOfHeapReserve;
  UINT32                      SizeOfHeapCommit;
  UINT32                      LoaderFlags;
  UINT32                      NumberOfRvaAndSizes;
  EFI_IMAGE_DATA_DIRECTORY    DataDirectory[16];
} EFI_IMAGE_OPTIONAL_HEADER32;

///
/// @attention
/// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and
/// EFI_IMAGE_OPTIONAL_HEADER64 must be used. The data structures only vary
/// after NT additional fields.
///


///
/// Optional Header Standard Fields for PE32+.
///
typedef struct {
  ///
  /// Standard fields.
  ///
  UINT16                      Magic;
  UINT8                       MajorLinkerVersion;
  UINT8                       MinorLinkerVersion;
  UINT32                      SizeOfCode;
  UINT32                      SizeOfInitializedData;
  UINT32                      SizeOfUninitializedData;
  UINT32                      AddressOfEntryPoint;
  UINT32                      BaseOfCode;
  ///
  /// Optional Header Windows-Specific Fields.
  ///
  UINT64                      ImageBase;
  UINT32                      SectionAlignment;
  UINT32                      FileAlignment;
  UINT16                      MajorOperatingSystemVersion;
  UINT16                      MinorOperatingSystemVersion;
  UINT16                      MajorImageVersion;
  UINT16                      MinorImageVersion;
  UINT16                      MajorSubsystemVersion;
  UINT16                      MinorSubsystemVersion;
  UINT32                      Win32VersionValue;
  UINT32                      SizeOfImage;
  UINT32                      SizeOfHeaders;
  UINT32                      CheckSum;
  UINT16                      Subsystem;
  UINT16                      DllCharacteristics;
  UINT64                      SizeOfStackReserve;
  UINT64                      SizeOfStackCommit;
  UINT64                      SizeOfHeapReserve;
  UINT64                      SizeOfHeapCommit;
  UINT32                      LoaderFlags;
  UINT32                      NumberOfRvaAndSizes;
  EFI_IMAGE_DATA_DIRECTORY    DataDirectory[16];
} EFI_IMAGE_OPTIONAL_HEADER64;

///
/// @attention
/// EFI_IMAGE_NT_HEADERS32 is for use ONLY by tools.
///
typedef struct {
  UINT32                         Signature;
  EFI_IMAGE_FILE_HEADER          FileHeader;
  EFI_IMAGE_OPTIONAL_HEADER32    OptionalHeader;
} EFI_IMAGE_NT_HEADERS32;



///
/// @attention
/// EFI_IMAGE_HEADERS64 is for use ONLY by tools.
///
typedef struct {
  UINT32                         Signature;
  EFI_IMAGE_FILE_HEADER          FileHeader;
  EFI_IMAGE_OPTIONAL_HEADER64    OptionalHeader;
} EFI_IMAGE_NT_HEADERS64;



//
// Other Windows Subsystem Values
//







//
// DLL Characteristics
//












///
/// Length of ShortName.
///


///
/// Section Table. This table immediately follows the optional header.
///
typedef struct {
  UINT8     Name[8];
  union {
    UINT32    PhysicalAddress;
    UINT32    VirtualSize;
  } Misc;
  UINT32    VirtualAddress;
  UINT32    SizeOfRawData;
  UINT32    PointerToRawData;
  UINT32    PointerToRelocations;
  UINT32    PointerToLinenumbers;
  UINT16    NumberOfRelocations;
  UINT16    NumberOfLinenumbers;
  UINT32    Characteristics;
} EFI_IMAGE_SECTION_HEADER;

///
/// Size of EFI_IMAGE_SECTION_HEADER.
///


//
// Section Flags Values
//


























///
/// Size of a Symbol Table Record.
///


//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//




//
// Symbol Type (fundamental) values.
//

















//
// Symbol Type (derived) values.
//





//
// Storage classes.
//



























//
// type packing constants
//







//
// Communal selection types.
//






//
// the following values only be referred in PeCoff, not defined in PECOFF.
//




///
/// Relocation format.
///
typedef struct {
  UINT32    VirtualAddress;
  UINT32    SymbolTableIndex;
  UINT16    Type;
} EFI_IMAGE_RELOCATION;

///
/// Size of EFI_IMAGE_RELOCATION
///


//
// I386 relocation types.
//










//
// x64 processor relocation types.
//


















///
/// Based relocation format.
///
typedef struct {
  UINT32    VirtualAddress;
  UINT32    SizeOfBlock;
} EFI_IMAGE_BASE_RELOCATION;

///
/// Size of EFI_IMAGE_BASE_RELOCATION.
///


//
// Based relocation types.
//












///
/// Relocation types of RISC-V processor.
///




//
// Relocation types of LoongArch processor.
//



///
/// Line number format.
///
typedef struct {
  union {
    UINT32    SymbolTableIndex; ///< Symbol table index of function name if Linenumber is 0.
    UINT32    VirtualAddress;   ///< Virtual address of line number.
  } Type;
  UINT16    Linenumber;       ///< Line number.
} EFI_IMAGE_LINENUMBER;

///
/// Size of EFI_IMAGE_LINENUMBER.
///


//
// Archive format.
//







///
/// Archive Member Headers
///
typedef struct {
  UINT8    Name[16];     ///< File member name - `/' terminated.
  UINT8    Date[12];     ///< File member date - decimal.
  UINT8    UserID[6];    ///< File member user id - decimal.
  UINT8    GroupID[6];   ///< File member group id - decimal.
  UINT8    Mode[8];      ///< File member mode - octal.
  UINT8    Size[10];     ///< File member size - decimal.
  UINT8    EndHeader[2]; ///< String to end header. (0x60 0x0A).
} EFI_IMAGE_ARCHIVE_MEMBER_HEADER;

///
/// Size of EFI_IMAGE_ARCHIVE_MEMBER_HEADER.
///


//
// DLL Support
//

///
/// Export Directory Table.
///
typedef struct {
  UINT32    Characteristics;
  UINT32    TimeDateStamp;
  UINT16    MajorVersion;
  UINT16    MinorVersion;
  UINT32    Name;
  UINT32    Base;
  UINT32    NumberOfFunctions;
  UINT32    NumberOfNames;
  UINT32    AddressOfFunctions;
  UINT32    AddressOfNames;
  UINT32    AddressOfNameOrdinals;
} EFI_IMAGE_EXPORT_DIRECTORY;

//
// Based export types.
//




///
/// Hint/Name Table.
///
typedef struct {
  UINT16    Hint;
  UINT8     Name[1];
} EFI_IMAGE_IMPORT_BY_NAME;

///
/// Import Address Table RVA (Thunk Table).
///
typedef struct {
  union {
    UINT32                      Function;
    UINT32                      Ordinal;
    EFI_IMAGE_IMPORT_BY_NAME    *AddressOfData;
  } u1;
} EFI_IMAGE_THUNK_DATA;





///
/// Import Directory Table
///
typedef struct {
  UINT32                  Characteristics;
  UINT32                  TimeDateStamp;
  UINT32                  ForwarderChain;
  UINT32                  Name;
  EFI_IMAGE_THUNK_DATA    *FirstThunk;
} EFI_IMAGE_IMPORT_DESCRIPTOR;

///
/// Debug Directory Format.
///
typedef struct {
  UINT32    Characteristics;
  UINT32    TimeDateStamp;
  UINT16    MajorVersion;
  UINT16    MinorVersion;
  UINT32    Type;
  UINT32    SizeOfData;
  UINT32    RVA;         ///< The address of the debug data when loaded, relative to the image base.
  UINT32    FileOffset;  ///< The file pointer to the debug data.
} EFI_IMAGE_DEBUG_DIRECTORY_ENTRY;




///
/// Debug Data Structure defined in Microsoft C++.
///

typedef struct {
  UINT32    Signature;                      ///< "NB10"
  UINT32    Unknown;
  UINT32    Unknown2;
  UINT32    Unknown3;
  //
  // Filename of .PDB goes here
  //
} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;

///
/// Debug Data Structure defined in Microsoft C++.
///

typedef struct {
  UINT32    Signature;                      ///< "RSDS".
  UINT32    Unknown;
  UINT32    Unknown2;
  UINT32    Unknown3;
  UINT32    Unknown4;
  UINT32    Unknown5;
  //
  // Filename of .PDB goes here
  //
} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;

///
/// Debug Data Structure defined by Apple Mach-O to Coff utility.
///

typedef struct {
  UINT32    Signature;                       ///< "MTOC".
  GUID      MachOUuid;
  //
  //  Filename of .DLL (Mach-O with debug info) goes here
  //
} EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY;

//
// .pdata entries for X64
//
typedef struct {
  UINT32    FunctionStartAddress;
  UINT32    FunctionEndAddress;
  UINT32    UnwindInfoAddress;
} RUNTIME_FUNCTION;

typedef struct {
  UINT8    Version             : 3;
  UINT8    Flags               : 5;
  UINT8    SizeOfProlog;
  UINT8    CountOfUnwindCodes;
  UINT8    FrameRegister       : 4;
  UINT8    FrameRegisterOffset : 4;
} UNWIND_INFO;

///
/// Extended DLL Characteristics
///



typedef struct {
  UINT32    DllCharacteristicsEx;
} EFI_IMAGE_DEBUG_EX_DLLCHARACTERISTICS_ENTRY;

///
/// Resource format.
///
typedef struct {
  UINT32    Characteristics;
  UINT32    TimeDateStamp;
  UINT16    MajorVersion;
  UINT16    MinorVersion;
  UINT16    NumberOfNamedEntries;
  UINT16    NumberOfIdEntries;
  //
  // Array of EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY entries goes here.
  //
} EFI_IMAGE_RESOURCE_DIRECTORY;

///
/// Resource directory entry format.
///
typedef struct {
  union {
    struct {
      UINT32    NameOffset   : 31;
      UINT32    NameIsString : 1;
    } s;
    UINT32    Id;
  } u1;
  union {
    UINT32    OffsetToData;
    struct {
      UINT32    OffsetToDirectory : 31;
      UINT32    DataIsDirectory   : 1;
    } s;
  } u2;
} EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY;

///
/// Resource directory entry for string.
///
typedef struct {
  UINT16    Length;
  CHAR16    String[1];
} EFI_IMAGE_RESOURCE_DIRECTORY_STRING;

///
/// Resource directory entry for data array.
///
typedef struct {
  UINT32    OffsetToData;
  UINT32    Size;
  UINT32    CodePage;
  UINT32    Reserved;
} EFI_IMAGE_RESOURCE_DATA_ENTRY;

///
/// Header format for TE images, defined in the PI Specification, 1.0.
///
typedef struct {
  UINT16                      Signature;           ///< The signature for TE format = "VZ".
  UINT16                      Machine;             ///< From the original file header.
  UINT8                       NumberOfSections;    ///< From the original file header.
  UINT8                       Subsystem;           ///< From original optional header.
  UINT16                      StrippedSize;        ///< Number of bytes we removed from the header.
  UINT32                      AddressOfEntryPoint; ///< Offset to entry point -- from original optional header.
  UINT32                      BaseOfCode;          ///< From original image -- required for ITP debug.
  UINT64                      ImageBase;           ///< From original file header.
  EFI_IMAGE_DATA_DIRECTORY    DataDirectory[2];    ///< Only base relocation and debug directory.
} EFI_TE_IMAGE_HEADER;



//
// Data directory indexes in our TE image header
//



///
/// Union of PE32, PE32+, and TE headers.
///
typedef union {
  EFI_IMAGE_NT_HEADERS32    Pe32;
  EFI_IMAGE_NT_HEADERS64    Pe32Plus;
  EFI_TE_IMAGE_HEADER       Te;
} EFI_IMAGE_OPTIONAL_HEADER_UNION;

typedef union {
  EFI_IMAGE_NT_HEADERS32             *Pe32;
  EFI_IMAGE_NT_HEADERS64             *Pe32Plus;
  EFI_TE_IMAGE_HEADER                *Te;
  EFI_IMAGE_OPTIONAL_HEADER_UNION    *Union;
} EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION;

#line 817 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\IndustryStandard/PeImage.h"
#line 20 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DebugSupport.h"

typedef struct _EFI_DEBUG_SUPPORT_PROTOCOL EFI_DEBUG_SUPPORT_PROTOCOL;

///
/// Debug Support protocol {2755590C-6F3C-42FA-9EA4-A3BA543CDA25}.
///





///
/// Processor exception to be hooked.
/// All exception types for IA32, X64, Itanium and EBC processors are defined.
///
typedef INTN EFI_EXCEPTION_TYPE;

///
///  IA-32 processor exception types.
///


















///
/// FXSAVE_STATE.
/// FP / MMX / XMM registers (see fxrstor instruction definition).
///
typedef struct {
  UINT16    Fcw;
  UINT16    Fsw;
  UINT16    Ftw;
  UINT16    Opcode;
  UINT32    Eip;
  UINT16    Cs;
  UINT16    Reserved1;
  UINT32    DataOffset;
  UINT16    Ds;
  UINT8     Reserved2[10];
  UINT8     St0Mm0[10], Reserved3[6];
  UINT8     St1Mm1[10], Reserved4[6];
  UINT8     St2Mm2[10], Reserved5[6];
  UINT8     St3Mm3[10], Reserved6[6];
  UINT8     St4Mm4[10], Reserved7[6];
  UINT8     St5Mm5[10], Reserved8[6];
  UINT8     St6Mm6[10], Reserved9[6];
  UINT8     St7Mm7[10], Reserved10[6];
  UINT8     Xmm0[16];
  UINT8     Xmm1[16];
  UINT8     Xmm2[16];
  UINT8     Xmm3[16];
  UINT8     Xmm4[16];
  UINT8     Xmm5[16];
  UINT8     Xmm6[16];
  UINT8     Xmm7[16];
  UINT8     Reserved11[14 * 16];
} EFI_FX_SAVE_STATE_IA32;

///
///  IA-32 processor context definition.
///
typedef struct {
  UINT32                    ExceptionData;
  EFI_FX_SAVE_STATE_IA32    FxSaveState;
  UINT32                    Dr0;
  UINT32                    Dr1;
  UINT32                    Dr2;
  UINT32                    Dr3;
  UINT32                    Dr6;
  UINT32                    Dr7;
  UINT32                    Cr0;
  UINT32                    Cr1; /* Reserved */
  UINT32                    Cr2;
  UINT32                    Cr3;
  UINT32                    Cr4;
  UINT32                    Eflags;
  UINT32                    Ldtr;
  UINT32                    Tr;
  UINT32                    Gdtr[2];
  UINT32                    Idtr[2];
  UINT32                    Eip;
  UINT32                    Gs;
  UINT32                    Fs;
  UINT32                    Es;
  UINT32                    Ds;
  UINT32                    Cs;
  UINT32                    Ss;
  UINT32                    Edi;
  UINT32                    Esi;
  UINT32                    Ebp;
  UINT32                    Esp;
  UINT32                    Ebx;
  UINT32                    Edx;
  UINT32                    Ecx;
  UINT32                    Eax;
} EFI_SYSTEM_CONTEXT_IA32;

///
///  x64 processor exception types.
///


















///
/// FXSAVE_STATE.
/// FP / MMX / XMM registers (see fxrstor instruction definition).
///
typedef struct {
  UINT16    Fcw;
  UINT16    Fsw;
  UINT16    Ftw;
  UINT16    Opcode;
  UINT64    Rip;
  UINT64    DataOffset;
  UINT8     Reserved1[8];
  UINT8     St0Mm0[10], Reserved2[6];
  UINT8     St1Mm1[10], Reserved3[6];
  UINT8     St2Mm2[10], Reserved4[6];
  UINT8     St3Mm3[10], Reserved5[6];
  UINT8     St4Mm4[10], Reserved6[6];
  UINT8     St5Mm5[10], Reserved7[6];
  UINT8     St6Mm6[10], Reserved8[6];
  UINT8     St7Mm7[10], Reserved9[6];
  UINT8     Xmm0[16];
  UINT8     Xmm1[16];
  UINT8     Xmm2[16];
  UINT8     Xmm3[16];
  UINT8     Xmm4[16];
  UINT8     Xmm5[16];
  UINT8     Xmm6[16];
  UINT8     Xmm7[16];
  //
  // NOTE: UEFI 2.0 spec definition as follows.
  //
  UINT8     Reserved11[14 * 16];
} EFI_FX_SAVE_STATE_X64;

///
///  x64 processor context definition.
///
typedef struct {
  UINT64                   ExceptionData;
  EFI_FX_SAVE_STATE_X64    FxSaveState;
  UINT64                   Dr0;
  UINT64                   Dr1;
  UINT64                   Dr2;
  UINT64                   Dr3;
  UINT64                   Dr6;
  UINT64                   Dr7;
  UINT64                   Cr0;
  UINT64                   Cr1; /* Reserved */
  UINT64                   Cr2;
  UINT64                   Cr3;
  UINT64                   Cr4;
  UINT64                   Cr8;
  UINT64                   Rflags;
  UINT64                   Ldtr;
  UINT64                   Tr;
  UINT64                   Gdtr[2];
  UINT64                   Idtr[2];
  UINT64                   Rip;
  UINT64                   Gs;
  UINT64                   Fs;
  UINT64                   Es;
  UINT64                   Ds;
  UINT64                   Cs;
  UINT64                   Ss;
  UINT64                   Rdi;
  UINT64                   Rsi;
  UINT64                   Rbp;
  UINT64                   Rsp;
  UINT64                   Rbx;
  UINT64                   Rdx;
  UINT64                   Rcx;
  UINT64                   Rax;
  UINT64                   R8;
  UINT64                   R9;
  UINT64                   R10;
  UINT64                   R11;
  UINT64                   R12;
  UINT64                   R13;
  UINT64                   R14;
  UINT64                   R15;
} EFI_SYSTEM_CONTEXT_X64;

///
///  Itanium Processor Family Exception types.
///













//
// 13 - 19 reserved
//








//
// 28 reserved
//








//
// 37 - 44 reserved
//




///
///  IPF processor context definition.
///
typedef struct {
  //
  // The first reserved field is necessary to preserve alignment for the correct
  // bits in UNAT and to insure F2 is 16 byte aligned.
  //
  UINT64    Reserved;
  UINT64    R1;
  UINT64    R2;
  UINT64    R3;
  UINT64    R4;
  UINT64    R5;
  UINT64    R6;
  UINT64    R7;
  UINT64    R8;
  UINT64    R9;
  UINT64    R10;
  UINT64    R11;
  UINT64    R12;
  UINT64    R13;
  UINT64    R14;
  UINT64    R15;
  UINT64    R16;
  UINT64    R17;
  UINT64    R18;
  UINT64    R19;
  UINT64    R20;
  UINT64    R21;
  UINT64    R22;
  UINT64    R23;
  UINT64    R24;
  UINT64    R25;
  UINT64    R26;
  UINT64    R27;
  UINT64    R28;
  UINT64    R29;
  UINT64    R30;
  UINT64    R31;

  UINT64    F2[2];
  UINT64    F3[2];
  UINT64    F4[2];
  UINT64    F5[2];
  UINT64    F6[2];
  UINT64    F7[2];
  UINT64    F8[2];
  UINT64    F9[2];
  UINT64    F10[2];
  UINT64    F11[2];
  UINT64    F12[2];
  UINT64    F13[2];
  UINT64    F14[2];
  UINT64    F15[2];
  UINT64    F16[2];
  UINT64    F17[2];
  UINT64    F18[2];
  UINT64    F19[2];
  UINT64    F20[2];
  UINT64    F21[2];
  UINT64    F22[2];
  UINT64    F23[2];
  UINT64    F24[2];
  UINT64    F25[2];
  UINT64    F26[2];
  UINT64    F27[2];
  UINT64    F28[2];
  UINT64    F29[2];
  UINT64    F30[2];
  UINT64    F31[2];

  UINT64    Pr;

  UINT64    B0;
  UINT64    B1;
  UINT64    B2;
  UINT64    B3;
  UINT64    B4;
  UINT64    B5;
  UINT64    B6;
  UINT64    B7;

  //
  // application registers
  //
  UINT64    ArRsc;
  UINT64    ArBsp;
  UINT64    ArBspstore;
  UINT64    ArRnat;

  UINT64    ArFcr;

  UINT64    ArEflag;
  UINT64    ArCsd;
  UINT64    ArSsd;
  UINT64    ArCflg;
  UINT64    ArFsr;
  UINT64    ArFir;
  UINT64    ArFdr;

  UINT64    ArCcv;

  UINT64    ArUnat;

  UINT64    ArFpsr;

  UINT64    ArPfs;
  UINT64    ArLc;
  UINT64    ArEc;

  //
  // control registers
  //
  UINT64    CrDcr;
  UINT64    CrItm;
  UINT64    CrIva;
  UINT64    CrPta;
  UINT64    CrIpsr;
  UINT64    CrIsr;
  UINT64    CrIip;
  UINT64    CrIfa;
  UINT64    CrItir;
  UINT64    CrIipa;
  UINT64    CrIfs;
  UINT64    CrIim;
  UINT64    CrIha;

  //
  // debug registers
  //
  UINT64    Dbr0;
  UINT64    Dbr1;
  UINT64    Dbr2;
  UINT64    Dbr3;
  UINT64    Dbr4;
  UINT64    Dbr5;
  UINT64    Dbr6;
  UINT64    Dbr7;

  UINT64    Ibr0;
  UINT64    Ibr1;
  UINT64    Ibr2;
  UINT64    Ibr3;
  UINT64    Ibr4;
  UINT64    Ibr5;
  UINT64    Ibr6;
  UINT64    Ibr7;

  //
  // virtual registers - nat bits for R1-R31
  //
  UINT64    IntNat;
} EFI_SYSTEM_CONTEXT_IPF;

///
///  EBC processor exception types.
///











///
/// For coding convenience, define the maximum valid EBC exception.
///


///
///  EBC processor context definition.
///
typedef struct {
  UINT64    R0;
  UINT64    R1;
  UINT64    R2;
  UINT64    R3;
  UINT64    R4;
  UINT64    R5;
  UINT64    R6;
  UINT64    R7;
  UINT64    Flags;
  UINT64    ControlFlags;
  UINT64    Ip;
} EFI_SYSTEM_CONTEXT_EBC;

///
///  ARM processor exception types.
///









///
/// For coding convenience, define the maximum valid ARM exception.
///


///
///  ARM processor context definition.
///
typedef struct {
  UINT32    R0;
  UINT32    R1;
  UINT32    R2;
  UINT32    R3;
  UINT32    R4;
  UINT32    R5;
  UINT32    R6;
  UINT32    R7;
  UINT32    R8;
  UINT32    R9;
  UINT32    R10;
  UINT32    R11;
  UINT32    R12;
  UINT32    SP;
  UINT32    LR;
  UINT32    PC;
  UINT32    CPSR;
  UINT32    DFSR;
  UINT32    DFAR;
  UINT32    IFSR;
  UINT32    IFAR;
} EFI_SYSTEM_CONTEXT_ARM;

///
///  AARCH64 processor exception types.
///





///
/// For coding convenience, define the maximum valid ARM exception.
///


typedef struct {
  // General Purpose Registers
  UINT64    X0;
  UINT64    X1;
  UINT64    X2;
  UINT64    X3;
  UINT64    X4;
  UINT64    X5;
  UINT64    X6;
  UINT64    X7;
  UINT64    X8;
  UINT64    X9;
  UINT64    X10;
  UINT64    X11;
  UINT64    X12;
  UINT64    X13;
  UINT64    X14;
  UINT64    X15;
  UINT64    X16;
  UINT64    X17;
  UINT64    X18;
  UINT64    X19;
  UINT64    X20;
  UINT64    X21;
  UINT64    X22;
  UINT64    X23;
  UINT64    X24;
  UINT64    X25;
  UINT64    X26;
  UINT64    X27;
  UINT64    X28;
  UINT64    FP; // x29 - Frame pointer
  UINT64    LR; // x30 - Link Register
  UINT64    SP; // x31 - Stack pointer

  // FP/SIMD Registers
  UINT64    V0[2];
  UINT64    V1[2];
  UINT64    V2[2];
  UINT64    V3[2];
  UINT64    V4[2];
  UINT64    V5[2];
  UINT64    V6[2];
  UINT64    V7[2];
  UINT64    V8[2];
  UINT64    V9[2];
  UINT64    V10[2];
  UINT64    V11[2];
  UINT64    V12[2];
  UINT64    V13[2];
  UINT64    V14[2];
  UINT64    V15[2];
  UINT64    V16[2];
  UINT64    V17[2];
  UINT64    V18[2];
  UINT64    V19[2];
  UINT64    V20[2];
  UINT64    V21[2];
  UINT64    V22[2];
  UINT64    V23[2];
  UINT64    V24[2];
  UINT64    V25[2];
  UINT64    V26[2];
  UINT64    V27[2];
  UINT64    V28[2];
  UINT64    V29[2];
  UINT64    V30[2];
  UINT64    V31[2];

  UINT64    ELR;  // Exception Link Register
  UINT64    SPSR; // Saved Processor Status Register
  UINT64    FPSR; // Floating Point Status Register
  UINT64    ESR;  // Exception syndrome register
  UINT64    FAR;  // Fault Address Register
} EFI_SYSTEM_CONTEXT_AARCH64;

///
/// RISC-V processor exception types.
///


























///
/// RISC-V processor exception types for interrupts.
///










typedef struct {
  UINT64    X0;
  UINT64    X1;
  UINT64    X2;
  UINT64    X3;
  UINT64    X4;
  UINT64    X5;
  UINT64    X6;
  UINT64    X7;
  UINT64    X8;
  UINT64    X9;
  UINT64    X10;
  UINT64    X11;
  UINT64    X12;
  UINT64    X13;
  UINT64    X14;
  UINT64    X15;
  UINT64    X16;
  UINT64    X17;
  UINT64    X18;
  UINT64    X19;
  UINT64    X20;
  UINT64    X21;
  UINT64    X22;
  UINT64    X23;
  UINT64    X24;
  UINT64    X25;
  UINT64    X26;
  UINT64    X27;
  UINT64    X28;
  UINT64    X29;
  UINT64    X30;
  UINT64    X31;
  UINT64    SEPC;
  UINT32    SSTATUS;
  UINT32    STVAL;
} EFI_SYSTEM_CONTEXT_RISCV64;

//
// LoongArch processor exception types.
//
// The exception types is located in the CSR ESTAT
// register offset 16 bits, width 6 bits.
//
// If you want to register an exception hook, you can
// shfit the number left by 16 bits, and the exception
// handler will know the types.
//
// For example:
// mCpu->CpuRegisterInterruptHandler (
//         mCpu,
//         (EXCEPT_LOONGARCH_PPI << CSR_ESTAT_EXC_SHIFT),
//         PpiExceptionHandler
//         );
//





















//
// LoongArch processor Interrupt types.
//














//
// For coding convenience, define the maximum valid
// LoongArch interrupt.
//


typedef struct {
  UINT64    R0;
  UINT64    R1;
  UINT64    R2;
  UINT64    R3;
  UINT64    R4;
  UINT64    R5;
  UINT64    R6;
  UINT64    R7;
  UINT64    R8;
  UINT64    R9;
  UINT64    R10;
  UINT64    R11;
  UINT64    R12;
  UINT64    R13;
  UINT64    R14;
  UINT64    R15;
  UINT64    R16;
  UINT64    R17;
  UINT64    R18;
  UINT64    R19;
  UINT64    R20;
  UINT64    R21;
  UINT64    R22;
  UINT64    R23;
  UINT64    R24;
  UINT64    R25;
  UINT64    R26;
  UINT64    R27;
  UINT64    R28;
  UINT64    R29;
  UINT64    R30;
  UINT64    R31;

  UINT64    CRMD;  // CuRrent MoDe information
  UINT64    PRMD;  // PRe-exception MoDe information
  UINT64    EUEN;  // Extended component Unit ENable
  UINT64    MISC;  // MISCellaneous controller
  UINT64    ECFG;  // Exception ConFiGuration
  UINT64    ESTAT; // Exception STATus
  UINT64    ERA;   // Exception Return Address
  UINT64    BADV;  // BAD Virtual address
  UINT64    BADI;  // BAD Instruction
} EFI_SYSTEM_CONTEXT_LOONGARCH64;

///
/// Universal EFI_SYSTEM_CONTEXT definition.
///
typedef union {
  EFI_SYSTEM_CONTEXT_EBC            *SystemContextEbc;
  EFI_SYSTEM_CONTEXT_IA32           *SystemContextIa32;
  EFI_SYSTEM_CONTEXT_X64            *SystemContextX64;
  EFI_SYSTEM_CONTEXT_IPF            *SystemContextIpf;
  EFI_SYSTEM_CONTEXT_ARM            *SystemContextArm;
  EFI_SYSTEM_CONTEXT_AARCH64        *SystemContextAArch64;
  EFI_SYSTEM_CONTEXT_RISCV64        *SystemContextRiscV64;
  EFI_SYSTEM_CONTEXT_LOONGARCH64    *SystemContextLoongArch64;
} EFI_SYSTEM_CONTEXT;

//
// DebugSupport callback function prototypes
//

/**
  Registers and enables an exception callback function for the specified exception.

  @param  ExceptionType         Exception types in EBC, IA-32, x64, or IPF.
  @param  SystemContext         Exception content.

**/
typedef
void
(__cdecl *EFI_EXCEPTION_CALLBACK)(
       EFI_EXCEPTION_TYPE               ExceptionType,
    EFI_SYSTEM_CONTEXT               SystemContext
  );

/**
  Registers and enables the on-target debug agent's periodic entry point.

  @param  SystemContext         Exception content.

**/
typedef
void
(__cdecl *EFI_PERIODIC_CALLBACK)(
    EFI_SYSTEM_CONTEXT               SystemContext
  );

///
/// Machine type definition
///
typedef enum {
  IsaIa32    = 0x014c,           ///< 0x014C
  IsaX64     = 0x8664,            ///< 0x8664
  IsaIpf     = 0x0200,           ///< 0x0200
  IsaEbc     = 0x0EBC,            ///< 0x0EBC
  IsaArm     = 0x01c2, ///< 0x01c2
  IsaAArch64 = 0xAA64           ///< 0xAA64
} EFI_INSTRUCTION_SET_ARCHITECTURE;

//
// DebugSupport member function definitions
//

/**
  Returns the maximum value that may be used for the ProcessorIndex parameter in
  RegisterPeriodicCallback() and RegisterExceptionCallback().

  @param  This                  A pointer to the EFI_DEBUG_SUPPORT_PROTOCOL instance.
  @param  MaxProcessorIndex     Pointer to a caller-allocated UINTN in which the maximum supported
                                processor index is returned.

  @retval EFI_SUCCESS           The function completed successfully.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_MAXIMUM_PROCESSOR_INDEX)(
   EFI_DEBUG_SUPPORT_PROTOCOL          *This,
   UINTN                              *MaxProcessorIndex
  );

/**
  Registers a function to be called back periodically in interrupt context.

  @param  This                  A pointer to the EFI_DEBUG_SUPPORT_PROTOCOL instance.
  @param  ProcessorIndex        Specifies which processor the callback function applies to.
  @param  PeriodicCallback      A pointer to a function of type PERIODIC_CALLBACK that is the main
                                periodic entry point of the debug agent.

  @retval EFI_SUCCESS           The function completed successfully.
  @retval EFI_ALREADY_STARTED   Non-NULL PeriodicCallback parameter when a callback
                                function was previously registered.
  @retval EFI_OUT_OF_RESOURCES  System has insufficient memory resources to register new callback
                                function.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REGISTER_PERIODIC_CALLBACK)(
   EFI_DEBUG_SUPPORT_PROTOCOL          *This,
   UINTN                               ProcessorIndex,
   EFI_PERIODIC_CALLBACK               PeriodicCallback
  );

/**
  Registers a function to be called when a given processor exception occurs.

  @param  This                  A pointer to the EFI_DEBUG_SUPPORT_PROTOCOL instance.
  @param  ProcessorIndex        Specifies which processor the callback function applies to.
  @param  ExceptionCallback     A pointer to a function of type EXCEPTION_CALLBACK that is called
                                when the processor exception specified by ExceptionType occurs.
  @param  ExceptionType         Specifies which processor exception to hook.

  @retval EFI_SUCCESS           The function completed successfully.
  @retval EFI_ALREADY_STARTED   Non-NULL PeriodicCallback parameter when a callback
                                function was previously registered.
  @retval EFI_OUT_OF_RESOURCES  System has insufficient memory resources to register new callback
                                function.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REGISTER_EXCEPTION_CALLBACK)(
   EFI_DEBUG_SUPPORT_PROTOCOL          *This,
   UINTN                               ProcessorIndex,
   EFI_EXCEPTION_CALLBACK              ExceptionCallback,
   EFI_EXCEPTION_TYPE                  ExceptionType
  );

/**
  Invalidates processor instruction cache for a memory range. Subsequent execution in this range
  causes a fresh memory fetch to retrieve code to be executed.

  @param  This                  A pointer to the EFI_DEBUG_SUPPORT_PROTOCOL instance.
  @param  ProcessorIndex        Specifies which processor's instruction cache is to be invalidated.
  @param  Start                 Specifies the physical base of the memory range to be invalidated.
  @param  Length                Specifies the minimum number of bytes in the processor's instruction
                                cache to invalidate.

  @retval EFI_SUCCESS           The function completed successfully.

**/
typedef
EFI_STATUS
(__cdecl *EFI_INVALIDATE_INSTRUCTION_CACHE)(
   EFI_DEBUG_SUPPORT_PROTOCOL          *This,
   UINTN                               ProcessorIndex,
   void                                *Start,
   UINT64                              Length
  );

///
/// This protocol provides the services to allow the debug agent to register
/// callback functions that are called either periodically or when specific
/// processor exceptions occur.
///
struct _EFI_DEBUG_SUPPORT_PROTOCOL {
  ///
  /// Declares the processor architecture for this instance of the EFI Debug Support protocol.
  ///
  EFI_INSTRUCTION_SET_ARCHITECTURE    Isa;
  EFI_GET_MAXIMUM_PROCESSOR_INDEX     GetMaximumProcessorIndex;
  EFI_REGISTER_PERIODIC_CALLBACK      RegisterPeriodicCallback;
  EFI_REGISTER_EXCEPTION_CALLBACK     RegisterExceptionCallback;
  EFI_INVALIDATE_INSTRUCTION_CACHE    InvalidateInstructionCache;
};

extern EFI_GUID  gEfiDebugSupportProtocolGuid;

#line 956 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Protocol/DebugSupport.h"
#line 20 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiStatusCode.h"

///
/// Status Code Type Definition.
///
typedef UINT32 EFI_STATUS_CODE_TYPE;

///
/// A Status Code Type is made up of the code type and severity.
/// All values masked by EFI_STATUS_CODE_RESERVED_MASK are
/// reserved for use by this specification.
///
///@{



///@}

///
/// Definition of code types. All other values masked by
/// EFI_STATUS_CODE_TYPE_MASK are reserved for use by
/// this specification.
///
///@{



///@}

///
/// Definitions of severities, all other values masked by
/// EFI_STATUS_CODE_SEVERITY_MASK are reserved for use by
/// this specification.
/// Uncontained errors are major errors that could not contained
/// to the specific component that is reporting the error.
/// For example, if a memory error was not detected early enough,
/// the bad data could be consumed by other drivers.
///
///@{




///@}

///
/// Status Code Value Definition.
///
typedef UINT32 EFI_STATUS_CODE_VALUE;

///
/// A Status Code Value is made up of the class, subclass, and
/// an operation.
///
///@{



///@}

///
/// Definition of Status Code extended data header.
/// The data will follow HeaderSize bytes from the beginning of
/// the structure and is Size bytes long.
///
typedef struct {
  ///
  /// The size of the structure. This is specified to enable future expansion.
  ///
  UINT16      HeaderSize;
  ///
  /// The size of the data in bytes. This does not include the size of the header structure.
  ///
  UINT16      Size;
  ///
  /// The GUID defining the type of the data.
  ///
  EFI_GUID    Type;
} EFI_STATUS_CODE_DATA;

///
/// General partitioning scheme for Progress and Error Codes are:
///   - 0x0000-0x0FFF    Shared by all sub-classes in a given class.
///   - 0x1000-0x7FFF    Subclass Specific.
///   - 0x8000-0xFFFF    OEM specific.
///@{


///@}

///
/// Debug Code definitions for all classes and subclass.
/// Only one debug code is defined at this point and should
/// be used for anything that is sent to the debug stream.
///
///@{

///@}

///
/// Class definitions.
/// Values of 4-127 are reserved for future use by this specification.
/// Values in the range 127-255 are reserved for OEM use.
///
///@{




///@}

///
/// Computing Unit Subclass definitions.
/// Values of 8-127 are reserved for future use by this specification.
/// Values of 128-255 are reserved for OEM use.
///
///@{







///@}

///
/// Computing Unit Class Progress Code definitions.
/// These are shared by all subclasses.
///
///@{


///@}

//
// Computing Unit Unspecified Subclass Progress Code definitions.
//

///
/// Computing Unit Host Processor Subclass Progress Code definitions.
///@{









///@}

//
// Computing Unit Firmware Processor Subclass Progress Code definitions.
//

//
// Computing Unit IO Processor Subclass Progress Code definitions.
//

///
/// Computing Unit Cache Subclass Progress Code definitions.
///
///@{


///@}

///
/// Computing Unit Memory Subclass Progress Code definitions.
///
///@{







///@}

//
// Computing Unit Chipset Subclass Progress Code definitions.
//

///
/// South Bridge initialization prior to memory detection.
///


///
/// North Bridge initialization prior to memory detection.
///


///
/// South Bridge initialization after memory detection.
///


///
/// North Bridge initialization after memory detection.
///


///
/// PCI Host Bridge DXE initialization.
///


///
/// North Bridge DXE initialization.
///


///
/// North Bridge specific SMM initialization in DXE.
///


///
/// Initialization of the South Bridge specific UEFI Runtime Services.
///


///
/// South Bridge DXE initialization
///


///
/// South Bridge specific SMM initialization in DXE.
///


///
/// Initialization of the South Bridge devices.
///


///
/// Computing Unit Class Error Code definitions.
/// These are shared by all subclasses.
///
///@{





///@}

//
// Computing Unit Unspecified Subclass Error Code definitions.
//

///
/// Computing Unit Host Processor Subclass Error Code definitions.
///
///@{














///@}

///
/// Computing Unit Firmware Processor Subclass Error Code definitions.
///
///@{



///@}

//
// Computing Unit IO Processor Subclass Error Code definitions.
//

///
/// Computing Unit Cache Subclass Error Code definitions.
///
///@{




///@}

///
/// Computing Unit Memory Subclass Error Code definitions.
///
///@{











///@}

///
/// Computing Unit Chipset Subclass Error Code definitions.
///
///@{




///@}

///
/// Peripheral Subclass definitions.
/// Values of 12-127 are reserved for future use by this specification.
/// Values of 128-255 are reserved for OEM use.
///
///@{















///@}

///
/// Peripheral Class Progress Code definitions.
/// These are shared by all subclasses.
///
///@{








///@}

//
// Peripheral Class Unspecified Subclass Progress Code definitions.
//

///
/// Peripheral Class Keyboard Subclass Progress Code definitions.
///
///@{


///@}

///
/// Peripheral Class Mouse Subclass Progress Code definitions.
///
///@{

///@}

//
// Peripheral Class Local Console Subclass Progress Code definitions.
//

//
// Peripheral Class Remote Console Subclass Progress Code definitions.
//

///
/// Peripheral Class Serial Port Subclass Progress Code definitions.
///
///@{

///@}

//
// Peripheral Class Parallel Port Subclass Progress Code definitions.
//

//
// Peripheral Class Fixed Media Subclass Progress Code definitions.
//

//
// Peripheral Class Removable Media Subclass Progress Code definitions.
//

//
// Peripheral Class Audio Input Subclass Progress Code definitions.
//

//
// Peripheral Class Audio Output Subclass Progress Code definitions.
//

//
// Peripheral Class LCD Device Subclass Progress Code definitions.
//

//
// Peripheral Class Network Subclass Progress Code definitions.
//

///
/// Peripheral Class Error Code definitions.
/// These are shared by all subclasses.
///
///@{










///@}

//
// Peripheral Class Unspecified Subclass Error Code definitions.
//

///
/// Peripheral Class Keyboard Subclass Error Code definitions.
///
///@{



///@}

///
/// Peripheral Class Mouse Subclass Error Code definitions.
///
///@{

///@}

//
// Peripheral Class Local Console Subclass Error Code definitions.
//

//
// Peripheral Class Remote Console Subclass Error Code definitions.
//

//
// Peripheral Class Serial Port Subclass Error Code definitions.
//

//
// Peripheral Class Parallel Port Subclass Error Code definitions.
//

//
// Peripheral Class Fixed Media Subclass Error Code definitions.
//

//
// Peripheral Class Removable Media Subclass Error Code definitions.
//

//
// Peripheral Class Audio Input Subclass Error Code definitions.
//

//
// Peripheral Class Audio Output Subclass Error Code definitions.
//

//
// Peripheral Class LCD Device Subclass Error Code definitions.
//

//
// Peripheral Class Network Subclass Error Code definitions.
//

///
/// IO Bus Subclass definitions.
/// Values of 14-127 are reserved for future use by this specification.
/// Values of 128-255 are reserved for OEM use.
///
///@{













///@}

///
/// IO Bus Class Progress Code definitions.
/// These are shared by all subclasses.
///
///@{







///@}

//
// IO Bus Class Unspecified Subclass Progress Code definitions.
//

///
/// IO Bus Class PCI Subclass Progress Code definitions.
///
///@{



///@}

//
// IO Bus Class USB Subclass Progress Code definitions.
//

//
// IO Bus Class IBA Subclass Progress Code definitions.
//

//
// IO Bus Class AGP Subclass Progress Code definitions.
//

//
// IO Bus Class PC Card Subclass Progress Code definitions.
//

//
// IO Bus Class LPC Subclass Progress Code definitions.
//

//
// IO Bus Class SCSI Subclass Progress Code definitions.
//

//
// IO Bus Class ATA/ATAPI Subclass Progress Code definitions.
//




//
// IO Bus Class FC Subclass Progress Code definitions.
//

//
// IO Bus Class IP Network Subclass Progress Code definitions.
//

//
// IO Bus Class SMBUS Subclass Progress Code definitions.
//

//
// IO Bus Class I2C Subclass Progress Code definitions.
//

///
/// IO Bus Class Error Code definitions.
/// These are shared by all subclasses.
///
///@{










///@}

//
// IO Bus Class Unspecified Subclass Error Code definitions.
//

///
/// IO Bus Class PCI Subclass Error Code definitions.
///
///@{


///@}

//
// IO Bus Class USB Subclass Error Code definitions.
//

//
// IO Bus Class IBA Subclass Error Code definitions.
//

//
// IO Bus Class AGP Subclass Error Code definitions.
//

//
// IO Bus Class PC Card Subclass Error Code definitions.
//

//
// IO Bus Class LPC Subclass Error Code definitions.
//

//
// IO Bus Class SCSI Subclass Error Code definitions.
//

//
// IO Bus Class ATA/ATAPI Subclass Error Code definitions.
//



//
// IO Bus Class FC Subclass Error Code definitions.
//

//
// IO Bus Class IP Network Subclass Error Code definitions.
//

//
// IO Bus Class SMBUS Subclass Error Code definitions.
//

//
// IO Bus Class I2C Subclass Error Code definitions.
//

///
/// Software Subclass definitions.
/// Values of 14-127 are reserved for future use by this specification.
/// Values of 128-255 are reserved for OEM use.
///
///@{






















///@}

///
/// Software Class Progress Code definitions.
/// These are shared by all subclasses.
///
///@{








///@}

//
// Software Class Unspecified Subclass Progress Code definitions.
//

///
/// Software Class SEC Subclass Progress Code definitions.
///
///@{


///@}

///
/// Software Class PEI Core Subclass Progress Code definitions.
///
///@{



///@}

///
/// Software Class PEI Module Subclass Progress Code definitions.
///
///@{








///@}

///
/// Software Class DXE Core Subclass Progress Code definitions.
///
///@{





///@}

///
/// Software Class DXE BS Driver Subclass Progress Code definitions.
///
///@{










///@}

//
// Software Class SMM Driver Subclass Progress Code definitions.
//

//
// Software Class EFI Application Subclass Progress Code definitions.
//

//
// Software Class EFI OS Loader Subclass Progress Code definitions.
//

///
/// Software Class EFI RT Subclass Progress Code definitions.
///
///@{



///@}

//
// Software Class X64 Exception Subclass Progress Code definitions.
//

//
// Software Class ARM Exception Subclass Progress Code definitions.
//

//
// Software Class EBC Exception Subclass Progress Code definitions.
//

//
// Software Class IA32 Exception Subclass Progress Code definitions.
//

//
// Software Class X64 Exception Subclass Progress Code definitions.
//

//
// Software Class IPF Exception Subclass Progress Code definitions.
//

///
/// Software Class PEI Services Subclass Progress Code definitions.
///
///@{





















///@}

///
/// Software Class EFI Boot Services Subclass Progress Code definitions.
///
///@{











































///@}

///
/// Software Class EFI Runtime Services Subclass Progress Code definitions.
///
///@{














///@}

///
/// Software Class EFI DXE Services Subclass Progress Code definitions
///
///@{

















///@}

///
/// Software Class Error Code definitions.
/// These are shared by all subclasses.
///
///@{





















///@}

//
// Software Class Unspecified Subclass Error Code definitions.
//

//
// Software Class SEC Subclass Error Code definitions.
//

///
/// Software Class PEI Core Subclass Error Code definitions.
///
///@{



///@}

///
/// Software Class PEI Module Subclass Error Code definitions.
///
///@{










///@}

///
/// Software Class DXE Foundation Subclass Error Code definitions.
///
///@{

///@}

///
/// Software Class DXE Boot Service Driver Subclass Error Code definitions.
///
///@{





///@}

//
// Software Class DXE Runtime Service Driver Subclass Error Code definitions.
//

//
// Software Class SMM Driver Subclass Error Code definitions.
//

//
// Software Class EFI Application Subclass Error Code definitions.
//

//
// Software Class EFI OS Loader Subclass Error Code definitions.
//

//
// Software Class EFI RT Subclass Error Code definitions.
//

//
// Software Class EFI AL Subclass Error Code definitions.
//

///
/// Software Class EBC Exception Subclass Error Code definitions.
/// These exceptions are derived from the debug protocol definitions in the EFI
/// specification.
///
///@{











///@}

///
/// Software Class IA32 Exception Subclass Error Code definitions.
/// These exceptions are derived from the debug protocol definitions in the EFI
/// specification.
///
///@{

















///@}

///
/// Software Class IPF Exception Subclass Error Code definitions.
/// These exceptions are derived from the debug protocol definitions in the EFI
/// specification.
///
///@{












///@}

///
/// Software Class PEI Service Subclass Error Code definitions.
///
///@{


///@}

//
// Software Class EFI Boot Service Subclass Error Code definitions.
//

//
// Software Class EFI Runtime Service Subclass Error Code definitions.
//

///
/// Software Class EFI DXE Service Subclass Error Code definitions.
///
///@{


///@}

///
/// Software Class DXE RT Driver Subclass Progress Code definitions.
///
///@{






///@}

///
/// Software Class X64 Exception Subclass Error Code definitions.
/// These exceptions are derived from the debug protocol
/// definitions in the EFI specification.
///
///@{

















///@}

///
/// Software Class ARM Exception Subclass Error Code definitions.
/// These exceptions are derived from the debug protocol
/// definitions in the EFI specification.
///
///@{








///@}

#line 1209 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiStatusCode.h"
#line 21 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiS3BootScript.h"
/** @file
  This file contains the boot script defintions that are shared between the
  Boot Script Executor PPI and the Boot Script Save Protocol.

  Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




// *******************************************
// EFI Boot Script Opcode definitions
// *******************************************


















// *******************************************
// EFI_BOOT_SCRIPT_WIDTH
// *******************************************
typedef enum {
  EfiBootScriptWidthUint8,
  EfiBootScriptWidthUint16,
  EfiBootScriptWidthUint32,
  EfiBootScriptWidthUint64,
  EfiBootScriptWidthFifoUint8,
  EfiBootScriptWidthFifoUint16,
  EfiBootScriptWidthFifoUint32,
  EfiBootScriptWidthFifoUint64,
  EfiBootScriptWidthFillUint8,
  EfiBootScriptWidthFillUint16,
  EfiBootScriptWidthFillUint32,
  EfiBootScriptWidthFillUint64,
  EfiBootScriptWidthMaximum
} EFI_BOOT_SCRIPT_WIDTH;

#line 54 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiS3BootScript.h"
#line 22 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"

/**
  Produces an error code in the range reserved for use by the Platform Initialization
  Architecture Specification.

  The supported 32-bit range is 0xA0000000-0xBFFFFFFF
  The supported 64-bit range is 0xA000000000000000-0xBFFFFFFFFFFFFFFF

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x1FFFFFFF.

  @return The value specified by StatusCode in the PI reserved range.

**/


///
/// If this value is returned by an EFI image, then the image should be unloaded.
///


///
/// If this value is returned by an API, it means the capability is not yet
/// installed/available/ready to use.
///


///
/// Success and warning codes reserved for use by PI.
/// Supported 32-bit range is 0x20000000-0x3fffffff.
/// Supported 64-bit range is 0x2000000000000000-0x3fffffffffffffff.
///


///
/// Error codes reserved for use by PI.
/// Supported 32-bit range is 0xa0000000-0xbfffffff.
/// Supported 64-bit range is 0xa000000000000000-0xbfffffffffffffff.
///


///
/// Return status codes defined in SMM CIS.
///





///
/// Bitmask of values for Authentication Status.
/// Authentication Status is returned from EFI_GUIDED_SECTION_EXTRACTION_PROTOCOL
/// and the EFI_PEI_GUIDED_SECTION_EXTRACTION_PPI
///
/// xx00 Image was not signed.
/// xxx1 Platform security policy override. Assumes the same meaning as 0010 (the image was signed, the
///      signature was tested, and the signature passed authentication test).
/// 0010 Image was signed, the signature was tested, and the signature passed authentication test.
/// 0110 Image was signed and the signature was not tested.
/// 1010 Image was signed, the signature was tested, and the signature failed the authentication test.
///
///@{





///@}

///
/// MMRAM states and capabilities
///












///
/// Structure describing a MMRAM region and its accessibility attributes.
///
typedef struct {
  ///
  /// Designates the physical address of the MMRAM in memory. This view of memory is
  /// the same as seen by I/O-based agents, for example, but it may not be the address seen
  /// by the processors.
  ///
  EFI_PHYSICAL_ADDRESS    PhysicalStart;
  ///
  /// Designates the address of the MMRAM, as seen by software executing on the
  /// processors. This address may or may not match PhysicalStart.
  ///
  EFI_PHYSICAL_ADDRESS    CpuStart;
  ///
  /// Describes the number of bytes in the MMRAM region.
  ///
  UINT64                  PhysicalSize;
  ///
  /// Describes the accessibility attributes of the MMRAM.  These attributes include the
  /// hardware state (e.g., Open/Closed/Locked), capability (e.g., cacheable), logical
  /// allocation (e.g., allocated), and pre-use initialization (e.g., needs testing/ECC
  /// initialization).
  ///
  UINT64                  RegionState;
} EFI_MMRAM_DESCRIPTOR;

typedef EFI_MMRAM_DESCRIPTOR EFI_SMRAM_DESCRIPTOR;

///
/// Structure describing a MMRAM region which cannot be used for the MMRAM heap.
///
typedef struct _EFI_MM_RESERVED_MMRAM_REGION {
  ///
  /// Starting address of the reserved MMRAM area, as it appears while MMRAM is open.
  /// Ignored if MmramReservedSize is 0.
  ///
  EFI_PHYSICAL_ADDRESS    MmramReservedStart;
  ///
  /// Number of bytes occupied by the reserved MMRAM area. A size of zero indicates the
  /// last MMRAM area.
  ///
  UINT64                  MmramReservedSize;
} EFI_MM_RESERVED_MMRAM_REGION;

typedef enum {
  EFI_PCD_TYPE_8,
  EFI_PCD_TYPE_16,
  EFI_PCD_TYPE_32,
  EFI_PCD_TYPE_64,
  EFI_PCD_TYPE_BOOL,
  EFI_PCD_TYPE_PTR
} EFI_PCD_TYPE;

typedef struct {
  ///
  /// The returned information associated with the requested TokenNumber. If
  /// TokenNumber is 0, then PcdType is set to EFI_PCD_TYPE_8.
  ///
  EFI_PCD_TYPE    PcdType;
  ///
  /// The size of the data in bytes associated with the TokenNumber specified. If
  /// TokenNumber is 0, then PcdSize is set 0.
  ///
  UINTN           PcdSize;
  ///
  /// The null-terminated ASCII string associated with a given token. If the
  /// TokenNumber specified was 0, then this field corresponds to the null-terminated
  /// ASCII string associated with the token's namespace Guid. If NULL, there is no
  /// name associated with this request.
  ///
  CHAR8           *PcdName;
} EFI_PCD_INFO;

/**
  The function prototype for invoking a function on an Application Processor.

  This definition is used by the UEFI MP Serices Protocol, and the
  PI SMM System Table.

  @param[in,out] Buffer  The pointer to private data buffer.
**/
typedef
void
(__cdecl *EFI_AP_PROCEDURE)(
    void  *Buffer
  );

/**
  The function prototype for invoking a function on an Application Processor.

  This definition is used by the UEFI MM MP Serices Protocol.

  @param[in] ProcedureArgument    The pointer to private data buffer.

  @retval EFI_SUCCESS             Excutive the procedure successfully

**/
typedef
EFI_STATUS
(__cdecl *EFI_AP_PROCEDURE2)(
   void  *ProcedureArgument
  );

#line 212 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiMultiPhase.h"
#line 17 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiDxeCis.h"

///
/// Global Coherencey Domain types - Memory type.
///
typedef enum {
  ///
  /// A memory region that is visible to the boot processor. However, there are no system
  /// components that are currently decoding this memory region.
  ///
  EfiGcdMemoryTypeNonExistent,
  ///
  /// A memory region that is visible to the boot processor. This memory region is being
  /// decoded by a system component, but the memory region is not considered to be either
  /// system memory or memory-mapped I/O.
  ///
  EfiGcdMemoryTypeReserved,
  ///
  /// A memory region that is visible to the boot processor. A memory controller is
  /// currently decoding this memory region and the memory controller is producing a
  /// tested system memory region that is available to the memory services.
  ///
  EfiGcdMemoryTypeSystemMemory,
  ///
  /// A memory region that is visible to the boot processor. This memory region is
  /// currently being decoded by a component as memory-mapped I/O that can be used to
  /// access I/O devices in the platform.
  ///
  EfiGcdMemoryTypeMemoryMappedIo,
  ///
  /// A memory region that is visible to the boot processor.
  /// This memory supports byte-addressable non-volatility.
  ///
  EfiGcdMemoryTypePersistent,
  //
  // Keep original one for the compatibility.
  //
  EfiGcdMemoryTypePersistentMemory = EfiGcdMemoryTypePersistent,
  ///
  /// A memory region that provides higher reliability relative to other memory in the
  /// system. If all memory has the same reliability, then this bit is not used.
  ///
  EfiGcdMemoryTypeMoreReliable,
  ///
  /// A memory region that describes system memory that has not been accepted
  /// by a corresponding call to the underlying isolation architecture.
  ///
  EfiGcdMemoryTypeUnaccepted,
  EfiGcdMemoryTypeMaximum = 7
} EFI_GCD_MEMORY_TYPE;

///
/// Global Coherencey Domain types - IO type.
///
typedef enum {
  ///
  /// An I/O region that is visible to the boot processor. However, there are no system
  /// components that are currently decoding this I/O region.
  ///
  EfiGcdIoTypeNonExistent,
  ///
  /// An I/O region that is visible to the boot processor. This I/O region is currently being
  /// decoded by a system component, but the I/O region cannot be used to access I/O devices.
  ///
  EfiGcdIoTypeReserved,
  ///
  /// An I/O region that is visible to the boot processor. This I/O region is currently being
  /// decoded by a system component that is producing I/O ports that can be used to access I/O devices.
  ///
  EfiGcdIoTypeIo,
  EfiGcdIoTypeMaximum
} EFI_GCD_IO_TYPE;

///
/// The type of allocation to perform.
///
typedef enum {
  ///
  /// The GCD memory space map is searched from the lowest address up to the highest address
  /// looking for unallocated memory ranges.
  ///
  EfiGcdAllocateAnySearchBottomUp,
  ///
  /// The GCD memory space map is searched from the lowest address up
  /// to the specified MaxAddress looking for unallocated memory ranges.
  ///
  EfiGcdAllocateMaxAddressSearchBottomUp,
  ///
  /// The GCD memory space map is checked to see if the memory range starting
  /// at the specified Address is available.
  ///
  EfiGcdAllocateAddress,
  ///
  /// The GCD memory space map is searched from the highest address down to the lowest address
  /// looking for unallocated memory ranges.
  ///
  EfiGcdAllocateAnySearchTopDown,
  ///
  /// The GCD memory space map is searched from the specified MaxAddress
  /// down to the lowest address looking for unallocated memory ranges.
  ///
  EfiGcdAllocateMaxAddressSearchTopDown,
  EfiGcdMaxAllocateType
} EFI_GCD_ALLOCATE_TYPE;

///
/// EFI_GCD_MEMORY_SPACE_DESCRIPTOR.
///
typedef struct {
  ///
  /// The physical address of the first byte in the memory region. Type
  /// EFI_PHYSICAL_ADDRESS is defined in the AllocatePages() function
  /// description in the UEFI 2.0 specification.
  ///
  EFI_PHYSICAL_ADDRESS    BaseAddress;

  ///
  /// The number of bytes in the memory region.
  ///
  UINT64                  Length;

  ///
  /// The bit mask of attributes that the memory region is capable of supporting. The bit
  /// mask of available attributes is defined in the GetMemoryMap() function description
  /// in the UEFI 2.0 specification.
  ///
  UINT64                  Capabilities;
  ///
  /// The bit mask of attributes that the memory region is currently using. The bit mask of
  /// available attributes is defined in GetMemoryMap().
  ///
  UINT64                  Attributes;
  ///
  /// Type of the memory region. Type EFI_GCD_MEMORY_TYPE is defined in the
  /// AddMemorySpace() function description.
  ///
  EFI_GCD_MEMORY_TYPE     GcdMemoryType;

  ///
  /// The image handle of the agent that allocated the memory resource described by
  /// PhysicalStart and NumberOfBytes. If this field is NULL, then the memory
  /// resource is not currently allocated. Type EFI_HANDLE is defined in
  /// InstallProtocolInterface() in the UEFI 2.0 specification.
  ///
  EFI_HANDLE              ImageHandle;

  ///
  /// The device handle for which the memory resource has been allocated. If
  /// ImageHandle is NULL, then the memory resource is not currently allocated. If this
  /// field is NULL, then the memory resource is not associated with a device that is
  /// described by a device handle. Type EFI_HANDLE is defined in
  /// InstallProtocolInterface() in the UEFI 2.0 specification.
  ///
  EFI_HANDLE    DeviceHandle;
} EFI_GCD_MEMORY_SPACE_DESCRIPTOR;

///
/// EFI_GCD_IO_SPACE_DESCRIPTOR.
///
typedef struct {
  ///
  /// Physical address of the first byte in the I/O region. Type
  /// EFI_PHYSICAL_ADDRESS is defined in the AllocatePages() function
  /// description in the UEFI 2.0 specification.
  ///
  EFI_PHYSICAL_ADDRESS    BaseAddress;

  ///
  /// Number of bytes in the I/O region.
  ///
  UINT64                  Length;

  ///
  /// Type of the I/O region. Type EFI_GCD_IO_TYPE is defined in the
  /// AddIoSpace() function description.
  ///
  EFI_GCD_IO_TYPE         GcdIoType;

  ///
  /// The image handle of the agent that allocated the I/O resource described by
  /// PhysicalStart and NumberOfBytes. If this field is NULL, then the I/O
  /// resource is not currently allocated. Type EFI_HANDLE is defined in
  /// InstallProtocolInterface() in the UEFI 2.0 specification.
  ///
  EFI_HANDLE              ImageHandle;

  ///
  /// The device handle for which the I/O resource has been allocated. If ImageHandle
  /// is NULL, then the I/O resource is not currently allocated. If this field is NULL, then
  /// the I/O resource is not associated with a device that is described by a device handle.
  /// Type EFI_HANDLE is defined in InstallProtocolInterface() in the UEFI
  /// 2.0 specification.
  ///
  EFI_HANDLE    DeviceHandle;
} EFI_GCD_IO_SPACE_DESCRIPTOR;

/**
  Adds reserved memory, system memory, or memory-mapped I/O resources to the
  global coherency domain of the processor.

  @param  GcdMemoryType    The type of memory resource being added.
  @param  BaseAddress      The physical address that is the start address
                           of the memory resource being added.
  @param  Length           The size, in bytes, of the memory resource that
                           is being added.
  @param  Capabilities     The bit mask of attributes that the memory
                           resource region supports.

  @retval EFI_SUCCESS            The memory resource was added to the global
                                 coherency domain of the processor.
  @retval EFI_INVALID_PARAMETER  GcdMemoryType is invalid.
  @retval EFI_INVALID_PARAMETER  Length is zero.
  @retval EFI_OUT_OF_RESOURCES   There are not enough system resources to add
                                 the memory resource to the global coherency
                                 domain of the processor.
  @retval EFI_UNSUPPORTED        The processor does not support one or more bytes
                                 of the memory resource range specified by
                                 BaseAddress and Length.
  @retval EFI_ACCESS_DENIED      One or more bytes of the memory resource range
                                 specified by BaseAddress and Length conflicts
                                 with a memory resource range that was previously
                                 added to the global coherency domain of the processor.
  @retval EFI_ACCESS_DENIED      One or more bytes of the memory resource range
                                 specified by BaseAddress and Length was allocated
                                 in a prior call to AllocateMemorySpace().

**/
typedef
EFI_STATUS
(__cdecl *EFI_ADD_MEMORY_SPACE)(
   EFI_GCD_MEMORY_TYPE   GcdMemoryType,
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length,
   UINT64                Capabilities
  );

/**
  Allocates nonexistent memory, reserved memory, system memory, or memorymapped
  I/O resources from the global coherency domain of the processor.

  @param  GcdAllocateType  The type of allocation to perform.
  @param  GcdMemoryType    The type of memory resource being allocated.
  @param  Alignment        The log base 2 of the boundary that BaseAddress must
                           be aligned on output. Align with 2^Alignment.
  @param  Length           The size in bytes of the memory resource range that
                           is being allocated.
  @param  BaseAddress      A pointer to a physical address to allocate.
  @param  Imagehandle      The image handle of the agent that is allocating
                           the memory resource.
  @param  DeviceHandle     The device handle for which the memory resource
                           is being allocated.

  @retval EFI_INVALID_PARAMETER GcdAllocateType is invalid.
  @retval EFI_INVALID_PARAMETER GcdMemoryType is invalid.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_INVALID_PARAMETER BaseAddress is NULL.
  @retval EFI_INVALID_PARAMETER ImageHandle is NULL.
  @retval EFI_NOT_FOUND         The memory resource request could not be satisfied.
                                No descriptor contains the desired space.
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to allocate the memory
                                resource from the global coherency domain of the processor.
  @retval EFI_SUCCESS           The memory resource was allocated from the global coherency
                                domain of the processor.


**/
typedef
EFI_STATUS
(__cdecl *EFI_ALLOCATE_MEMORY_SPACE)(
       EFI_GCD_ALLOCATE_TYPE               GcdAllocateType,
       EFI_GCD_MEMORY_TYPE                 GcdMemoryType,
       UINTN                               Alignment,
       UINT64                              Length,
    EFI_PHYSICAL_ADDRESS                *BaseAddress,
       EFI_HANDLE                          ImageHandle,
       EFI_HANDLE                          DeviceHandle 
  );

/**
  Frees nonexistent memory, reserved memory, system memory, or memory-mapped
  I/O resources from the global coherency domain of the processor.

  @param  BaseAddress      The physical address that is the start address of the memory resource being freed.
  @param  Length           The size in bytes of the memory resource range that is being freed.

  @retval EFI_SUCCESS           The memory resource was freed from the global coherency domain of
                                the processor.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the memory
                                resource range specified by BaseAddress and Length.
  @retval EFI_NOT_FOUND         The memory resource range specified by BaseAddress and
                                Length was not allocated with previous calls to AllocateMemorySpace().
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to free the memory resource
                                from the global coherency domain of the processor.

**/
typedef
EFI_STATUS
(__cdecl *EFI_FREE_MEMORY_SPACE)(
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length
  );

/**
  Removes reserved memory, system memory, or memory-mapped I/O resources from
  the global coherency domain of the processor.

  @param  BaseAddress      The physical address that is the start address of the memory resource being removed.
  @param  Length           The size in bytes of the memory resource that is being removed.

  @retval EFI_SUCCESS           The memory resource was removed from the global coherency
                                domain of the processor.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the memory
                                resource range specified by BaseAddress and Length.
  @retval EFI_NOT_FOUND         One or more bytes of the memory resource range specified by
                                BaseAddress and Length was not added with previous calls to
                                AddMemorySpace().
  @retval EFI_ACCESS_DEFINED    One or more bytes of the memory resource range specified by
                                BaseAddress and Length has been allocated with AllocateMemorySpace().
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to remove the memory
                                resource from the global coherency domain of the processor.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REMOVE_MEMORY_SPACE)(
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length
  );

/**
  Retrieves the descriptor for a memory region containing a specified address.

  @param  BaseAddress      The physical address that is the start address of a memory region.
  @param  Descriptor       A pointer to a caller allocated descriptor.

  @retval EFI_SUCCESS           The descriptor for the memory resource region containing
                                BaseAddress was returned in Descriptor.
  @retval EFI_INVALID_PARAMETER Descriptor is NULL.
  @retval EFI_NOT_FOUND         A memory resource range containing BaseAddress was not found.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_MEMORY_SPACE_DESCRIPTOR)(
    EFI_PHYSICAL_ADDRESS             BaseAddress,
   EFI_GCD_MEMORY_SPACE_DESCRIPTOR  *Descriptor
  );

/**
  Modifies the attributes for a memory region in the global coherency domain of the
  processor.

  @param  BaseAddress      The physical address that is the start address of a memory region.
  @param  Length           The size in bytes of the memory region.
  @param  Attributes       The bit mask of attributes to set for the memory region.

  @retval EFI_SUCCESS           The attributes were set for the memory region.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the memory
                                resource range specified by BaseAddress and Length.
  @retval EFI_UNSUPPORTED       The bit mask of attributes is not support for the memory resource
                                range specified by BaseAddress and Length.
  @retval EFI_ACCESS_DENIED     The attributes for the memory resource range specified by
                                BaseAddress and Length cannot be modified.
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to modify the attributes of
                                the memory resource range.
  @retval EFI_NOT_AVAILABLE_YET The attributes cannot be set because CPU architectural protocol is
                                not available yet.
**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_MEMORY_SPACE_ATTRIBUTES)(
   EFI_PHYSICAL_ADDRESS         BaseAddress,
   UINT64                       Length,
   UINT64                       Attributes
  );

/**
  Modifies the capabilities for a memory region in the global coherency domain of the
  processor.

  @param  BaseAddress      The physical address that is the start address of a memory region.
  @param  Length           The size in bytes of the memory region.
  @param  Capabilities     The bit mask of capabilities that the memory region supports.

  @retval EFI_SUCCESS           The capabilities were set for the memory region.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The capabilities specified by Capabilities do not include the
                                memory region attributes currently in use.
  @retval EFI_ACCESS_DENIED     The capabilities for the memory resource range specified by
                                BaseAddress and Length cannot be modified.
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to modify the capabilities
                                of the memory resource range.
**/
typedef
EFI_STATUS
(__cdecl *EFI_SET_MEMORY_SPACE_CAPABILITIES)(
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length,
   UINT64                Capabilities
  );

/**
  Returns a map of the memory resources in the global coherency domain of the
  processor.

  @param  NumberOfDescriptors A pointer to number of descriptors returned in the MemorySpaceMap buffer.
  @param  MemorySpaceMap      A pointer to the array of EFI_GCD_MEMORY_SPACE_DESCRIPTORs.

  @retval EFI_SUCCESS           The memory space map was returned in the MemorySpaceMap
                                buffer, and the number of descriptors in MemorySpaceMap was
                                returned in NumberOfDescriptors.
  @retval EFI_INVALID_PARAMETER NumberOfDescriptors is NULL.
  @retval EFI_INVALID_PARAMETER MemorySpaceMap is NULL.
  @retval EFI_OUT_OF_RESOURCES  There are not enough resources to allocate MemorySpaceMap.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_MEMORY_SPACE_MAP)(
   UINTN                            *NumberOfDescriptors,
   EFI_GCD_MEMORY_SPACE_DESCRIPTOR  **MemorySpaceMap
  );

/**
  Adds reserved I/O or I/O resources to the global coherency domain of the processor.

  @param  GcdIoType        The type of I/O resource being added.
  @param  BaseAddress      The physical address that is the start address of the I/O resource being added.
  @param  Length           The size in bytes of the I/O resource that is being added.

  @retval EFI_SUCCESS           The I/O resource was added to the global coherency domain of
                                the processor.
  @retval EFI_INVALID_PARAMETER GcdIoType is invalid.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to add the I/O resource to
                                the global coherency domain of the processor.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the I/O
                                resource range specified by BaseAddress and Length.
  @retval EFI_ACCESS_DENIED     One or more bytes of the I/O resource range specified by
                                BaseAddress and Length conflicts with an I/O resource
                                range that was previously added to the global coherency domain
                                of the processor.
  @retval EFI_ACCESS_DENIED     One or more bytes of the I/O resource range specified by
                                BaseAddress and Length was allocated in a prior call to
                                AllocateIoSpace().

**/
typedef
EFI_STATUS
(__cdecl *EFI_ADD_IO_SPACE)(
   EFI_GCD_IO_TYPE       GcdIoType,
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length
  );

/**
  Allocates nonexistent I/O, reserved I/O, or I/O resources from the global coherency
  domain of the processor.

  @param  GcdAllocateType  The type of allocation to perform.
  @param  GcdIoType        The type of I/O resource being allocated.
  @param  Alignment        The log base 2 of the boundary that BaseAddress must be aligned on output.
  @param  Length           The size in bytes of the I/O resource range that is being allocated.
  @param  BaseAddress      A pointer to a physical address.
  @param  Imagehandle      The image handle of the agent that is allocating the I/O resource.
  @param  DeviceHandle     The device handle for which the I/O resource is being allocated.

  @retval EFI_SUCCESS           The I/O resource was allocated from the global coherency domain
                                of the processor.
  @retval EFI_INVALID_PARAMETER GcdAllocateType is invalid.
  @retval EFI_INVALID_PARAMETER GcdIoType is invalid.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_INVALID_PARAMETER BaseAddress is NULL.
  @retval EFI_INVALID_PARAMETER ImageHandle is NULL.
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to allocate the I/O
                                resource from the global coherency domain of the processor.
  @retval EFI_NOT_FOUND         The I/O resource request could not be satisfied.

**/
typedef
EFI_STATUS
(__cdecl *EFI_ALLOCATE_IO_SPACE)(
       EFI_GCD_ALLOCATE_TYPE               GcdAllocateType,
       EFI_GCD_IO_TYPE                     GcdIoType,
       UINTN                               Alignment,
       UINT64                              Length,
    EFI_PHYSICAL_ADDRESS                *BaseAddress,
       EFI_HANDLE                          ImageHandle,
       EFI_HANDLE                          DeviceHandle 
  );

/**
  Frees nonexistent I/O, reserved I/O, or I/O resources from the global coherency
  domain of the processor.

  @param  BaseAddress      The physical address that is the start address of the I/O resource being freed.
  @param  Length           The size in bytes of the I/O resource range that is being freed.

  @retval EFI_SUCCESS           The I/O resource was freed from the global coherency domain of the
                                processor.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the I/O resource
                                range specified by BaseAddress and Length.
  @retval EFI_NOT_FOUND         The I/O resource range specified by BaseAddress and Length
                                was not allocated with previous calls to AllocateIoSpace().
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to free the I/O resource from
                                the global coherency domain of the processor.

**/
typedef
EFI_STATUS
(__cdecl *EFI_FREE_IO_SPACE)(
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length
  );

/**
  Removes reserved I/O or I/O resources from the global coherency domain of the
  processor.

  @param  BaseAddress      A pointer to a physical address that is the start address of the I/O resource being
                           removed.
  @param Length            The size in bytes of the I/O resource that is being removed.

  @retval EFI_SUCCESS           The I/O resource was removed from the global coherency domain
                                of the processor.
  @retval EFI_INVALID_PARAMETER Length is zero.
  @retval EFI_UNSUPPORTED       The processor does not support one or more bytes of the I/O
                                resource range specified by BaseAddress and Length.
  @retval EFI_NOT_FOUND         One or more bytes of the I/O resource range specified by
                                BaseAddress and Length was not added with previous
                                calls to AddIoSpace().
  @retval EFI_ACCESS_DENIED     One or more bytes of the I/O resource range specified by
                                BaseAddress and Length has been allocated with
                                AllocateIoSpace().
  @retval EFI_OUT_OF_RESOURCES  There are not enough system resources to remove the I/O
                                resource from the global coherency domain of the processor.

**/
typedef
EFI_STATUS
(__cdecl *EFI_REMOVE_IO_SPACE)(
   EFI_PHYSICAL_ADDRESS  BaseAddress,
   UINT64                Length
  );

/**
  Retrieves the descriptor for an I/O region containing a specified address.

  @param  BaseAddress      The physical address that is the start address of an I/O region.
  @param  Descriptor       A pointer to a caller allocated descriptor.

  @retval EFI_SUCCESS           The descriptor for the I/O resource region containing
                                BaseAddress was returned in Descriptor.
  @retval EFI_INVALID_PARAMETER Descriptor is NULL.
  @retval EFI_NOT_FOUND         An I/O resource range containing BaseAddress was not found.

**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_IO_SPACE_DESCRIPTOR)(
    EFI_PHYSICAL_ADDRESS         BaseAddress,
   EFI_GCD_IO_SPACE_DESCRIPTOR  *Descriptor
  );

/**
  Returns a map of the I/O resources in the global coherency domain of the processor.

  @param  NumberOfDescriptors A pointer to number of descriptors returned in the IoSpaceMap buffer.
  @param  MemorySpaceMap      A pointer to the array of EFI_GCD_IO_SPACE_DESCRIPTORs.

  @retval EFI_SUCCESS           The I/O space map was returned in the IoSpaceMap buffer, and
                                the number of descriptors in IoSpaceMap was returned in
                                NumberOfDescriptors.
  @retval EFI_INVALID_PARAMETER NumberOfDescriptors is NULL.
  @retval EFI_INVALID_PARAMETER IoSpaceMap is NULL.
  @retval EFI_OUT_OF_RESOURCES  There are not enough resources to allocate IoSpaceMap.


**/
typedef
EFI_STATUS
(__cdecl *EFI_GET_IO_SPACE_MAP)(
   UINTN                        *NumberOfDescriptors,
   EFI_GCD_IO_SPACE_DESCRIPTOR  **IoSpaceMap
  );

/**
  Loads and executed DXE drivers from firmware volumes.

  The Dispatch() function searches for DXE drivers in firmware volumes that have been
  installed since the last time the Dispatch() service was called. It then evaluates
  the dependency expressions of all the DXE drivers and loads and executes those DXE
  drivers whose dependency expression evaluate to TRUE. This service must interact with
  the Security Architectural Protocol to authenticate DXE drivers before they are executed.
  This process is continued until no more DXE drivers can be executed.

  @retval EFI_SUCCESS         One or more DXE driver were dispatched.
  @retval EFI_NOT_FOUND       No DXE drivers were dispatched.
  @retval EFI_ALREADY_STARTED An attempt is being made to start the DXE Dispatcher recursively.
                              Thus, no action was taken.

**/
typedef
EFI_STATUS
(__cdecl *EFI_DISPATCH)(
  void
  );

/**
  Clears the Schedule on Request (SOR) flag for a component that is stored in a firmware volume.

  @param  FirmwareVolumeHandle The handle of the firmware volume that contains the file specified by FileName.
  @param  FileName             A pointer to the name of the file in a firmware volume.

  @retval EFI_SUCCESS         The DXE driver was found and its SOR bit was cleared.
  @retval EFI_NOT_FOUND       The DXE driver does not exist, or the DXE driver exists and its SOR
                              bit is not set.

**/
typedef
EFI_STATUS
(__cdecl *EFI_SCHEDULE)(
   EFI_HANDLE  FirmwareVolumeHandle,
   const EFI_GUID    *FileName
  );

/**
  Promotes a file stored in a firmware volume from the untrusted to the trusted state.

  @param  FirmwareVolumeHandle The handle of the firmware volume that contains the file specified by FileName.
  @param  DriverName           A pointer to the name of the file in a firmware volume.

  @return Status of promoting FFS from untrusted to trusted
          state.
  @retval EFI_NOT_FOUND       The file was not found in the untrusted state.

**/
typedef
EFI_STATUS
(__cdecl *EFI_TRUST)(
   EFI_HANDLE  FirmwareVolumeHandle,
   const EFI_GUID    *FileName
  );

/**
  Creates a firmware volume handle for a firmware volume that is present in system memory.

  @param  FirmwareVolumeHeader A pointer to the header of the firmware volume.
  @param  Size                 The size, in bytes, of the firmware volume.
  @param  FirmwareVolumeHandle On output, a pointer to the created handle.

  @retval EFI_SUCCESS          The EFI_FIRMWARE_VOLUME_PROTOCOL and
                               EFI_DEVICE_PATH_PROTOCOL were installed onto
                               FirmwareVolumeHandle for the firmware volume described
                               by FirmwareVolumeHeader and Size.
  @retval EFI_VOLUME_CORRUPTED The firmware volume described by FirmwareVolumeHeader
                               and Size is corrupted.
  @retval EFI_OUT_OF_RESOURCES There are not enough system resources available to produce the
                               EFI_FIRMWARE_VOLUME_PROTOCOL and EFI_DEVICE_PATH_PROTOCOL
                               for the firmware volume described by FirmwareVolumeHeader and Size.

**/
typedef
EFI_STATUS
(__cdecl *EFI_PROCESS_FIRMWARE_VOLUME)(
   const void                       *FirmwareVolumeHeader,
   UINTN                            Size,
   EFI_HANDLE                      *FirmwareVolumeHandle
  );

//
// DXE Services Table
//





typedef struct {
  ///
  /// The table header for the DXE Services Table.
  /// This header contains the DXE_SERVICES_SIGNATURE and DXE_SERVICES_REVISION values.
  ///
  EFI_TABLE_HEADER                     Hdr;

  //
  // Global Coherency Domain Services
  //
  EFI_ADD_MEMORY_SPACE                 AddMemorySpace;
  EFI_ALLOCATE_MEMORY_SPACE            AllocateMemorySpace;
  EFI_FREE_MEMORY_SPACE                FreeMemorySpace;
  EFI_REMOVE_MEMORY_SPACE              RemoveMemorySpace;
  EFI_GET_MEMORY_SPACE_DESCRIPTOR      GetMemorySpaceDescriptor;
  EFI_SET_MEMORY_SPACE_ATTRIBUTES      SetMemorySpaceAttributes;
  EFI_GET_MEMORY_SPACE_MAP             GetMemorySpaceMap;
  EFI_ADD_IO_SPACE                     AddIoSpace;
  EFI_ALLOCATE_IO_SPACE                AllocateIoSpace;
  EFI_FREE_IO_SPACE                    FreeIoSpace;
  EFI_REMOVE_IO_SPACE                  RemoveIoSpace;
  EFI_GET_IO_SPACE_DESCRIPTOR          GetIoSpaceDescriptor;
  EFI_GET_IO_SPACE_MAP                 GetIoSpaceMap;

  //
  // Dispatcher Services
  //
  EFI_DISPATCH                         Dispatch;
  EFI_SCHEDULE                         Schedule;
  EFI_TRUST                            Trust;
  //
  // Service to process a single firmware volume found in a capsule
  //
  EFI_PROCESS_FIRMWARE_VOLUME          ProcessFirmwareVolume;
  //
  // Extensions to Global Coherency Domain Services
  //
  EFI_SET_MEMORY_SPACE_CAPABILITIES    SetMemorySpaceCapabilities;
} DXE_SERVICES;

typedef DXE_SERVICES EFI_DXE_SERVICES;

#line 741 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Pi/PiDxeCis.h"
#line 17 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\PiDxe.h"

#line 19 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\PiDxe.h"
#line 17 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\AutoGen.h"
#line 1 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Library/PcdLib.h"
/** @file
  Provides library services to get and set Platform Configuration Database entries.

  PCD Library Class provides a PCD usage macro interface for all PCD types.
  It should be included in any module that uses PCD. If a module uses dynamic/dynamicex
  PCD, module should be linked to a PEIM/DXE library instance to access that PCD.
  If a module uses PatchableInModule type PCD, it also needs the library instance to produce
  LibPatchPcdSetPtr() interface. For FeatureFlag/Fixed PCD, the macro interface is
  translated to a variable or macro that is auto-generated by build tool in
  module's autogen.h/autogen.c.
  The PcdGetXX(), PcdSetXX(), PcdToken(), and PcdGetNextTokenSpace() operations are
  only available prior to ExitBootServices().  If access to PCD values are required
  at runtime, then their values must be collected prior to ExitBootServices().
  There are no restrictions on the use of FeaturePcd(), FixedPcdGetXX(),
  PatchPcdGetXX(), and PatchPcdSetXX().

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




/**
  Retrieves a token number based on a token name.

  Returns the token number associated with the PCD token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve the token number for.

  @return  The token number associated with the PCD.

**/


/**
  Retrieves a Boolean PCD feature flag based on a token name.

  Returns the Boolean value for the PCD feature flag specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a feature flag PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  Boolean value for the PCD feature flag.

**/


/**
  Retrieves an 8-bit fixed PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 16-bit fixed PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 32-bit fixed PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 64-bit fixed PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/


/**
  Retrieves a Boolean fixed PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/


/**
  Retrieves a pointer to a fixed PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/


/**
  Retrieves an 8-bit binary patchable PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  An 8-bit binary patchable PCD token value.

**/


/**
  Retrieves a 16-bit binary patchable PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 16-bit binary patchable PCD token value.

**/


/**
  Retrieves a 32-bit binary patchable PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 32-bit binary patchable PCD token value.

**/


/**
  Retrieves a 64-bit binary patchable PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 64-bit binary patchable PCD token value.

**/


/**
  Retrieves a Boolean binary patchable PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/


/**
  Retrieves a pointer to a binary patchable PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer for the token.

**/


/**
  Sets an 8-bit binary patchable PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 8-bit value to set.

  @return Return the Value that was set.

**/


/**
  Sets a 16-bit binary patchable PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 16-bit value to set.

  @return Return the Value that was set.

**/


/**
  Sets a 32-bit binary patchable PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 32-bit value to set.

  @return Return the Value that was set.

**/


/**
  Sets a 64-bit binary patchable PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 64-bit value to set.

  @return Return the Value that was set.

**/


/**
  Sets a Boolean binary patchable PCD token value based on a token name.

  Sets the Boolean value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The boolean value to set.

  @return Return the Value that was set.

**/


/**
  Sets a pointer to a binary patchable PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.  Buffer is returned.
  If SizeOfBuffer is greater than the maximum size supported by TokenName, then set SizeOfBuffer
  to the maximum size supported by TokenName and return NULL to indicate that the set operation
  was not actually performed.  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be
  set to the maximum size supported by TokenName and NULL must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param   TokenName      The name of the binary patchable PCD token to set the current value for.
  @param   SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param   Buffer         Pointer to the value to set.

  @return Return the pointer to the Buffer that was set.

**/









/**
  Retrieves an 8-bit PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 16-bit PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 32-bit PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/


/**
  Retrieves a 64-bit PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/


/**
  Retrieves a pointer to a PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/


/**
  Retrieves a Boolean PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/


/**
  Retrieves the size of a fixed PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/


/**
  Retrieves the size of a binary patchable PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/


/**
  Retrieves the size of the PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]   TokenName  The name of the PCD token to retrieve a current value size for.

  @return      Return the size

**/


/**
  Retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value size for.

  @return     Return the size.

**/


/**
  Sets a 8-bit PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 16-bit PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 32-bit PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 64-bit PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.
  If SizeOfBuffer is greater than the maximum size supported by TokenName,
  then set SizeOfBuffer to the maximum size supported by TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         A pointer to the buffer to set.

  @return The status of the set operation.

**/



/**
  Sets a boolean PCD token value based on a token name.

  Sets the boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/


/**
  Retrieves a token number based on a GUID and a token name.

  Returns the token number for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  Return the token number.

**/


/**
  Retrieves an 8-bit PCD token value based on a GUID and a token name.

  Returns the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  An 8-bit PCD token value.

**/


/**
  Retrieves a 16-bit PCD token value based on a GUID and a token name.

  Returns the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 16-bit PCD token value.

**/


/**
  Retrieves a 32-bit PCD token value based on a GUID and a token name.

  Returns the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 32-bit PCD token value.

**/


/**
  Retrieves a 64-bit PCD token value based on a GUID and a token name.

  Returns the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 64-bit PCD token value.

**/


/**
  Retrieves a pointer to a PCD token buffer based on a GUID and a token name.

  Returns a pointer to the buffer for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A pointer to a PCD token buffer.

**/


/**
  Retrieves a Boolean PCD token value based on a GUID and a token name.

  Returns the Boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/


/**
  Sets an 8-bit PCD token value based on a GUID and a token name.

  Sets the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 16-bit PCD token value based on a GUID and a token name.

  Sets the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 32-bit PCD token value based on a GUID and a token name.

  Sets the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 64-bit PCD token value based on a GUID and a token name.

  Sets the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a GUID and a token name.

  Sets the buffer for the token specified by Guid and TokenName.
  If SizeOfBuffer is greater than the maximum size supported by Guid and TokenName,
  then set SizeOfBuffer to the maximum size supported by Guid and TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by Guid and TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param Guid           Pointer to a 128-bit unique value that designates
                        which namespace to retrieve a value from.
  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         Pointer to the buffer to set.

  @return The status of the set operation.

**/



/**
  Sets an boolean PCD token value based on a GUID and a token name.

  Sets the boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/



/**
  This function provides a means by which SKU support can be established in the PCD infrastructure.

  Sets the current SKU in the PCD database to the value specified by SkuId.  SkuId is returned.

  @param  SkuId   The SKU value that will be used when the PCD service retrieves and sets values
                  associated with a PCD token.

  @return  Return the SKU ID that was set.

**/
UINTN
__cdecl
LibPcdSetSku (
   UINTN  SkuId
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 8-bit value for the token specified by TokenNumber.

**/
UINT8
__cdecl
LibPcdGet8 (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 16-bit value for the token specified by TokenNumber.

**/
UINT16
__cdecl
LibPcdGet16 (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 32-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 32-bit value for the token specified by TokenNumber.

**/
UINT32
__cdecl
LibPcdGet32 (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 64-bit value for the token specified by TokenNumber.

**/
UINT64
__cdecl
LibPcdGet64 (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the pointer to the token specified by TokenNumber.

**/
void *
__cdecl
LibPcdGetPtr (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the Boolean value of the token specified by TokenNumber.

**/
BOOLEAN
__cdecl
LibPcdGetBool (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve the size of a given PCD token.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the size of the token specified by TokenNumber.

**/
UINTN
__cdecl
LibPcdGetSize (
   UINTN  TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT8.

**/
UINT8
__cdecl
LibPcdGetEx8 (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT16.

**/
UINT16
__cdecl
LibPcdGetEx16 (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  Returns the 32-bit value for the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT32.

**/
UINT32
__cdecl
LibPcdGetEx32 (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the UINT64.

**/
UINT64
__cdecl
LibPcdGetEx64 (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the VOID* pointer.

**/
void *
__cdecl
LibPcdGetExPtr (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the BOOLEAN.

**/
BOOLEAN
__cdecl
LibPcdGetExBool (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the size.

**/
UINTN
__cdecl
LibPcdGetExSize (
   const GUID  *Guid,
   UINTN       TokenNumber
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet8S (
   UINTN  TokenNumber,
   UINT8  Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet16S (
   UINTN   TokenNumber,
   UINT16  Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet32S (
   UINTN   TokenNumber,
   UINT32  Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet64S (
   UINTN   TokenNumber,
   UINT64  Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the
  maximum size supported by TokenName and RETURN_INVALID_PARAMETER must be returned.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetPtrS (
         UINTN  TokenNumber,
      UINTN  *SizeOfBuffer,
   const void   *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetBoolS (
   UINTN    TokenNumber,
   BOOLEAN  Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx8S (
   const GUID  *Guid,
   UINTN       TokenNumber,
   UINT8       Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx16S (
   const GUID  *Guid,
   UINTN       TokenNumber,
   UINT16      Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx32S (
   const GUID  *Guid,
   UINTN       TokenNumber,
   UINT32      Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx64S (
   const GUID  *Guid,
   UINTN       TokenNumber,
   UINT64      Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified by
  Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      Guid          Pointer to a 128-bit unique value that
                                designates which namespace to set a value from.
  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExPtrS (
   const GUID   *Guid,
         UINTN  TokenNumber,
      UINTN  *SizeOfBuffer,
         void   *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExBoolS (
   const GUID  *Guid,
   UINTN       TokenNumber,
   BOOLEAN     Value
  );

/**
  This notification function serves two purposes.

  Firstly, it notifies the module that did the registration that the value of this
  PCD token has been set.
  Secondly, it provides a mechanism for the module that did the registration to intercept
  the set operation and override the value been set if necessary. After the invocation of
  the callback function, TokenData will be used by PCD service PEIM or driver to modify th
  internal data in PCD database.

  @param[in]      CallBackGuid    The PCD token GUID being set.
  @param[in]      CallBackToken   The PCD token number being set.
  @param[in, out] TokenData       A pointer to the token data being set.
  @param[in]      TokenDataSize   The size, in bytes, of the data being set.

**/
typedef
void
(__cdecl *PCD_CALLBACK)(
          const GUID        *CallBackGuid  ,
          UINTN             CallBackToken,
       void              *TokenData,
          UINTN             TokenDataSize
  );

/**
  Set up a notification function that is called when a specified token is set.

  When the token specified by TokenNumber and Guid is set,
  then notification function specified by NotificationFunction is called.
  If Guid is NULL, then the default token space is used.
  If NotificationFunction is NULL, then ASSERT().

  @param[in]  Guid                  Pointer to a 128-bit unique value that designates which
                                    namespace to set a value from.  If NULL, then the default
                                    token space is used.
  @param[in]  TokenNumber           The PCD token number to monitor.
  @param[in]  NotificationFunction  The function to call when the token
                                    specified by Guid and TokenNumber is set.

**/
void
__cdecl
LibPcdCallbackOnSet (
   const GUID    *Guid        ,
   UINTN         TokenNumber,
   PCD_CALLBACK  NotificationFunction
  );

/**
  Disable a notification function that was established with LibPcdCallbackonSet().

  Disable a notification function that was previously established with LibPcdCallbackOnSet().
  If NotificationFunction is NULL, then ASSERT().
  If LibPcdCallbackOnSet() was not previously called with Guid, TokenNumber,
  and NotificationFunction, then ASSERT().

  @param[in]  Guid                 Specify the GUID token space.
  @param[in]  TokenNumber          Specify the token number.
  @param[in]  NotificationFunction The callback function to be unregistered.

**/
void
__cdecl
LibPcdCancelCallback (
   const GUID    *Guid        ,
   UINTN         TokenNumber,
   PCD_CALLBACK  NotificationFunction
  );

/**
  Retrieves the next token in a token space.

  Retrieves the next PCD token number from the token space specified by Guid.
  If Guid is NULL, then the default token space is used.  If TokenNumber is 0,
  then the first token number is returned.  Otherwise, the token number that
  follows TokenNumber in the token space is returned.  If TokenNumber is the last
  token number in the token space, then 0 is returned.

  If TokenNumber is not 0 and is not in the token space specified by Guid, then ASSERT().

  @param[in]  Guid        Pointer to a 128-bit unique value that designates which namespace
                          to set a value from.  If NULL, then the default token space is used.
  @param[in]  TokenNumber The previous PCD token number.  If 0, then retrieves the first PCD
                          token number.

  @return The next valid token number.

**/
UINTN
__cdecl
LibPcdGetNextToken (
   const GUID  *Guid        ,
   UINTN       TokenNumber
  );

/**
  Used to retrieve the list of available PCD token space GUIDs.

  Returns the PCD token space GUID that follows TokenSpaceGuid in the list of token spaces
  in the platform.
  If TokenSpaceGuid is NULL, then a pointer to the first PCD token spaces returned.
  If TokenSpaceGuid is the last PCD token space GUID in the list, then NULL is returned.

  @param  TokenSpaceGuid  Pointer to the a PCD token space GUID

  @return The next valid token namespace.

**/
GUID *
__cdecl
LibPcdGetNextTokenSpace (
   const GUID  *TokenSpaceGuid
  );

/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer.  Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtr (
          void  *PatchVariable,
          UINTN  MaximumDatumSize,
       UINTN  *SizeOfBuffer,
   const  void   *Buffer
  );

/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrS (
        void   *PatchVariable,
         UINTN  MaximumDatumSize,
      UINTN  *SizeOfBuffer,
   const void   *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer. Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtrAndSize (
         void   *PatchVariable,
         UINTN  *SizeOfPatchVariable,
          UINTN  MaximumDatumSize,
       UINTN  *SizeOfBuffer,
   const  void   *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrAndSizeS (
        void   *PatchVariable,
        UINTN  *SizeOfPatchVariable,
         UINTN  MaximumDatumSize,
      UINTN  *SizeOfBuffer,
   const void   *Buffer
  );

typedef enum {
  PCD_TYPE_8,
  PCD_TYPE_16,
  PCD_TYPE_32,
  PCD_TYPE_64,
  PCD_TYPE_BOOL,
  PCD_TYPE_PTR
} PCD_TYPE;

typedef struct {
  ///
  /// The returned information associated with the requested TokenNumber. If
  /// TokenNumber is 0, then PcdType is set to PCD_TYPE_8.
  ///
  PCD_TYPE    PcdType;
  ///
  /// The size of the data in bytes associated with the TokenNumber specified. If
  /// TokenNumber is 0, then PcdSize is set 0.
  ///
  UINTN       PcdSize;
  ///
  /// The null-terminated ASCII string associated with a given token. If the
  /// TokenNumber specified was 0, then this field corresponds to the null-terminated
  /// ASCII string associated with the token's namespace Guid. If NULL, there is no
  /// name associated with this request.
  ///
  CHAR8       *PcdName;
} PCD_INFO;

/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the default token space specified, then ASSERT().

  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfo (
          UINTN     TokenNumber,
         PCD_INFO  *PcdInfo
  );

/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the token space specified by Guid, then ASSERT().

  @param[in]    Guid        The 128-bit unique value that designates the namespace from which to extract the value.
  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfoEx (
   const  GUID      *Guid,
          UINTN     TokenNumber,
         PCD_INFO  *PcdInfo
  );

/**
  Retrieve the currently set SKU Id.

  @return   The currently set SKU Id. If the platform has not set at a SKU Id, then the
            default SKU Id value of 0 is returned. If the platform has set a SKU Id, then the currently set SKU
            Id is returned.
**/
UINTN
__cdecl
LibPcdGetSku (
  void
  );

#line 1677 "D:\\uefi_specs_personal_collections\\edk2\\MdePkg\\Include\\Library/PcdLib.h"
#line 18 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\AutoGen.h"

extern GUID  gEfiCallerIdGuid;
extern GUID  gEdkiiDscPlatformGuid;
extern CHAR8 *gEfiCallerBaseName;






// Guids
extern EFI_GUID gEfiIfrTianoGuid;
extern EFI_GUID gRamDiskFormSetGuid;
extern EFI_GUID gEfiVirtualDiskGuid;
extern EFI_GUID gEfiFileInfoGuid;
extern EFI_GUID gEfiMdeModulePkgTokenSpaceGuid;
extern EFI_GUID gEfiMdePkgTokenSpaceGuid;
extern EFI_GUID gUefiOvmfPkgTokenSpaceGuid;
extern EFI_GUID gEfiEventReadyToBootGuid;
extern EFI_GUID gEfiEventAfterReadyToBootGuid;
extern EFI_GUID gEfiEventLegacyBootGuid;
extern EFI_GUID gEfiGlobalVariableGuid;
extern EFI_GUID gEfiAcpi20TableGuid;
extern EFI_GUID gEfiAcpi10TableGuid;
extern EFI_GUID gEdkiiIfrBitVarstoreGuid;
extern EFI_GUID gEfiHobListGuid;
extern EFI_GUID gEfiFileSystemVolumeLabelInfoIdGuid;

// Protocols
extern EFI_GUID gEfiRamDiskProtocolGuid;
extern EFI_GUID gEfiHiiConfigAccessProtocolGuid;
extern EFI_GUID gEfiDevicePathProtocolGuid;
extern EFI_GUID gEfiBlockIoProtocolGuid;
extern EFI_GUID gEfiBlockIo2ProtocolGuid;
extern EFI_GUID gEfiAcpiTableProtocolGuid;
extern EFI_GUID gEfiAcpiSdtProtocolGuid;
extern EFI_GUID gPcdProtocolGuid;
extern EFI_GUID gEfiPcdProtocolGuid;
extern EFI_GUID gGetPcdInfoProtocolGuid;
extern EFI_GUID gEfiGetPcdInfoProtocolGuid;
extern EFI_GUID gEfiDevicePathUtilitiesProtocolGuid;
extern EFI_GUID gEfiDevicePathToTextProtocolGuid;
extern EFI_GUID gEfiDevicePathFromTextProtocolGuid;
extern EFI_GUID gEfiHiiFontProtocolGuid;
extern EFI_GUID gEfiHiiStringProtocolGuid;
extern EFI_GUID gEfiHiiImageProtocolGuid;
extern EFI_GUID gEfiHiiDatabaseProtocolGuid;
extern EFI_GUID gEfiHiiConfigRoutingProtocolGuid;
extern EFI_GUID gEfiDriverBindingProtocolGuid;
extern EFI_GUID gEfiSimpleTextOutProtocolGuid;
extern EFI_GUID gEfiGraphicsOutputProtocolGuid;
extern EFI_GUID gEfiSimpleFileSystemProtocolGuid;
extern EFI_GUID gEfiUgaDrawProtocolGuid;
extern EFI_GUID gEfiComponentNameProtocolGuid;
extern EFI_GUID gEfiComponentName2ProtocolGuid;
extern EFI_GUID gEfiDriverConfigurationProtocolGuid;
extern EFI_GUID gEfiDriverConfiguration2ProtocolGuid;
extern EFI_GUID gEfiDriverDiagnosticsProtocolGuid;
extern EFI_GUID gEfiDriverDiagnostics2ProtocolGuid;
extern EFI_GUID gEfiFormBrowser2ProtocolGuid;
extern EFI_GUID gEfiLoadedImageProtocolGuid;
extern EFI_GUID gEfiFirmwareVolume2ProtocolGuid;
extern EFI_GUID gEfiLoadFileProtocolGuid;
extern EFI_GUID gEfiLoadFile2ProtocolGuid;

// Definition of SkuId Array
extern UINT64 _gPcd_SkuId_Array[];

// Definition of PCDs used in this module



extern const UINT8 _gPcd_FixedAtBuild_PcdAcpiDefaultOemId[7];



//#define _PCD_SET_MODE_PTR_PcdAcpiDefaultOemId  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD





extern const  UINT64  _gPcd_FixedAtBuild_PcdAcpiDefaultOemTableId;

//#define _PCD_SET_MODE_64_PcdAcpiDefaultOemTableId  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD





extern const  UINT32  _gPcd_FixedAtBuild_PcdAcpiDefaultOemRevision;

//#define _PCD_SET_MODE_32_PcdAcpiDefaultOemRevision  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD





extern const  UINT32  _gPcd_FixedAtBuild_PcdAcpiDefaultCreatorId;

//#define _PCD_SET_MODE_32_PcdAcpiDefaultCreatorId  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD





extern const  UINT32  _gPcd_FixedAtBuild_PcdAcpiDefaultCreatorRevision;

//#define _PCD_SET_MODE_32_PcdAcpiDefaultCreatorRevision  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD

// Definition of PCDs used in libraries is in AutoGen.c


EFI_STATUS
__cdecl
RamDiskDxeEntryPoint (
   EFI_HANDLE        ImageHandle,
   EFI_SYSTEM_TABLE  *SystemTable
  );



EFI_STATUS
__cdecl
RamDiskDxeUnload (
   EFI_HANDLE        ImageHandle
  );

#line 1 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\RamDiskDxeStrDefs.h"
/**
  DO NOT EDIT
  FILE auto-generated
  Module name:
    RamDiskDxeStrDefs.h
  Abstract:       Auto-generated RamDiskDxeStrDefs.h for building module or library.
**/





//
//Unicode String ID
//
// #define $LANGUAGE_NAME                                       0x0000 // not referenced
// #define $PRINTABLE_LANGUAGE_NAME                             0x0001 // not referenced























// #define STR_ADD_RAW_FORM_SUBTITLE_TEXT                       0x0019 // not referenced

extern unsigned char RamDiskDxeStrings[];








































#line 85 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\RamDiskDxeStrDefs.h"
#line 147 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\AutoGen.h"






#line 154 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\DEBUG\\AutoGen.h"
#line 1 "d:\\uefi_specs_personal_collections\\csdn\\Build\\OvmfX64\\DEBUG_VS2019\\X64\\MdeModulePkg\\Universal\\Disk\\RamDiskDxe\\RamDiskDxe\\OUTPUT\\.\\RamDisk.i"


/** @file
  The definition block in ACPI table for NVDIMM root device.

Copyright (c) 2016, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/

DefinitionBlock (
  "RamDisk.aml",
  "SSDT",
  2,
  "INTEL ",
  "RamDisk ",
  0x1000
  )
{
  Scope (\_SB)
  {
    Device (NVDR)
    {
      //
      // Define _HID, "ACPI0012" NVDIMM Root Device
      //
      Name (_HID, "ACPI0012")

      //
      // Readable name of this device
      //
      Name (_STR, Unicode ("NVDIMM Root Device"))

      Method (_STA, 0)
      {
        Return (0x0f)
      }
    }
  }
}
